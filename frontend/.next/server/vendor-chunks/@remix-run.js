"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@remix-run";
exports.ids = ["vendor-chunks/@remix-run"];
exports.modules = {

/***/ "(ssr)/./node_modules/@remix-run/router/dist/router.js":
/*!*******************************************************!*\
  !*** ./node_modules/@remix-run/router/dist/router.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* binding */ AbortedDeferredError),\n/* harmony export */   Action: () => (/* binding */ Action),\n/* harmony export */   IDLE_BLOCKER: () => (/* binding */ IDLE_BLOCKER),\n/* harmony export */   IDLE_FETCHER: () => (/* binding */ IDLE_FETCHER),\n/* harmony export */   IDLE_NAVIGATION: () => (/* binding */ IDLE_NAVIGATION),\n/* harmony export */   UNSAFE_DEFERRED_SYMBOL: () => (/* binding */ UNSAFE_DEFERRED_SYMBOL),\n/* harmony export */   UNSAFE_DeferredData: () => (/* binding */ DeferredData),\n/* harmony export */   UNSAFE_ErrorResponseImpl: () => (/* binding */ ErrorResponseImpl),\n/* harmony export */   UNSAFE_convertRouteMatchToUiMatch: () => (/* binding */ convertRouteMatchToUiMatch),\n/* harmony export */   UNSAFE_convertRoutesToDataRoutes: () => (/* binding */ convertRoutesToDataRoutes),\n/* harmony export */   UNSAFE_getResolveToMatches: () => (/* binding */ getResolveToMatches),\n/* harmony export */   UNSAFE_invariant: () => (/* binding */ invariant),\n/* harmony export */   UNSAFE_warning: () => (/* binding */ warning),\n/* harmony export */   createBrowserHistory: () => (/* binding */ createBrowserHistory),\n/* harmony export */   createHashHistory: () => (/* binding */ createHashHistory),\n/* harmony export */   createMemoryHistory: () => (/* binding */ createMemoryHistory),\n/* harmony export */   createPath: () => (/* binding */ createPath),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   createStaticHandler: () => (/* binding */ createStaticHandler),\n/* harmony export */   defer: () => (/* binding */ defer),\n/* harmony export */   generatePath: () => (/* binding */ generatePath),\n/* harmony export */   getStaticContextFromError: () => (/* binding */ getStaticContextFromError),\n/* harmony export */   getToPathname: () => (/* binding */ getToPathname),\n/* harmony export */   isDeferredData: () => (/* binding */ isDeferredData),\n/* harmony export */   isRouteErrorResponse: () => (/* binding */ isRouteErrorResponse),\n/* harmony export */   joinPaths: () => (/* binding */ joinPaths),\n/* harmony export */   json: () => (/* binding */ json),\n/* harmony export */   matchPath: () => (/* binding */ matchPath),\n/* harmony export */   matchRoutes: () => (/* binding */ matchRoutes),\n/* harmony export */   normalizePathname: () => (/* binding */ normalizePathname),\n/* harmony export */   parsePath: () => (/* binding */ parsePath),\n/* harmony export */   redirect: () => (/* binding */ redirect),\n/* harmony export */   redirectDocument: () => (/* binding */ redirectDocument),\n/* harmony export */   resolvePath: () => (/* binding */ resolvePath),\n/* harmony export */   resolveTo: () => (/* binding */ resolveTo),\n/* harmony export */   stripBasename: () => (/* binding */ stripBasename)\n/* harmony export */ });\n/**\n * @remix-run/router v1.15.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Actions represent the type of change to a location value.\n */ var Action;\n(function(Action) {\n    /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */ Action[\"Pop\"] = \"POP\";\n    /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */ Action[\"Push\"] = \"PUSH\";\n    /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */ Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\nconst PopStateEventType = \"popstate\";\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */ function createMemoryHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    let { initialEntries = [\n        \"/\"\n    ], initialIndex, v5Compat = false } = options;\n    let entries; // Declare so we can access from createMemoryLocation\n    entries = initialEntries.map((entry, index)=>createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index === 0 ? \"default\" : undefined));\n    let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n    let action = Action.Pop;\n    let listener = null;\n    function clampIndex(n) {\n        return Math.min(Math.max(n, 0), entries.length - 1);\n    }\n    function getCurrentLocation() {\n        return entries[index];\n    }\n    function createMemoryLocation(to, state, key) {\n        if (state === void 0) {\n            state = null;\n        }\n        let location = createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\n        warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in memory history: \" + JSON.stringify(to));\n        return location;\n    }\n    function createHref(to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    let history = {\n        get index () {\n            return index;\n        },\n        get action () {\n            return action;\n        },\n        get location () {\n            return getCurrentLocation();\n        },\n        createHref,\n        createURL (to) {\n            return new URL(createHref(to), \"http://localhost\");\n        },\n        encodeLocation (to) {\n            let path = typeof to === \"string\" ? parsePath(to) : to;\n            return {\n                pathname: path.pathname || \"\",\n                search: path.search || \"\",\n                hash: path.hash || \"\"\n            };\n        },\n        push (to, state) {\n            action = Action.Push;\n            let nextLocation = createMemoryLocation(to, state);\n            index += 1;\n            entries.splice(index, entries.length, nextLocation);\n            if (v5Compat && listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta: 1\n                });\n            }\n        },\n        replace (to, state) {\n            action = Action.Replace;\n            let nextLocation = createMemoryLocation(to, state);\n            entries[index] = nextLocation;\n            if (v5Compat && listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta: 0\n                });\n            }\n        },\n        go (delta) {\n            action = Action.Pop;\n            let nextIndex = clampIndex(index + delta);\n            let nextLocation = entries[nextIndex];\n            index = nextIndex;\n            if (listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta\n                });\n            }\n        },\n        listen (fn) {\n            listener = fn;\n            return ()=>{\n                listener = null;\n            };\n        }\n    };\n    return history;\n}\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */ function createBrowserHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    function createBrowserLocation(window1, globalHistory) {\n        let { pathname, search, hash } = window1.location;\n        return createLocation(\"\", {\n            pathname,\n            search,\n            hash\n        }, // state defaults to `null` because `window.history.state` does\n        globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createBrowserHref(window1, to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */ function createHashHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    function createHashLocation(window1, globalHistory) {\n        let { pathname = \"/\", search = \"\", hash = \"\" } = parsePath(window1.location.hash.substr(1));\n        // Hash URL should always have a leading / just like window.location.pathname\n        // does, so if an app ends up at a route like /#something then we add a\n        // leading slash so all of our path-matching behaves the same as if it would\n        // in a browser router.  This is particularly important when there exists a\n        // root splat route (<Route path=\"*\">) since that matches internally against\n        // \"/*\" and we'd expect /#something to 404 in a hash router app.\n        if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n            pathname = \"/\" + pathname;\n        }\n        return createLocation(\"\", {\n            pathname,\n            search,\n            hash\n        }, // state defaults to `null` because `window.history.state` does\n        globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createHashHref(window1, to) {\n        let base = window1.document.querySelector(\"base\");\n        let href = \"\";\n        if (base && base.getAttribute(\"href\")) {\n            let url = window1.location.href;\n            let hashIndex = url.indexOf(\"#\");\n            href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n        }\n        return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n    }\n    function validateHashLocation(location, to) {\n        warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\");\n    }\n    return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\nfunction invariant(value, message) {\n    if (value === false || value === null || typeof value === \"undefined\") {\n        throw new Error(message);\n    }\n}\nfunction warning(cond, message) {\n    if (!cond) {\n        // eslint-disable-next-line no-console\n        if (typeof console !== \"undefined\") console.warn(message);\n        try {\n            // Welcome to debugging history!\n            //\n            // This error is thrown as a convenience, so you can more easily\n            // find the source for a warning that appears in the console by\n            // enabling \"pause on exceptions\" in your JavaScript debugger.\n            throw new Error(message);\n        // eslint-disable-next-line no-empty\n        } catch (e) {}\n    }\n}\nfunction createKey() {\n    return Math.random().toString(36).substr(2, 8);\n}\n/**\n * For browser-based histories, we combine the state and key into an object\n */ function getHistoryState(location, index) {\n    return {\n        usr: location.state,\n        key: location.key,\n        idx: index\n    };\n}\n/**\n * Creates a Location object with a unique key from the given Path\n */ function createLocation(current, to, state, key) {\n    if (state === void 0) {\n        state = null;\n    }\n    let location = _extends({\n        pathname: typeof current === \"string\" ? current : current.pathname,\n        search: \"\",\n        hash: \"\"\n    }, typeof to === \"string\" ? parsePath(to) : to, {\n        state,\n        // TODO: This could be cleaned up.  push/replace should probably just take\n        // full Locations now and avoid the need to run through this flow at all\n        // But that's a pretty big refactor to the current test suite so going to\n        // keep as is for the time being and just let any incoming keys take precedence\n        key: to && to.key || key || createKey()\n    });\n    return location;\n}\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */ function createPath(_ref) {\n    let { pathname = \"/\", search = \"\", hash = \"\" } = _ref;\n    if (search && search !== \"?\") pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n    if (hash && hash !== \"#\") pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n    return pathname;\n}\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */ function parsePath(path) {\n    let parsedPath = {};\n    if (path) {\n        let hashIndex = path.indexOf(\"#\");\n        if (hashIndex >= 0) {\n            parsedPath.hash = path.substr(hashIndex);\n            path = path.substr(0, hashIndex);\n        }\n        let searchIndex = path.indexOf(\"?\");\n        if (searchIndex >= 0) {\n            parsedPath.search = path.substr(searchIndex);\n            path = path.substr(0, searchIndex);\n        }\n        if (path) {\n            parsedPath.pathname = path;\n        }\n    }\n    return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    let { window: window1 = document.defaultView, v5Compat = false } = options;\n    let globalHistory = window1.history;\n    let action = Action.Pop;\n    let listener = null;\n    let index = getIndex();\n    // Index should only be null when we initialize. If not, it's because the\n    // user called history.pushState or history.replaceState directly, in which\n    // case we should log a warning as it will result in bugs.\n    if (index == null) {\n        index = 0;\n        globalHistory.replaceState(_extends({}, globalHistory.state, {\n            idx: index\n        }), \"\");\n    }\n    function getIndex() {\n        let state = globalHistory.state || {\n            idx: null\n        };\n        return state.idx;\n    }\n    function handlePop() {\n        action = Action.Pop;\n        let nextIndex = getIndex();\n        let delta = nextIndex == null ? null : nextIndex - index;\n        index = nextIndex;\n        if (listener) {\n            listener({\n                action,\n                location: history.location,\n                delta\n            });\n        }\n    }\n    function push(to, state) {\n        action = Action.Push;\n        let location = createLocation(history.location, to, state);\n        if (validateLocation) validateLocation(location, to);\n        index = getIndex() + 1;\n        let historyState = getHistoryState(location, index);\n        let url = history.createHref(location);\n        // try...catch because iOS limits us to 100 pushState calls :/\n        try {\n            globalHistory.pushState(historyState, \"\", url);\n        } catch (error) {\n            // If the exception is because `state` can't be serialized, let that throw\n            // outwards just like a replace call would so the dev knows the cause\n            // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n            // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n            if (error instanceof DOMException && error.name === \"DataCloneError\") {\n                throw error;\n            }\n            // They are going to lose state here, but there is no real\n            // way to warn them about it since the page will refresh...\n            window1.location.assign(url);\n        }\n        if (v5Compat && listener) {\n            listener({\n                action,\n                location: history.location,\n                delta: 1\n            });\n        }\n    }\n    function replace(to, state) {\n        action = Action.Replace;\n        let location = createLocation(history.location, to, state);\n        if (validateLocation) validateLocation(location, to);\n        index = getIndex();\n        let historyState = getHistoryState(location, index);\n        let url = history.createHref(location);\n        globalHistory.replaceState(historyState, \"\", url);\n        if (v5Compat && listener) {\n            listener({\n                action,\n                location: history.location,\n                delta: 0\n            });\n        }\n    }\n    function createURL(to) {\n        // window.location.origin is \"null\" (the literal string value) in Firefox\n        // under certain conditions, notably when serving from a local HTML file\n        // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n        let base = window1.location.origin !== \"null\" ? window1.location.origin : window1.location.href;\n        let href = typeof to === \"string\" ? to : createPath(to);\n        // Treating this as a full URL will strip any trailing spaces so we need to\n        // pre-encode them since they might be part of a matching splat param from\n        // an ancestor route\n        href = href.replace(/ $/, \"%20\");\n        invariant(base, \"No window.location.(origin|href) available to create URL for href: \" + href);\n        return new URL(href, base);\n    }\n    let history = {\n        get action () {\n            return action;\n        },\n        get location () {\n            return getLocation(window1, globalHistory);\n        },\n        listen (fn) {\n            if (listener) {\n                throw new Error(\"A history only accepts one active listener\");\n            }\n            window1.addEventListener(PopStateEventType, handlePop);\n            listener = fn;\n            return ()=>{\n                window1.removeEventListener(PopStateEventType, handlePop);\n                listener = null;\n            };\n        },\n        createHref (to) {\n            return createHref(window1, to);\n        },\n        createURL,\n        encodeLocation (to) {\n            // Encode a Location the same way window.location would\n            let url = createURL(to);\n            return {\n                pathname: url.pathname,\n                search: url.search,\n                hash: url.hash\n            };\n        },\n        push,\n        replace,\n        go (n) {\n            return globalHistory.go(n);\n        }\n    };\n    return history;\n}\n//#endregion\nvar ResultType;\n(function(ResultType) {\n    ResultType[\"data\"] = \"data\";\n    ResultType[\"deferred\"] = \"deferred\";\n    ResultType[\"redirect\"] = \"redirect\";\n    ResultType[\"error\"] = \"error\";\n})(ResultType || (ResultType = {}));\nconst immutableRouteKeys = new Set([\n    \"lazy\",\n    \"caseSensitive\",\n    \"path\",\n    \"id\",\n    \"index\",\n    \"children\"\n]);\nfunction isIndexRoute(route) {\n    return route.index === true;\n}\n// Walk the route tree generating unique IDs where necessary, so we are working\n// solely with AgnosticDataRouteObject's within the Router\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties, parentPath, manifest) {\n    if (parentPath === void 0) {\n        parentPath = [];\n    }\n    if (manifest === void 0) {\n        manifest = {};\n    }\n    return routes.map((route, index)=>{\n        let treePath = [\n            ...parentPath,\n            index\n        ];\n        let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n        invariant(route.index !== true || !route.children, \"Cannot specify children on an index route\");\n        invariant(!manifest[id], 'Found a route id collision on id \"' + id + '\".  Route ' + \"id's must be globally unique within Data Router usages\");\n        if (isIndexRoute(route)) {\n            let indexRoute = _extends({}, route, mapRouteProperties(route), {\n                id\n            });\n            manifest[id] = indexRoute;\n            return indexRoute;\n        } else {\n            let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {\n                id,\n                children: undefined\n            });\n            manifest[id] = pathOrLayoutRoute;\n            if (route.children) {\n                pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest);\n            }\n            return pathOrLayoutRoute;\n        }\n    });\n}\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */ function matchRoutes(routes, locationArg, basename) {\n    if (basename === void 0) {\n        basename = \"/\";\n    }\n    let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    let pathname = stripBasename(location.pathname || \"/\", basename);\n    if (pathname == null) {\n        return null;\n    }\n    let branches = flattenRoutes(routes);\n    rankRouteBranches(branches);\n    let matches = null;\n    for(let i = 0; matches == null && i < branches.length; ++i){\n        // Incoming pathnames are generally encoded from either window.location\n        // or from router.navigate, but we want to match against the unencoded\n        // paths in the route definitions.  Memory router locations won't be\n        // encoded here but there also shouldn't be anything to decode so this\n        // should be a safe operation.  This avoids needing matchRoutes to be\n        // history-aware.\n        let decoded = decodePath(pathname);\n        matches = matchRouteBranch(branches[i], decoded);\n    }\n    return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n    let { route, pathname, params } = match;\n    return {\n        id: route.id,\n        pathname,\n        params,\n        data: loaderData[route.id],\n        handle: route.handle\n    };\n}\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n    if (branches === void 0) {\n        branches = [];\n    }\n    if (parentsMeta === void 0) {\n        parentsMeta = [];\n    }\n    if (parentPath === void 0) {\n        parentPath = \"\";\n    }\n    let flattenRoute = (route, index, relativePath)=>{\n        let meta = {\n            relativePath: relativePath === undefined ? route.path || \"\" : relativePath,\n            caseSensitive: route.caseSensitive === true,\n            childrenIndex: index,\n            route\n        };\n        if (meta.relativePath.startsWith(\"/\")) {\n            invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path \"' + meta.relativePath + '\" nested under path ' + ('\"' + parentPath + '\" is not valid. An absolute child route path ') + \"must start with the combined path of all its parent routes.\");\n            meta.relativePath = meta.relativePath.slice(parentPath.length);\n        }\n        let path = joinPaths([\n            parentPath,\n            meta.relativePath\n        ]);\n        let routesMeta = parentsMeta.concat(meta);\n        // Add the children before adding this route to the array, so we traverse the\n        // route tree depth-first and child routes appear before their parents in\n        // the \"flattened\" version.\n        if (route.children && route.children.length > 0) {\n            invariant(// Our types know better, but runtime JS may not!\n            // @ts-expect-error\n            route.index !== true, \"Index routes must not have child routes. Please remove \" + ('all child routes from route path \"' + path + '\".'));\n            flattenRoutes(route.children, branches, routesMeta, path);\n        }\n        // Routes without a path shouldn't ever match by themselves unless they are\n        // index routes, so don't add them to the list of possible branches.\n        if (route.path == null && !route.index) {\n            return;\n        }\n        branches.push({\n            path,\n            score: computeScore(path, route.index),\n            routesMeta\n        });\n    };\n    routes.forEach((route, index)=>{\n        var _route$path;\n        // coarse-grain check for optional params\n        if (route.path === \"\" || !((_route$path = route.path) != null && _route$path.includes(\"?\"))) {\n            flattenRoute(route, index);\n        } else {\n            for (let exploded of explodeOptionalSegments(route.path)){\n                flattenRoute(route, index, exploded);\n            }\n        }\n    });\n    return branches;\n}\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */ function explodeOptionalSegments(path) {\n    let segments = path.split(\"/\");\n    if (segments.length === 0) return [];\n    let [first, ...rest] = segments;\n    // Optional path segments are denoted by a trailing `?`\n    let isOptional = first.endsWith(\"?\");\n    // Compute the corresponding required segment: `foo?` -> `foo`\n    let required = first.replace(/\\?$/, \"\");\n    if (rest.length === 0) {\n        // Intepret empty string as omitting an optional segment\n        // `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n        return isOptional ? [\n            required,\n            \"\"\n        ] : [\n            required\n        ];\n    }\n    let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n    let result = [];\n    // All child paths with the prefix.  Do this for all children before the\n    // optional version for all children, so we get consistent ordering where the\n    // parent optional aspect is preferred as required.  Otherwise, we can get\n    // child sections interspersed where deeper optional segments are higher than\n    // parent optional segments, where for example, /:two would explode _earlier_\n    // then /:one.  By always including the parent as required _for all children_\n    // first, we avoid this issue\n    result.push(...restExploded.map((subpath)=>subpath === \"\" ? required : [\n            required,\n            subpath\n        ].join(\"/\")));\n    // Then, if this is an optional value, add all child versions without\n    if (isOptional) {\n        result.push(...restExploded);\n    }\n    // for absolute paths, ensure `/` instead of empty segment\n    return result.map((exploded)=>path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded);\n}\nfunction rankRouteBranches(branches) {\n    branches.sort((a, b)=>a.score !== b.score ? b.score - a.score // Higher score first\n         : compareIndexes(a.routesMeta.map((meta)=>meta.childrenIndex), b.routesMeta.map((meta)=>meta.childrenIndex)));\n}\nconst paramRe = /^:[\\w-]+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = (s)=>s === \"*\";\nfunction computeScore(path, index) {\n    let segments = path.split(\"/\");\n    let initialScore = segments.length;\n    if (segments.some(isSplat)) {\n        initialScore += splatPenalty;\n    }\n    if (index) {\n        initialScore += indexRouteValue;\n    }\n    return segments.filter((s)=>!isSplat(s)).reduce((score, segment)=>score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\nfunction compareIndexes(a, b) {\n    let siblings = a.length === b.length && a.slice(0, -1).every((n, i)=>n === b[i]);\n    return siblings ? // If two routes are siblings, we should try to match the earlier sibling\n    // first. This allows people to have fine-grained control over the matching\n    // behavior by simply putting routes with identical paths in the order they\n    // want them tried.\n    a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n    // so they sort equally.\n    0;\n}\nfunction matchRouteBranch(branch, pathname) {\n    let { routesMeta } = branch;\n    let matchedParams = {};\n    let matchedPathname = \"/\";\n    let matches = [];\n    for(let i = 0; i < routesMeta.length; ++i){\n        let meta = routesMeta[i];\n        let end = i === routesMeta.length - 1;\n        let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n        let match = matchPath({\n            path: meta.relativePath,\n            caseSensitive: meta.caseSensitive,\n            end\n        }, remainingPathname);\n        if (!match) return null;\n        Object.assign(matchedParams, match.params);\n        let route = meta.route;\n        matches.push({\n            // TODO: Can this as be avoided?\n            params: matchedParams,\n            pathname: joinPaths([\n                matchedPathname,\n                match.pathname\n            ]),\n            pathnameBase: normalizePathname(joinPaths([\n                matchedPathname,\n                match.pathnameBase\n            ])),\n            route\n        });\n        if (match.pathnameBase !== \"/\") {\n            matchedPathname = joinPaths([\n                matchedPathname,\n                match.pathnameBase\n            ]);\n        }\n    }\n    return matches;\n}\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */ function generatePath(originalPath, params) {\n    if (params === void 0) {\n        params = {};\n    }\n    let path = originalPath;\n    if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n        warning(false, 'Route path \"' + path + '\" will be treated as if it were ' + ('\"' + path.replace(/\\*$/, \"/*\") + '\" because the `*` character must ') + \"always follow a `/` in the pattern. To get rid of this warning, \" + ('please change the route path to \"' + path.replace(/\\*$/, \"/*\") + '\".'));\n        path = path.replace(/\\*$/, \"/*\");\n    }\n    // ensure `/` is added at the beginning if the path is absolute\n    const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n    const stringify = (p)=>p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n    const segments = path.split(/\\/+/).map((segment, index, array)=>{\n        const isLastSegment = index === array.length - 1;\n        // only apply the splat if it's the last segment\n        if (isLastSegment && segment === \"*\") {\n            const star = \"*\";\n            // Apply the splat\n            return stringify(params[star]);\n        }\n        const keyMatch = segment.match(/^:([\\w-]+)(\\??)$/);\n        if (keyMatch) {\n            const [, key, optional] = keyMatch;\n            let param = params[key];\n            invariant(optional === \"?\" || param != null, 'Missing \":' + key + '\" param');\n            return stringify(param);\n        }\n        // Remove any optional markers from optional static segments\n        return segment.replace(/\\?$/g, \"\");\n    })// Remove empty segments\n    .filter((segment)=>!!segment);\n    return prefix + segments.join(\"/\");\n}\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */ function matchPath(pattern, pathname) {\n    if (typeof pattern === \"string\") {\n        pattern = {\n            path: pattern,\n            caseSensitive: false,\n            end: true\n        };\n    }\n    let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n    let match = pathname.match(matcher);\n    if (!match) return null;\n    let matchedPathname = match[0];\n    let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n    let captureGroups = match.slice(1);\n    let params = compiledParams.reduce((memo, _ref, index)=>{\n        let { paramName, isOptional } = _ref;\n        // We need to compute the pathnameBase here using the raw splat value\n        // instead of using params[\"*\"] later because it will be decoded then\n        if (paramName === \"*\") {\n            let splatValue = captureGroups[index] || \"\";\n            pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n        }\n        const value = captureGroups[index];\n        if (isOptional && !value) {\n            memo[paramName] = undefined;\n        } else {\n            memo[paramName] = (value || \"\").replace(/%2F/g, \"/\");\n        }\n        return memo;\n    }, {});\n    return {\n        params,\n        pathname: matchedPathname,\n        pathnameBase,\n        pattern\n    };\n}\nfunction compilePath(path, caseSensitive, end) {\n    if (caseSensitive === void 0) {\n        caseSensitive = false;\n    }\n    if (end === void 0) {\n        end = true;\n    }\n    warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), 'Route path \"' + path + '\" will be treated as if it were ' + ('\"' + path.replace(/\\*$/, \"/*\") + '\" because the `*` character must ') + \"always follow a `/` in the pattern. To get rid of this warning, \" + ('please change the route path to \"' + path.replace(/\\*$/, \"/*\") + '\".'));\n    let params = [];\n    let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n    .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n    .replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n    .replace(/\\/:([\\w-]+)(\\?)?/g, (_, paramName, isOptional)=>{\n        params.push({\n            paramName,\n            isOptional: isOptional != null\n        });\n        return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n    });\n    if (path.endsWith(\"*\")) {\n        params.push({\n            paramName: \"*\"\n        });\n        regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" // Already matched the initial /, just match the rest\n         : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n    } else if (end) {\n        // When matching to the end, ignore trailing slashes\n        regexpSource += \"\\\\/*$\";\n    } else if (path !== \"\" && path !== \"/\") {\n        // If our path is non-empty and contains anything beyond an initial slash,\n        // then we have _some_ form of path in our regex, so we should expect to\n        // match only if we find the end of this path segment.  Look for an optional\n        // non-captured trailing slash (to match a portion of the URL) or the end\n        // of the path (if we've matched to the end).  We used to do this with a\n        // word boundary but that gives false positives on routes like\n        // /user-preferences since `-` counts as a word boundary.\n        regexpSource += \"(?:(?=\\\\/|$))\";\n    } else ;\n    let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n    return [\n        matcher,\n        params\n    ];\n}\nfunction decodePath(value) {\n    try {\n        return value.split(\"/\").map((v)=>decodeURIComponent(v).replace(/\\//g, \"%2F\")).join(\"/\");\n    } catch (error) {\n        warning(false, 'The URL path \"' + value + '\" could not be decoded because it is is a ' + \"malformed URL segment. This is probably due to a bad percent \" + (\"encoding (\" + error + \").\"));\n        return value;\n    }\n}\n/**\n * @private\n */ function stripBasename(pathname, basename) {\n    if (basename === \"/\") return pathname;\n    if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n        return null;\n    }\n    // We want to leave trailing slash behavior in the user's control, so if they\n    // specify a basename with a trailing slash, we should support it\n    let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n    let nextChar = pathname.charAt(startIndex);\n    if (nextChar && nextChar !== \"/\") {\n        // pathname does not start with basename/\n        return null;\n    }\n    return pathname.slice(startIndex) || \"/\";\n}\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */ function resolvePath(to, fromPathname) {\n    if (fromPathname === void 0) {\n        fromPathname = \"/\";\n    }\n    let { pathname: toPathname, search = \"\", hash = \"\" } = typeof to === \"string\" ? parsePath(to) : to;\n    let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n    return {\n        pathname,\n        search: normalizeSearch(search),\n        hash: normalizeHash(hash)\n    };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n    let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n    let relativeSegments = relativePath.split(\"/\");\n    relativeSegments.forEach((segment)=>{\n        if (segment === \"..\") {\n            // Keep the root \"\" segment so the pathname starts at /\n            if (segments.length > 1) segments.pop();\n        } else if (segment !== \".\") {\n            segments.push(segment);\n        }\n    });\n    return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n    return \"Cannot include a '\" + char + \"' character in a manually specified \" + (\"`to.\" + field + \"` field [\" + JSON.stringify(path) + \"].  Please separate it out to the \") + (\"`to.\" + dest + \"` field. Alternatively you may provide the full path as \") + 'a string in <Link to=\"...\"> and the router will parse it for you.';\n}\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */ function getPathContributingMatches(matches) {\n    return matches.filter((match, index)=>index === 0 || match.route.path && match.route.path.length > 0);\n}\n// Return the array of pathnames for the current route matches - used to\n// generate the routePathnames input for resolveTo()\nfunction getResolveToMatches(matches, v7_relativeSplatPath) {\n    let pathMatches = getPathContributingMatches(matches);\n    // When v7_relativeSplatPath is enabled, use the full pathname for the leaf\n    // match so we include splat values for \".\" links.  See:\n    // https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329\n    if (v7_relativeSplatPath) {\n        return pathMatches.map((match, idx)=>idx === matches.length - 1 ? match.pathname : match.pathnameBase);\n    }\n    return pathMatches.map((match)=>match.pathnameBase);\n}\n/**\n * @private\n */ function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\n    if (isPathRelative === void 0) {\n        isPathRelative = false;\n    }\n    let to;\n    if (typeof toArg === \"string\") {\n        to = parsePath(toArg);\n    } else {\n        to = _extends({}, toArg);\n        invariant(!to.pathname || !to.pathname.includes(\"?\"), getInvalidPathError(\"?\", \"pathname\", \"search\", to));\n        invariant(!to.pathname || !to.pathname.includes(\"#\"), getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\n        invariant(!to.search || !to.search.includes(\"#\"), getInvalidPathError(\"#\", \"search\", \"hash\", to));\n    }\n    let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n    let toPathname = isEmptyPath ? \"/\" : to.pathname;\n    let from;\n    // Routing is relative to the current pathname if explicitly requested.\n    //\n    // If a pathname is explicitly provided in `to`, it should be relative to the\n    // route context. This is explained in `Note on `<Link to>` values` in our\n    // migration guide from v5 as a means of disambiguation between `to` values\n    // that begin with `/` and those that do not. However, this is problematic for\n    // `to` values that do not provide a pathname. `to` can simply be a search or\n    // hash string, in which case we should assume that the navigation is relative\n    // to the current location's pathname and *not* the route pathname.\n    if (toPathname == null) {\n        from = locationPathname;\n    } else {\n        let routePathnameIndex = routePathnames.length - 1;\n        // With relative=\"route\" (the default), each leading .. segment means\n        // \"go up one route\" instead of \"go up one URL segment\".  This is a key\n        // difference from how <a href> works and a major reason we call this a\n        // \"to\" value instead of a \"href\".\n        if (!isPathRelative && toPathname.startsWith(\"..\")) {\n            let toSegments = toPathname.split(\"/\");\n            while(toSegments[0] === \"..\"){\n                toSegments.shift();\n                routePathnameIndex -= 1;\n            }\n            to.pathname = toSegments.join(\"/\");\n        }\n        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n    }\n    let path = resolvePath(to, from);\n    // Ensure the pathname has a trailing slash if the original \"to\" had one\n    let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n    // Or if this was a link to the current path which has a trailing slash\n    let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n    if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n        path.pathname += \"/\";\n    }\n    return path;\n}\n/**\n * @private\n */ function getToPathname(to) {\n    // Empty strings should be treated the same as / paths\n    return to === \"\" || to.pathname === \"\" ? \"/\" : typeof to === \"string\" ? parsePath(to).pathname : to.pathname;\n}\n/**\n * @private\n */ const joinPaths = (paths)=>paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n/**\n * @private\n */ const normalizePathname = (pathname)=>pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n/**\n * @private\n */ const normalizeSearch = (search)=>!search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\n/**\n * @private\n */ const normalizeHash = (hash)=>!hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */ const json = function json(data, init) {\n    if (init === void 0) {\n        init = {};\n    }\n    let responseInit = typeof init === \"number\" ? {\n        status: init\n    } : init;\n    let headers = new Headers(responseInit.headers);\n    if (!headers.has(\"Content-Type\")) {\n        headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n    }\n    return new Response(JSON.stringify(data), _extends({}, responseInit, {\n        headers\n    }));\n};\nclass AbortedDeferredError extends Error {\n}\nclass DeferredData {\n    constructor(data, responseInit){\n        this.pendingKeysSet = new Set();\n        this.subscribers = new Set();\n        this.deferredKeys = [];\n        invariant(data && typeof data === \"object\" && !Array.isArray(data), \"defer() only accepts plain objects\");\n        // Set up an AbortController + Promise we can race against to exit early\n        // cancellation\n        let reject;\n        this.abortPromise = new Promise((_, r)=>reject = r);\n        this.controller = new AbortController();\n        let onAbort = ()=>reject(new AbortedDeferredError(\"Deferred data aborted\"));\n        this.unlistenAbortSignal = ()=>this.controller.signal.removeEventListener(\"abort\", onAbort);\n        this.controller.signal.addEventListener(\"abort\", onAbort);\n        this.data = Object.entries(data).reduce((acc, _ref2)=>{\n            let [key, value] = _ref2;\n            return Object.assign(acc, {\n                [key]: this.trackPromise(key, value)\n            });\n        }, {});\n        if (this.done) {\n            // All incoming values were resolved\n            this.unlistenAbortSignal();\n        }\n        this.init = responseInit;\n    }\n    trackPromise(key, value) {\n        if (!(value instanceof Promise)) {\n            return value;\n        }\n        this.deferredKeys.push(key);\n        this.pendingKeysSet.add(key);\n        // We store a little wrapper promise that will be extended with\n        // _data/_error props upon resolve/reject\n        let promise = Promise.race([\n            value,\n            this.abortPromise\n        ]).then((data)=>this.onSettle(promise, key, undefined, data), (error)=>this.onSettle(promise, key, error));\n        // Register rejection listeners to avoid uncaught promise rejections on\n        // errors or aborted deferred values\n        promise.catch(()=>{});\n        Object.defineProperty(promise, \"_tracked\", {\n            get: ()=>true\n        });\n        return promise;\n    }\n    onSettle(promise, key, error, data) {\n        if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {\n            this.unlistenAbortSignal();\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>error\n            });\n            return Promise.reject(error);\n        }\n        this.pendingKeysSet.delete(key);\n        if (this.done) {\n            // Nothing left to abort!\n            this.unlistenAbortSignal();\n        }\n        // If the promise was resolved/rejected with undefined, we'll throw an error as you\n        // should always resolve with a value or null\n        if (error === undefined && data === undefined) {\n            let undefinedError = new Error('Deferred data for key \"' + key + '\" resolved/rejected with `undefined`, ' + \"you must resolve/reject with a value or `null`.\");\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>undefinedError\n            });\n            this.emit(false, key);\n            return Promise.reject(undefinedError);\n        }\n        if (data === undefined) {\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>error\n            });\n            this.emit(false, key);\n            return Promise.reject(error);\n        }\n        Object.defineProperty(promise, \"_data\", {\n            get: ()=>data\n        });\n        this.emit(false, key);\n        return data;\n    }\n    emit(aborted, settledKey) {\n        this.subscribers.forEach((subscriber)=>subscriber(aborted, settledKey));\n    }\n    subscribe(fn) {\n        this.subscribers.add(fn);\n        return ()=>this.subscribers.delete(fn);\n    }\n    cancel() {\n        this.controller.abort();\n        this.pendingKeysSet.forEach((v, k)=>this.pendingKeysSet.delete(k));\n        this.emit(true);\n    }\n    async resolveData(signal) {\n        let aborted = false;\n        if (!this.done) {\n            let onAbort = ()=>this.cancel();\n            signal.addEventListener(\"abort\", onAbort);\n            aborted = await new Promise((resolve)=>{\n                this.subscribe((aborted)=>{\n                    signal.removeEventListener(\"abort\", onAbort);\n                    if (aborted || this.done) {\n                        resolve(aborted);\n                    }\n                });\n            });\n        }\n        return aborted;\n    }\n    get done() {\n        return this.pendingKeysSet.size === 0;\n    }\n    get unwrappedData() {\n        invariant(this.data !== null && this.done, \"Can only unwrap data on initialized and settled deferreds\");\n        return Object.entries(this.data).reduce((acc, _ref3)=>{\n            let [key, value] = _ref3;\n            return Object.assign(acc, {\n                [key]: unwrapTrackedPromise(value)\n            });\n        }, {});\n    }\n    get pendingKeys() {\n        return Array.from(this.pendingKeysSet);\n    }\n}\nfunction isTrackedPromise(value) {\n    return value instanceof Promise && value._tracked === true;\n}\nfunction unwrapTrackedPromise(value) {\n    if (!isTrackedPromise(value)) {\n        return value;\n    }\n    if (value._error) {\n        throw value._error;\n    }\n    return value._data;\n}\nconst defer = function defer(data, init) {\n    if (init === void 0) {\n        init = {};\n    }\n    let responseInit = typeof init === \"number\" ? {\n        status: init\n    } : init;\n    return new DeferredData(data, responseInit);\n};\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */ const redirect = function redirect(url, init) {\n    if (init === void 0) {\n        init = 302;\n    }\n    let responseInit = init;\n    if (typeof responseInit === \"number\") {\n        responseInit = {\n            status: responseInit\n        };\n    } else if (typeof responseInit.status === \"undefined\") {\n        responseInit.status = 302;\n    }\n    let headers = new Headers(responseInit.headers);\n    headers.set(\"Location\", url);\n    return new Response(null, _extends({}, responseInit, {\n        headers\n    }));\n};\n/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */ const redirectDocument = (url, init)=>{\n    let response = redirect(url, init);\n    response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n    return response;\n};\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n *\n * We don't export the class for public use since it's an implementation\n * detail, but we export the interface above so folks can build their own\n * abstractions around instances via isRouteErrorResponse()\n */ class ErrorResponseImpl {\n    constructor(status, statusText, data, internal){\n        if (internal === void 0) {\n            internal = false;\n        }\n        this.status = status;\n        this.statusText = statusText || \"\";\n        this.internal = internal;\n        if (data instanceof Error) {\n            this.data = data.toString();\n            this.error = data;\n        } else {\n            this.data = data;\n        }\n    }\n}\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */ function isRouteErrorResponse(error) {\n    return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\nconst validMutationMethodsArr = [\n    \"post\",\n    \"put\",\n    \"patch\",\n    \"delete\"\n];\nconst validMutationMethods = new Set(validMutationMethodsArr);\nconst validRequestMethodsArr = [\n    \"get\",\n    ...validMutationMethodsArr\n];\nconst validRequestMethods = new Set(validRequestMethodsArr);\nconst redirectStatusCodes = new Set([\n    301,\n    302,\n    303,\n    307,\n    308\n]);\nconst redirectPreserveMethodStatusCodes = new Set([\n    307,\n    308\n]);\nconst IDLE_NAVIGATION = {\n    state: \"idle\",\n    location: undefined,\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined\n};\nconst IDLE_FETCHER = {\n    state: \"idle\",\n    data: undefined,\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined\n};\nconst IDLE_BLOCKER = {\n    state: \"unblocked\",\n    proceed: undefined,\n    reset: undefined,\n    location: undefined\n};\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nconst defaultMapRouteProperties = (route)=>({\n        hasErrorBoundary: Boolean(route.hasErrorBoundary)\n    });\nconst TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a router and listen to history POP navigations\n */ function createRouter(init) {\n    const routerWindow = init.window ? init.window :  false ? 0 : undefined;\n    const isBrowser = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n    const isServer = !isBrowser;\n    invariant(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\n    let mapRouteProperties;\n    if (init.mapRouteProperties) {\n        mapRouteProperties = init.mapRouteProperties;\n    } else if (init.detectErrorBoundary) {\n        // If they are still using the deprecated version, wrap it with the new API\n        let detectErrorBoundary = init.detectErrorBoundary;\n        mapRouteProperties = (route)=>({\n                hasErrorBoundary: detectErrorBoundary(route)\n            });\n    } else {\n        mapRouteProperties = defaultMapRouteProperties;\n    }\n    // Routes keyed by ID\n    let manifest = {};\n    // Routes in tree format for matching\n    let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, undefined, manifest);\n    let inFlightDataRoutes;\n    let basename = init.basename || \"/\";\n    // Config driven behavior flags\n    let future = _extends({\n        v7_fetcherPersist: false,\n        v7_normalizeFormMethod: false,\n        v7_partialHydration: false,\n        v7_prependBasename: false,\n        v7_relativeSplatPath: false\n    }, init.future);\n    // Cleanup function for history\n    let unlistenHistory = null;\n    // Externally-provided functions to call on all state changes\n    let subscribers = new Set();\n    // Externally-provided object to hold scroll restoration locations during routing\n    let savedScrollPositions = null;\n    // Externally-provided function to get scroll restoration keys\n    let getScrollRestorationKey = null;\n    // Externally-provided function to get current scroll position\n    let getScrollPosition = null;\n    // One-time flag to control the initial hydration scroll restoration.  Because\n    // we don't get the saved positions from <ScrollRestoration /> until _after_\n    // the initial render, we need to manually trigger a separate updateState to\n    // send along the restoreScrollPosition\n    // Set to true if we have `hydrationData` since we assume we were SSR'd and that\n    // SSR did the initial scroll restoration.\n    let initialScrollRestored = init.hydrationData != null;\n    let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n    let initialErrors = null;\n    if (initialMatches == null) {\n        // If we do not match a user-provided-route, fall back to the root\n        // to allow the error boundary to take over\n        let error = getInternalRouterError(404, {\n            pathname: init.history.location.pathname\n        });\n        let { matches, route } = getShortCircuitMatches(dataRoutes);\n        initialMatches = matches;\n        initialErrors = {\n            [route.id]: error\n        };\n    }\n    let initialized;\n    let hasLazyRoutes = initialMatches.some((m)=>m.route.lazy);\n    let hasLoaders = initialMatches.some((m)=>m.route.loader);\n    if (hasLazyRoutes) {\n        // All initialMatches need to be loaded before we're ready.  If we have lazy\n        // functions around still then we'll need to run them in initialize()\n        initialized = false;\n    } else if (!hasLoaders) {\n        // If we've got no loaders to run, then we're good to go\n        initialized = true;\n    } else if (future.v7_partialHydration) {\n        // If partial hydration is enabled, we're initialized so long as we were\n        // provided with hydrationData for every route with a loader, and no loaders\n        // were marked for explicit hydration\n        let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;\n        let errors = init.hydrationData ? init.hydrationData.errors : null;\n        let isRouteInitialized = (m)=>{\n            // No loader, nothing to initialize\n            if (!m.route.loader) return true;\n            // Explicitly opting-in to running on hydration\n            if (m.route.loader.hydrate === true) return false;\n            // Otherwise, initialized if hydrated with data or an error\n            return loaderData && loaderData[m.route.id] !== undefined || errors && errors[m.route.id] !== undefined;\n        };\n        // If errors exist, don't consider routes below the boundary\n        if (errors) {\n            let idx = initialMatches.findIndex((m)=>errors[m.route.id] !== undefined);\n            initialized = initialMatches.slice(0, idx + 1).every(isRouteInitialized);\n        } else {\n            initialized = initialMatches.every(isRouteInitialized);\n        }\n    } else {\n        // Without partial hydration - we're initialized if we were provided any\n        // hydrationData - which is expected to be complete\n        initialized = init.hydrationData != null;\n    }\n    let router;\n    let state = {\n        historyAction: init.history.action,\n        location: init.history.location,\n        matches: initialMatches,\n        initialized,\n        navigation: IDLE_NAVIGATION,\n        // Don't restore on initial updateState() if we were SSR'd\n        restoreScrollPosition: init.hydrationData != null ? false : null,\n        preventScrollReset: false,\n        revalidation: \"idle\",\n        loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n        actionData: init.hydrationData && init.hydrationData.actionData || null,\n        errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n        fetchers: new Map(),\n        blockers: new Map()\n    };\n    // -- Stateful internal variables to manage navigations --\n    // Current navigation in progress (to be committed in completeNavigation)\n    let pendingAction = Action.Pop;\n    // Should the current navigation prevent the scroll reset if scroll cannot\n    // be restored?\n    let pendingPreventScrollReset = false;\n    // AbortController for the active navigation\n    let pendingNavigationController;\n    // Should the current navigation enable document.startViewTransition?\n    let pendingViewTransitionEnabled = false;\n    // Store applied view transitions so we can apply them on POP\n    let appliedViewTransitions = new Map();\n    // Cleanup function for persisting applied transitions to sessionStorage\n    let removePageHideEventListener = null;\n    // We use this to avoid touching history in completeNavigation if a\n    // revalidation is entirely uninterrupted\n    let isUninterruptedRevalidation = false;\n    // Use this internal flag to force revalidation of all loaders:\n    //  - submissions (completed or interrupted)\n    //  - useRevalidator()\n    //  - X-Remix-Revalidate (from redirect)\n    let isRevalidationRequired = false;\n    // Use this internal array to capture routes that require revalidation due\n    // to a cancelled deferred on action submission\n    let cancelledDeferredRoutes = [];\n    // Use this internal array to capture fetcher loads that were cancelled by an\n    // action navigation and require revalidation\n    let cancelledFetcherLoads = [];\n    // AbortControllers for any in-flight fetchers\n    let fetchControllers = new Map();\n    // Track loads based on the order in which they started\n    let incrementingLoadId = 0;\n    // Track the outstanding pending navigation data load to be compared against\n    // the globally incrementing load when a fetcher load lands after a completed\n    // navigation\n    let pendingNavigationLoadId = -1;\n    // Fetchers that triggered data reloads as a result of their actions\n    let fetchReloadIds = new Map();\n    // Fetchers that triggered redirect navigations\n    let fetchRedirectIds = new Set();\n    // Most recent href/match for fetcher.load calls for fetchers\n    let fetchLoadMatches = new Map();\n    // Ref-count mounted fetchers so we know when it's ok to clean them up\n    let activeFetchers = new Map();\n    // Fetchers that have requested a delete when using v7_fetcherPersist,\n    // they'll be officially removed after they return to idle\n    let deletedFetchers = new Set();\n    // Store DeferredData instances for active route matches.  When a\n    // route loader returns defer() we stick one in here.  Then, when a nested\n    // promise resolves we update loaderData.  If a new navigation starts we\n    // cancel active deferreds for eliminated routes.\n    let activeDeferreds = new Map();\n    // Store blocker functions in a separate Map outside of router state since\n    // we don't need to update UI state if they change\n    let blockerFunctions = new Map();\n    // Flag to ignore the next history update, so we can revert the URL change on\n    // a POP navigation that was blocked by the user without touching router state\n    let ignoreNextHistoryUpdate = false;\n    // Initialize the router, all side effects should be kicked off from here.\n    // Implemented as a Fluent API for ease of:\n    //   let router = createRouter(init).initialize();\n    function initialize() {\n        // If history informs us of a POP navigation, start the navigation but do not update\n        // state.  We'll update our own state once the navigation completes\n        unlistenHistory = init.history.listen((_ref)=>{\n            let { action: historyAction, location, delta } = _ref;\n            // Ignore this event if it was just us resetting the URL from a\n            // blocked POP navigation\n            if (ignoreNextHistoryUpdate) {\n                ignoreNextHistoryUpdate = false;\n                return;\n            }\n            warning(blockerFunctions.size === 0 || delta != null, \"You are trying to use a blocker on a POP navigation to a location \" + \"that was not created by @remix-run/router. This will fail silently in \" + \"production. This can happen if you are navigating outside the router \" + \"via `window.history.pushState`/`window.location.hash` instead of using \" + \"router navigation APIs.  This can also happen if you are using \" + \"createHashRouter and the user manually changes the URL.\");\n            let blockerKey = shouldBlockNavigation({\n                currentLocation: state.location,\n                nextLocation: location,\n                historyAction\n            });\n            if (blockerKey && delta != null) {\n                // Restore the URL to match the current UI, but don't update router state\n                ignoreNextHistoryUpdate = true;\n                init.history.go(delta * -1);\n                // Put the blocker into a blocked state\n                updateBlocker(blockerKey, {\n                    state: \"blocked\",\n                    location,\n                    proceed () {\n                        updateBlocker(blockerKey, {\n                            state: \"proceeding\",\n                            proceed: undefined,\n                            reset: undefined,\n                            location\n                        });\n                        // Re-do the same POP navigation we just blocked\n                        init.history.go(delta);\n                    },\n                    reset () {\n                        let blockers = new Map(state.blockers);\n                        blockers.set(blockerKey, IDLE_BLOCKER);\n                        updateState({\n                            blockers\n                        });\n                    }\n                });\n                return;\n            }\n            return startNavigation(historyAction, location);\n        });\n        if (isBrowser) {\n            // FIXME: This feels gross.  How can we cleanup the lines between\n            // scrollRestoration/appliedTransitions persistance?\n            restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n            let _saveAppliedTransitions = ()=>persistAppliedTransitions(routerWindow, appliedViewTransitions);\n            routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\n            removePageHideEventListener = ()=>routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\n        }\n        // Kick off initial data load if needed.  Use Pop to avoid modifying history\n        // Note we don't do any handling of lazy here.  For SPA's it'll get handled\n        // in the normal navigation flow.  For SSR it's expected that lazy modules are\n        // resolved prior to router creation since we can't go into a fallbackElement\n        // UI for SSR'd apps\n        if (!state.initialized) {\n            startNavigation(Action.Pop, state.location, {\n                initialHydration: true\n            });\n        }\n        return router;\n    }\n    // Clean up a router and it's side effects\n    function dispose() {\n        if (unlistenHistory) {\n            unlistenHistory();\n        }\n        if (removePageHideEventListener) {\n            removePageHideEventListener();\n        }\n        subscribers.clear();\n        pendingNavigationController && pendingNavigationController.abort();\n        state.fetchers.forEach((_, key)=>deleteFetcher(key));\n        state.blockers.forEach((_, key)=>deleteBlocker(key));\n    }\n    // Subscribe to state updates for the router\n    function subscribe(fn) {\n        subscribers.add(fn);\n        return ()=>subscribers.delete(fn);\n    }\n    // Update our state and notify the calling context of the change\n    function updateState(newState, opts) {\n        if (opts === void 0) {\n            opts = {};\n        }\n        state = _extends({}, state, newState);\n        // Prep fetcher cleanup so we can tell the UI which fetcher data entries\n        // can be removed\n        let completedFetchers = [];\n        let deletedFetchersKeys = [];\n        if (future.v7_fetcherPersist) {\n            state.fetchers.forEach((fetcher, key)=>{\n                if (fetcher.state === \"idle\") {\n                    if (deletedFetchers.has(key)) {\n                        // Unmounted from the UI and can be totally removed\n                        deletedFetchersKeys.push(key);\n                    } else {\n                        // Returned to idle but still mounted in the UI, so semi-remains for\n                        // revalidations and such\n                        completedFetchers.push(key);\n                    }\n                }\n            });\n        }\n        // Iterate over a local copy so that if flushSync is used and we end up\n        // removing and adding a new subscriber due to the useCallback dependencies,\n        // we don't get ourselves into a loop calling the new subscriber immediately\n        [\n            ...subscribers\n        ].forEach((subscriber)=>subscriber(state, {\n                deletedFetchers: deletedFetchersKeys,\n                unstable_viewTransitionOpts: opts.viewTransitionOpts,\n                unstable_flushSync: opts.flushSync === true\n            }));\n        // Remove idle fetchers from state since we only care about in-flight fetchers.\n        if (future.v7_fetcherPersist) {\n            completedFetchers.forEach((key)=>state.fetchers.delete(key));\n            deletedFetchersKeys.forEach((key)=>deleteFetcher(key));\n        }\n    }\n    // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n    // and setting state.[historyAction/location/matches] to the new route.\n    // - Location is a required param\n    // - Navigation will always be set to IDLE_NAVIGATION\n    // - Can pass any other state in newState\n    function completeNavigation(location, newState, _temp) {\n        var _location$state, _location$state2;\n        let { flushSync } = _temp === void 0 ? {} : _temp;\n        // Deduce if we're in a loading/actionReload state:\n        // - We have committed actionData in the store\n        // - The current navigation was a mutation submission\n        // - We're past the submitting state and into the loading state\n        // - The location being loaded is not the result of a redirect\n        let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\n        let actionData;\n        if (newState.actionData) {\n            if (Object.keys(newState.actionData).length > 0) {\n                actionData = newState.actionData;\n            } else {\n                // Empty actionData -> clear prior actionData due to an action error\n                actionData = null;\n            }\n        } else if (isActionReload) {\n            // Keep the current data if we're wrapping up the action reload\n            actionData = state.actionData;\n        } else {\n            // Clear actionData on any other completed navigations\n            actionData = null;\n        }\n        // Always preserve any existing loaderData from re-used routes\n        let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n        // On a successful navigation we can assume we got through all blockers\n        // so we can start fresh\n        let blockers = state.blockers;\n        if (blockers.size > 0) {\n            blockers = new Map(blockers);\n            blockers.forEach((_, k)=>blockers.set(k, IDLE_BLOCKER));\n        }\n        // Always respect the user flag.  Otherwise don't reset on mutation\n        // submission navigations unless they redirect\n        let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\n        if (inFlightDataRoutes) {\n            dataRoutes = inFlightDataRoutes;\n            inFlightDataRoutes = undefined;\n        }\n        if (isUninterruptedRevalidation) ;\n        else if (pendingAction === Action.Pop) ;\n        else if (pendingAction === Action.Push) {\n            init.history.push(location, location.state);\n        } else if (pendingAction === Action.Replace) {\n            init.history.replace(location, location.state);\n        }\n        let viewTransitionOpts;\n        // On POP, enable transitions if they were enabled on the original navigation\n        if (pendingAction === Action.Pop) {\n            // Forward takes precedence so they behave like the original navigation\n            let priorPaths = appliedViewTransitions.get(state.location.pathname);\n            if (priorPaths && priorPaths.has(location.pathname)) {\n                viewTransitionOpts = {\n                    currentLocation: state.location,\n                    nextLocation: location\n                };\n            } else if (appliedViewTransitions.has(location.pathname)) {\n                // If we don't have a previous forward nav, assume we're popping back to\n                // the new location and enable if that location previously enabled\n                viewTransitionOpts = {\n                    currentLocation: location,\n                    nextLocation: state.location\n                };\n            }\n        } else if (pendingViewTransitionEnabled) {\n            // Store the applied transition on PUSH/REPLACE\n            let toPaths = appliedViewTransitions.get(state.location.pathname);\n            if (toPaths) {\n                toPaths.add(location.pathname);\n            } else {\n                toPaths = new Set([\n                    location.pathname\n                ]);\n                appliedViewTransitions.set(state.location.pathname, toPaths);\n            }\n            viewTransitionOpts = {\n                currentLocation: state.location,\n                nextLocation: location\n            };\n        }\n        updateState(_extends({}, newState, {\n            actionData,\n            loaderData,\n            historyAction: pendingAction,\n            location,\n            initialized: true,\n            navigation: IDLE_NAVIGATION,\n            revalidation: \"idle\",\n            restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n            preventScrollReset,\n            blockers\n        }), {\n            viewTransitionOpts,\n            flushSync: flushSync === true\n        });\n        // Reset stateful navigation vars\n        pendingAction = Action.Pop;\n        pendingPreventScrollReset = false;\n        pendingViewTransitionEnabled = false;\n        isUninterruptedRevalidation = false;\n        isRevalidationRequired = false;\n        cancelledDeferredRoutes = [];\n        cancelledFetcherLoads = [];\n    }\n    // Trigger a navigation event, which can either be a numerical POP or a PUSH\n    // replace with an optional submission\n    async function navigate(to, opts) {\n        if (typeof to === \"number\") {\n            init.history.go(to);\n            return;\n        }\n        let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);\n        let { path, submission, error } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);\n        let currentLocation = state.location;\n        let nextLocation = createLocation(state.location, path, opts && opts.state);\n        // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n        // URL from window.location, so we need to encode it here so the behavior\n        // remains the same as POP and non-data-router usages.  new URL() does all\n        // the same encoding we'd get from a history.pushState/window.location read\n        // without having to touch history\n        nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));\n        let userReplace = opts && opts.replace != null ? opts.replace : undefined;\n        let historyAction = Action.Push;\n        if (userReplace === true) {\n            historyAction = Action.Replace;\n        } else if (userReplace === false) ;\n        else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n            // By default on submissions to the current location we REPLACE so that\n            // users don't have to double-click the back button to get to the prior\n            // location.  If the user redirects to a different location from the\n            // action/loader this will be ignored and the redirect will be a PUSH\n            historyAction = Action.Replace;\n        }\n        let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : undefined;\n        let flushSync = (opts && opts.unstable_flushSync) === true;\n        let blockerKey = shouldBlockNavigation({\n            currentLocation,\n            nextLocation,\n            historyAction\n        });\n        if (blockerKey) {\n            // Put the blocker into a blocked state\n            updateBlocker(blockerKey, {\n                state: \"blocked\",\n                location: nextLocation,\n                proceed () {\n                    updateBlocker(blockerKey, {\n                        state: \"proceeding\",\n                        proceed: undefined,\n                        reset: undefined,\n                        location: nextLocation\n                    });\n                    // Send the same navigation through\n                    navigate(to, opts);\n                },\n                reset () {\n                    let blockers = new Map(state.blockers);\n                    blockers.set(blockerKey, IDLE_BLOCKER);\n                    updateState({\n                        blockers\n                    });\n                }\n            });\n            return;\n        }\n        return await startNavigation(historyAction, nextLocation, {\n            submission,\n            // Send through the formData serialization error if we have one so we can\n            // render at the right error boundary after we match routes\n            pendingError: error,\n            preventScrollReset,\n            replace: opts && opts.replace,\n            enableViewTransition: opts && opts.unstable_viewTransition,\n            flushSync\n        });\n    }\n    // Revalidate all current loaders.  If a navigation is in progress or if this\n    // is interrupted by a navigation, allow this to \"succeed\" by calling all\n    // loaders during the next loader round\n    function revalidate() {\n        interruptActiveLoads();\n        updateState({\n            revalidation: \"loading\"\n        });\n        // If we're currently submitting an action, we don't need to start a new\n        // navigation, we'll just let the follow up loader execution call all loaders\n        if (state.navigation.state === \"submitting\") {\n            return;\n        }\n        // If we're currently in an idle state, start a new navigation for the current\n        // action/location and mark it as uninterrupted, which will skip the history\n        // update in completeNavigation\n        if (state.navigation.state === \"idle\") {\n            startNavigation(state.historyAction, state.location, {\n                startUninterruptedRevalidation: true\n            });\n            return;\n        }\n        // Otherwise, if we're currently in a loading state, just start a new\n        // navigation to the navigation.location but do not trigger an uninterrupted\n        // revalidation so that history correctly updates once the navigation completes\n        startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n            overrideNavigation: state.navigation\n        });\n    }\n    // Start a navigation to the given action/location.  Can optionally provide a\n    // overrideNavigation which will override the normalLoad in the case of a redirect\n    // navigation\n    async function startNavigation(historyAction, location, opts) {\n        // Abort any in-progress navigations and start a new one. Unset any ongoing\n        // uninterrupted revalidations unless told otherwise, since we want this\n        // new navigation to update history normally\n        pendingNavigationController && pendingNavigationController.abort();\n        pendingNavigationController = null;\n        pendingAction = historyAction;\n        isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n        // Save the current scroll position every time we start a new navigation,\n        // and track whether we should reset scroll on completion\n        saveScrollPosition(state.location, state.matches);\n        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n        pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let loadingNavigation = opts && opts.overrideNavigation;\n        let matches = matchRoutes(routesToUse, location, basename);\n        let flushSync = (opts && opts.flushSync) === true;\n        // Short circuit with a 404 on the root error boundary if we match nothing\n        if (!matches) {\n            let error = getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n            let { matches: notFoundMatches, route } = getShortCircuitMatches(routesToUse);\n            // Cancel all pending deferred on 404s since we don't keep any routes\n            cancelActiveDeferreds();\n            completeNavigation(location, {\n                matches: notFoundMatches,\n                loaderData: {},\n                errors: {\n                    [route.id]: error\n                }\n            }, {\n                flushSync\n            });\n            return;\n        }\n        // Short circuit if it's only a hash change and not a revalidation or\n        // mutation submission.\n        //\n        // Ignore on initial page loads because since the initial load will always\n        // be \"same hash\".  For example, on /page#hash and submit a <Form method=\"post\">\n        // which will default to a navigation to /page\n        if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n            completeNavigation(location, {\n                matches\n            }, {\n                flushSync\n            });\n            return;\n        }\n        // Create a controller/Request for this navigation\n        pendingNavigationController = new AbortController();\n        let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n        let pendingActionData;\n        let pendingError;\n        if (opts && opts.pendingError) {\n            // If we have a pendingError, it means the user attempted a GET submission\n            // with binary FormData so assign here and skip to handleLoaders.  That\n            // way we handle calling loaders above the boundary etc.  It's not really\n            // different from an actionError in that sense.\n            pendingError = {\n                [findNearestBoundary(matches).route.id]: opts.pendingError\n            };\n        } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n            // Call action if we received an action submission\n            let actionOutput = await handleAction(request, location, opts.submission, matches, {\n                replace: opts.replace,\n                flushSync\n            });\n            if (actionOutput.shortCircuited) {\n                return;\n            }\n            pendingActionData = actionOutput.pendingActionData;\n            pendingError = actionOutput.pendingActionError;\n            loadingNavigation = getLoadingNavigation(location, opts.submission);\n            flushSync = false;\n            // Create a GET request for the loaders\n            request = new Request(request.url, {\n                signal: request.signal\n            });\n        }\n        // Call loaders\n        let { shortCircuited, loaderData, errors } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionData, pendingError);\n        if (shortCircuited) {\n            return;\n        }\n        // Clean up now that the action/loaders have completed.  Don't clean up if\n        // we short circuited because pendingNavigationController will have already\n        // been assigned to a new controller for the next navigation\n        pendingNavigationController = null;\n        completeNavigation(location, _extends({\n            matches\n        }, pendingActionData ? {\n            actionData: pendingActionData\n        } : {}, {\n            loaderData,\n            errors\n        }));\n    }\n    // Call the action matched by the leaf route for this navigation and handle\n    // redirects/errors\n    async function handleAction(request, location, submission, matches, opts) {\n        if (opts === void 0) {\n            opts = {};\n        }\n        interruptActiveLoads();\n        // Put us in a submitting state\n        let navigation = getSubmittingNavigation(location, submission);\n        updateState({\n            navigation\n        }, {\n            flushSync: opts.flushSync === true\n        });\n        // Call our action and get the result\n        let result;\n        let actionMatch = getTargetMatch(matches, location);\n        if (!actionMatch.route.action && !actionMatch.route.lazy) {\n            result = {\n                type: ResultType.error,\n                error: getInternalRouterError(405, {\n                    method: request.method,\n                    pathname: location.pathname,\n                    routeId: actionMatch.route.id\n                })\n            };\n        } else {\n            result = await callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath);\n            if (request.signal.aborted) {\n                return {\n                    shortCircuited: true\n                };\n            }\n        }\n        if (isRedirectResult(result)) {\n            let replace;\n            if (opts && opts.replace != null) {\n                replace = opts.replace;\n            } else {\n                // If the user didn't explicity indicate replace behavior, replace if\n                // we redirected to the exact same location we're currently at to avoid\n                // double back-buttons\n                replace = result.location === state.location.pathname + state.location.search;\n            }\n            await startRedirectNavigation(state, result, {\n                submission,\n                replace\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        if (isErrorResult(result)) {\n            // Store off the pending error - we use it to determine which loaders\n            // to call and will commit it when we complete the navigation\n            let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n            // By default, all submissions are REPLACE navigations, but if the\n            // action threw an error that'll be rendered in an errorElement, we fall\n            // back to PUSH so that the user can use the back button to get back to\n            // the pre-submission form location to try again\n            if ((opts && opts.replace) !== true) {\n                pendingAction = Action.Push;\n            }\n            return {\n                // Send back an empty object we can use to clear out any prior actionData\n                pendingActionData: {},\n                pendingActionError: {\n                    [boundaryMatch.route.id]: result.error\n                }\n            };\n        }\n        if (isDeferredResult(result)) {\n            throw getInternalRouterError(400, {\n                type: \"defer-action\"\n            });\n        }\n        return {\n            pendingActionData: {\n                [actionMatch.route.id]: result.data\n            }\n        };\n    }\n    // Call all applicable loaders for the given matches, handling redirects,\n    // errors, etc.\n    async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, initialHydration, flushSync, pendingActionData, pendingError) {\n        // Figure out the right navigation we want to use for data loading\n        let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n        // If this was a redirect from an action we don't have a \"submission\" but\n        // we have it on the loading navigation so use that if available\n        let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, future.v7_partialHydration && initialHydration === true, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError);\n        // Cancel pending deferreds for no-longer-matched routes or routes we're\n        // about to reload.  Note that if this is an action reload we would have\n        // already cancelled all pending deferreds so this would be a no-op\n        cancelActiveDeferreds((routeId)=>!(matches && matches.some((m)=>m.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m)=>m.route.id === routeId));\n        pendingNavigationLoadId = ++incrementingLoadId;\n        // Short circuit if we have no loaders to run\n        if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n            let updatedFetchers = markFetchRedirectsDone();\n            completeNavigation(location, _extends({\n                matches,\n                loaderData: {},\n                // Commit pending error if we're short circuiting\n                errors: pendingError || null\n            }, pendingActionData ? {\n                actionData: pendingActionData\n            } : {}, updatedFetchers ? {\n                fetchers: new Map(state.fetchers)\n            } : {}), {\n                flushSync\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        // If this is an uninterrupted revalidation, we remain in our current idle\n        // state.  If not, we need to switch to our loading state and load data,\n        // preserving any new action data or existing action data (in the case of\n        // a revalidation interrupting an actionReload)\n        // If we have partialHydration enabled, then don't update the state for the\n        // initial data load since it's not a \"navigation\"\n        if (!isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration)) {\n            revalidatingFetchers.forEach((rf)=>{\n                let fetcher = state.fetchers.get(rf.key);\n                let revalidatingFetcher = getLoadingFetcher(undefined, fetcher ? fetcher.data : undefined);\n                state.fetchers.set(rf.key, revalidatingFetcher);\n            });\n            let actionData = pendingActionData || state.actionData;\n            updateState(_extends({\n                navigation: loadingNavigation\n            }, actionData ? Object.keys(actionData).length === 0 ? {\n                actionData: null\n            } : {\n                actionData\n            } : {}, revalidatingFetchers.length > 0 ? {\n                fetchers: new Map(state.fetchers)\n            } : {}), {\n                flushSync\n            });\n        }\n        revalidatingFetchers.forEach((rf)=>{\n            if (fetchControllers.has(rf.key)) {\n                abortFetcher(rf.key);\n            }\n            if (rf.controller) {\n                // Fetchers use an independent AbortController so that aborting a fetcher\n                // (via deleteFetcher) does not abort the triggering navigation that\n                // triggered the revalidation\n                fetchControllers.set(rf.key, rf.controller);\n            }\n        });\n        // Proxy navigation abort through to revalidation fetchers\n        let abortPendingFetchRevalidations = ()=>revalidatingFetchers.forEach((f)=>abortFetcher(f.key));\n        if (pendingNavigationController) {\n            pendingNavigationController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n        }\n        let { results, loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);\n        if (request.signal.aborted) {\n            return {\n                shortCircuited: true\n            };\n        }\n        // Clean up _after_ loaders have completed.  Don't clean up if we short\n        // circuited because fetchControllers would have been aborted and\n        // reassigned to new controllers for the next navigation\n        if (pendingNavigationController) {\n            pendingNavigationController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n        }\n        revalidatingFetchers.forEach((rf)=>fetchControllers.delete(rf.key));\n        // If any loaders returned a redirect Response, start a new REPLACE navigation\n        let redirect = findRedirect(results);\n        if (redirect) {\n            if (redirect.idx >= matchesToLoad.length) {\n                // If this redirect came from a fetcher make sure we mark it in\n                // fetchRedirectIds so it doesn't get revalidated on the next set of\n                // loader executions\n                let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n                fetchRedirectIds.add(fetcherKey);\n            }\n            await startRedirectNavigation(state, redirect.result, {\n                replace\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        // Process and commit output from loaders\n        let { loaderData, errors } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);\n        // Wire up subscribers to update loaderData as promises settle\n        activeDeferreds.forEach((deferredData, routeId)=>{\n            deferredData.subscribe((aborted)=>{\n                // Note: No need to updateState here since the TrackedPromise on\n                // loaderData is stable across resolve/reject\n                // Remove this instance if we were aborted or if promises have settled\n                if (aborted || deferredData.done) {\n                    activeDeferreds.delete(routeId);\n                }\n            });\n        });\n        // During partial hydration, preserve SSR errors for routes that don't re-run\n        if (future.v7_partialHydration && initialHydration && state.errors) {\n            Object.entries(state.errors).filter((_ref2)=>{\n                let [id] = _ref2;\n                return !matchesToLoad.some((m)=>m.route.id === id);\n            }).forEach((_ref3)=>{\n                let [routeId, error] = _ref3;\n                errors = Object.assign(errors || {}, {\n                    [routeId]: error\n                });\n            });\n        }\n        let updatedFetchers = markFetchRedirectsDone();\n        let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n        let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n        return _extends({\n            loaderData,\n            errors\n        }, shouldUpdateFetchers ? {\n            fetchers: new Map(state.fetchers)\n        } : {});\n    }\n    // Trigger a fetcher load/submit for the given fetcher key\n    function fetch(key, routeId, href, opts) {\n        if (isServer) {\n            throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. \" + \"You are likely calling a useFetcher() method in the body of your component. \" + \"Try moving it to a useEffect or a callback.\");\n        }\n        if (fetchControllers.has(key)) abortFetcher(key);\n        let flushSync = (opts && opts.unstable_flushSync) === true;\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, opts == null ? void 0 : opts.relative);\n        let matches = matchRoutes(routesToUse, normalizedPath, basename);\n        if (!matches) {\n            setFetcherError(key, routeId, getInternalRouterError(404, {\n                pathname: normalizedPath\n            }), {\n                flushSync\n            });\n            return;\n        }\n        let { path, submission, error } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);\n        if (error) {\n            setFetcherError(key, routeId, error, {\n                flushSync\n            });\n            return;\n        }\n        let match = getTargetMatch(matches, path);\n        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n        if (submission && isMutationMethod(submission.formMethod)) {\n            handleFetcherAction(key, routeId, path, match, matches, flushSync, submission);\n            return;\n        }\n        // Store off the match so we can call it's shouldRevalidate on subsequent\n        // revalidations\n        fetchLoadMatches.set(key, {\n            routeId,\n            path\n        });\n        handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission);\n    }\n    // Call the action for the matched fetcher.submit(), and then handle redirects,\n    // errors, and revalidation\n    async function handleFetcherAction(key, routeId, path, match, requestMatches, flushSync, submission) {\n        interruptActiveLoads();\n        fetchLoadMatches.delete(key);\n        if (!match.route.action && !match.route.lazy) {\n            let error = getInternalRouterError(405, {\n                method: submission.formMethod,\n                pathname: path,\n                routeId: routeId\n            });\n            setFetcherError(key, routeId, error, {\n                flushSync\n            });\n            return;\n        }\n        // Put this fetcher into it's submitting state\n        let existingFetcher = state.fetchers.get(key);\n        updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n            flushSync\n        });\n        // Call the action for the fetcher\n        let abortController = new AbortController();\n        let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\n        fetchControllers.set(key, abortController);\n        let originatingLoadId = incrementingLoadId;\n        let actionResult = await callLoaderOrAction(\"action\", fetchRequest, match, requestMatches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath);\n        if (fetchRequest.signal.aborted) {\n            // We can delete this so long as we weren't aborted by our own fetcher\n            // re-submit which would have put _new_ controller is in fetchControllers\n            if (fetchControllers.get(key) === abortController) {\n                fetchControllers.delete(key);\n            }\n            return;\n        }\n        // When using v7_fetcherPersist, we don't want errors bubbling up to the UI\n        // or redirects processed for unmounted fetchers so we just revert them to\n        // idle\n        if (future.v7_fetcherPersist && deletedFetchers.has(key)) {\n            if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {\n                updateFetcherState(key, getDoneFetcher(undefined));\n                return;\n            }\n        // Let SuccessResult's fall through for revalidation\n        } else {\n            if (isRedirectResult(actionResult)) {\n                fetchControllers.delete(key);\n                if (pendingNavigationLoadId > originatingLoadId) {\n                    // A new navigation was kicked off after our action started, so that\n                    // should take precedence over this redirect navigation.  We already\n                    // set isRevalidationRequired so all loaders for the new route should\n                    // fire unless opted out via shouldRevalidate\n                    updateFetcherState(key, getDoneFetcher(undefined));\n                    return;\n                } else {\n                    fetchRedirectIds.add(key);\n                    updateFetcherState(key, getLoadingFetcher(submission));\n                    return startRedirectNavigation(state, actionResult, {\n                        fetcherSubmission: submission\n                    });\n                }\n            }\n            // Process any non-redirect errors thrown\n            if (isErrorResult(actionResult)) {\n                setFetcherError(key, routeId, actionResult.error);\n                return;\n            }\n        }\n        if (isDeferredResult(actionResult)) {\n            throw getInternalRouterError(400, {\n                type: \"defer-action\"\n            });\n        }\n        // Start the data load for current matches, or the next location if we're\n        // in the middle of a navigation\n        let nextLocation = state.navigation.location || state.location;\n        let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n        invariant(matches, \"Didn't find any matches after fetcher action\");\n        let loadId = ++incrementingLoadId;\n        fetchReloadIds.set(key, loadId);\n        let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n        state.fetchers.set(key, loadFetcher);\n        let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, false, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, {\n            [match.route.id]: actionResult.data\n        }, undefined // No need to send through errors since we short circuit above\n        );\n        // Put all revalidating fetchers into the loading state, except for the\n        // current fetcher which we want to keep in it's current loading state which\n        // contains it's action submission info + action data\n        revalidatingFetchers.filter((rf)=>rf.key !== key).forEach((rf)=>{\n            let staleKey = rf.key;\n            let existingFetcher = state.fetchers.get(staleKey);\n            let revalidatingFetcher = getLoadingFetcher(undefined, existingFetcher ? existingFetcher.data : undefined);\n            state.fetchers.set(staleKey, revalidatingFetcher);\n            if (fetchControllers.has(staleKey)) {\n                abortFetcher(staleKey);\n            }\n            if (rf.controller) {\n                fetchControllers.set(staleKey, rf.controller);\n            }\n        });\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n        let abortPendingFetchRevalidations = ()=>revalidatingFetchers.forEach((rf)=>abortFetcher(rf.key));\n        abortController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n        let { results, loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);\n        if (abortController.signal.aborted) {\n            return;\n        }\n        abortController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n        fetchReloadIds.delete(key);\n        fetchControllers.delete(key);\n        revalidatingFetchers.forEach((r)=>fetchControllers.delete(r.key));\n        let redirect = findRedirect(results);\n        if (redirect) {\n            if (redirect.idx >= matchesToLoad.length) {\n                // If this redirect came from a fetcher make sure we mark it in\n                // fetchRedirectIds so it doesn't get revalidated on the next set of\n                // loader executions\n                let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n                fetchRedirectIds.add(fetcherKey);\n            }\n            return startRedirectNavigation(state, redirect.result);\n        }\n        // Process and commit output from loaders\n        let { loaderData, errors } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);\n        // Since we let revalidations complete even if the submitting fetcher was\n        // deleted, only put it back to idle if it hasn't been deleted\n        if (state.fetchers.has(key)) {\n            let doneFetcher = getDoneFetcher(actionResult.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n        abortStaleFetchLoads(loadId);\n        // If we are currently in a navigation loading state and this fetcher is\n        // more recent than the navigation, we want the newer data so abort the\n        // navigation and complete it with the fetcher data\n        if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n            invariant(pendingAction, \"Expected pending action\");\n            pendingNavigationController && pendingNavigationController.abort();\n            completeNavigation(state.navigation.location, {\n                matches,\n                loaderData,\n                errors,\n                fetchers: new Map(state.fetchers)\n            });\n        } else {\n            // otherwise just update with the fetcher data, preserving any existing\n            // loaderData for loaders that did not need to reload.  We have to\n            // manually merge here since we aren't going through completeNavigation\n            updateState({\n                errors,\n                loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),\n                fetchers: new Map(state.fetchers)\n            });\n            isRevalidationRequired = false;\n        }\n    }\n    // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n    async function handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission) {\n        let existingFetcher = state.fetchers.get(key);\n        updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : undefined), {\n            flushSync\n        });\n        // Call the loader for this fetcher route match\n        let abortController = new AbortController();\n        let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\n        fetchControllers.set(key, abortController);\n        let originatingLoadId = incrementingLoadId;\n        let result = await callLoaderOrAction(\"loader\", fetchRequest, match, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath);\n        // Deferred isn't supported for fetcher loads, await everything and treat it\n        // as a normal load.  resolveDeferredData will return undefined if this\n        // fetcher gets aborted, so we just leave result untouched and short circuit\n        // below if that happens\n        if (isDeferredResult(result)) {\n            result = await resolveDeferredData(result, fetchRequest.signal, true) || result;\n        }\n        // We can delete this so long as we weren't aborted by our our own fetcher\n        // re-load which would have put _new_ controller is in fetchControllers\n        if (fetchControllers.get(key) === abortController) {\n            fetchControllers.delete(key);\n        }\n        if (fetchRequest.signal.aborted) {\n            return;\n        }\n        // We don't want errors bubbling up or redirects followed for unmounted\n        // fetchers, so short circuit here if it was removed from the UI\n        if (deletedFetchers.has(key)) {\n            updateFetcherState(key, getDoneFetcher(undefined));\n            return;\n        }\n        // If the loader threw a redirect Response, start a new REPLACE navigation\n        if (isRedirectResult(result)) {\n            if (pendingNavigationLoadId > originatingLoadId) {\n                // A new navigation was kicked off after our loader started, so that\n                // should take precedence over this redirect navigation\n                updateFetcherState(key, getDoneFetcher(undefined));\n                return;\n            } else {\n                fetchRedirectIds.add(key);\n                await startRedirectNavigation(state, result);\n                return;\n            }\n        }\n        // Process any non-redirect errors thrown\n        if (isErrorResult(result)) {\n            setFetcherError(key, routeId, result.error);\n            return;\n        }\n        invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n        // Put the fetcher back into an idle state\n        updateFetcherState(key, getDoneFetcher(result.data));\n    }\n    /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */ async function startRedirectNavigation(state, redirect, _temp2) {\n        let { submission, fetcherSubmission, replace } = _temp2 === void 0 ? {} : _temp2;\n        if (redirect.revalidate) {\n            isRevalidationRequired = true;\n        }\n        let redirectLocation = createLocation(state.location, redirect.location, {\n            _isRedirect: true\n        });\n        invariant(redirectLocation, \"Expected a location on the redirect navigation\");\n        if (isBrowser) {\n            let isDocumentReload = false;\n            if (redirect.reloadDocument) {\n                // Hard reload if the response contained X-Remix-Reload-Document\n                isDocumentReload = true;\n            } else if (ABSOLUTE_URL_REGEX.test(redirect.location)) {\n                const url = init.history.createURL(redirect.location);\n                isDocumentReload = // Hard reload if it's an absolute URL to a new origin\n                url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename\n                stripBasename(url.pathname, basename) == null;\n            }\n            if (isDocumentReload) {\n                if (replace) {\n                    routerWindow.location.replace(redirect.location);\n                } else {\n                    routerWindow.location.assign(redirect.location);\n                }\n                return;\n            }\n        }\n        // There's no need to abort on redirects, since we don't detect the\n        // redirect until the action/loaders have settled\n        pendingNavigationController = null;\n        let redirectHistoryAction = replace === true ? Action.Replace : Action.Push;\n        // Use the incoming submission if provided, fallback on the active one in\n        // state.navigation\n        let { formMethod, formAction, formEncType } = state.navigation;\n        if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n            submission = getSubmissionFromNavigation(state.navigation);\n        }\n        // If this was a 307/308 submission we want to preserve the HTTP method and\n        // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n        // redirected location\n        let activeSubmission = submission || fetcherSubmission;\n        if (redirectPreserveMethodStatusCodes.has(redirect.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n            await startNavigation(redirectHistoryAction, redirectLocation, {\n                submission: _extends({}, activeSubmission, {\n                    formAction: redirect.location\n                }),\n                // Preserve this flag across redirects\n                preventScrollReset: pendingPreventScrollReset\n            });\n        } else {\n            // If we have a navigation submission, we will preserve it through the\n            // redirect navigation\n            let overrideNavigation = getLoadingNavigation(redirectLocation, submission);\n            await startNavigation(redirectHistoryAction, redirectLocation, {\n                overrideNavigation,\n                // Send fetcher submissions through for shouldRevalidate\n                fetcherSubmission,\n                // Preserve this flag across redirects\n                preventScrollReset: pendingPreventScrollReset\n            });\n        }\n    }\n    async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {\n        // Call all navigation loaders and revalidating fetcher loaders in parallel,\n        // then slice off the results into separate arrays so we can handle them\n        // accordingly\n        let results = await Promise.all([\n            ...matchesToLoad.map((match)=>callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath)),\n            ...fetchersToLoad.map((f)=>{\n                if (f.matches && f.match && f.controller) {\n                    return callLoaderOrAction(\"loader\", createClientSideRequest(init.history, f.path, f.controller.signal), f.match, f.matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath);\n                } else {\n                    let error = {\n                        type: ResultType.error,\n                        error: getInternalRouterError(404, {\n                            pathname: f.path\n                        })\n                    };\n                    return error;\n                }\n            })\n        ]);\n        let loaderResults = results.slice(0, matchesToLoad.length);\n        let fetcherResults = results.slice(matchesToLoad.length);\n        await Promise.all([\n            resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(()=>request.signal), false, state.loaderData),\n            resolveDeferredResults(currentMatches, fetchersToLoad.map((f)=>f.match), fetcherResults, fetchersToLoad.map((f)=>f.controller ? f.controller.signal : null), true)\n        ]);\n        return {\n            results,\n            loaderResults,\n            fetcherResults\n        };\n    }\n    function interruptActiveLoads() {\n        // Every interruption triggers a revalidation\n        isRevalidationRequired = true;\n        // Cancel pending route-level deferreds and mark cancelled routes for\n        // revalidation\n        cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n        // Abort in-flight fetcher loads\n        fetchLoadMatches.forEach((_, key)=>{\n            if (fetchControllers.has(key)) {\n                cancelledFetcherLoads.push(key);\n                abortFetcher(key);\n            }\n        });\n    }\n    function updateFetcherState(key, fetcher, opts) {\n        if (opts === void 0) {\n            opts = {};\n        }\n        state.fetchers.set(key, fetcher);\n        updateState({\n            fetchers: new Map(state.fetchers)\n        }, {\n            flushSync: (opts && opts.flushSync) === true\n        });\n    }\n    function setFetcherError(key, routeId, error, opts) {\n        if (opts === void 0) {\n            opts = {};\n        }\n        let boundaryMatch = findNearestBoundary(state.matches, routeId);\n        deleteFetcher(key);\n        updateState({\n            errors: {\n                [boundaryMatch.route.id]: error\n            },\n            fetchers: new Map(state.fetchers)\n        }, {\n            flushSync: (opts && opts.flushSync) === true\n        });\n    }\n    function getFetcher(key) {\n        if (future.v7_fetcherPersist) {\n            activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n            // If this fetcher was previously marked for deletion, unmark it since we\n            // have a new instance\n            if (deletedFetchers.has(key)) {\n                deletedFetchers.delete(key);\n            }\n        }\n        return state.fetchers.get(key) || IDLE_FETCHER;\n    }\n    function deleteFetcher(key) {\n        let fetcher = state.fetchers.get(key);\n        // Don't abort the controller if this is a deletion of a fetcher.submit()\n        // in it's loading phase since - we don't want to abort the corresponding\n        // revalidation and want them to complete and land\n        if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\n            abortFetcher(key);\n        }\n        fetchLoadMatches.delete(key);\n        fetchReloadIds.delete(key);\n        fetchRedirectIds.delete(key);\n        deletedFetchers.delete(key);\n        state.fetchers.delete(key);\n    }\n    function deleteFetcherAndUpdateState(key) {\n        if (future.v7_fetcherPersist) {\n            let count = (activeFetchers.get(key) || 0) - 1;\n            if (count <= 0) {\n                activeFetchers.delete(key);\n                deletedFetchers.add(key);\n            } else {\n                activeFetchers.set(key, count);\n            }\n        } else {\n            deleteFetcher(key);\n        }\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n    }\n    function abortFetcher(key) {\n        let controller = fetchControllers.get(key);\n        invariant(controller, \"Expected fetch controller: \" + key);\n        controller.abort();\n        fetchControllers.delete(key);\n    }\n    function markFetchersDone(keys) {\n        for (let key of keys){\n            let fetcher = getFetcher(key);\n            let doneFetcher = getDoneFetcher(fetcher.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n    }\n    function markFetchRedirectsDone() {\n        let doneKeys = [];\n        let updatedFetchers = false;\n        for (let key of fetchRedirectIds){\n            let fetcher = state.fetchers.get(key);\n            invariant(fetcher, \"Expected fetcher: \" + key);\n            if (fetcher.state === \"loading\") {\n                fetchRedirectIds.delete(key);\n                doneKeys.push(key);\n                updatedFetchers = true;\n            }\n        }\n        markFetchersDone(doneKeys);\n        return updatedFetchers;\n    }\n    function abortStaleFetchLoads(landedId) {\n        let yeetedKeys = [];\n        for (let [key, id] of fetchReloadIds){\n            if (id < landedId) {\n                let fetcher = state.fetchers.get(key);\n                invariant(fetcher, \"Expected fetcher: \" + key);\n                if (fetcher.state === \"loading\") {\n                    abortFetcher(key);\n                    fetchReloadIds.delete(key);\n                    yeetedKeys.push(key);\n                }\n            }\n        }\n        markFetchersDone(yeetedKeys);\n        return yeetedKeys.length > 0;\n    }\n    function getBlocker(key, fn) {\n        let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n        if (blockerFunctions.get(key) !== fn) {\n            blockerFunctions.set(key, fn);\n        }\n        return blocker;\n    }\n    function deleteBlocker(key) {\n        state.blockers.delete(key);\n        blockerFunctions.delete(key);\n    }\n    // Utility function to update blockers, ensuring valid state transitions\n    function updateBlocker(key, newBlocker) {\n        let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n        // Poor mans state machine :)\n        // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\n        invariant(blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\", \"Invalid blocker state transition: \" + blocker.state + \" -> \" + newBlocker.state);\n        let blockers = new Map(state.blockers);\n        blockers.set(key, newBlocker);\n        updateState({\n            blockers\n        });\n    }\n    function shouldBlockNavigation(_ref4) {\n        let { currentLocation, nextLocation, historyAction } = _ref4;\n        if (blockerFunctions.size === 0) {\n            return;\n        }\n        // We ony support a single active blocker at the moment since we don't have\n        // any compelling use cases for multi-blocker yet\n        if (blockerFunctions.size > 1) {\n            warning(false, \"A router only supports one blocker at a time\");\n        }\n        let entries = Array.from(blockerFunctions.entries());\n        let [blockerKey, blockerFunction] = entries[entries.length - 1];\n        let blocker = state.blockers.get(blockerKey);\n        if (blocker && blocker.state === \"proceeding\") {\n            // If the blocker is currently proceeding, we don't need to re-check\n            // it and can let this navigation continue\n            return;\n        }\n        // At this point, we know we're unblocked/blocked so we need to check the\n        // user-provided blocker function\n        if (blockerFunction({\n            currentLocation,\n            nextLocation,\n            historyAction\n        })) {\n            return blockerKey;\n        }\n    }\n    function cancelActiveDeferreds(predicate) {\n        let cancelledRouteIds = [];\n        activeDeferreds.forEach((dfd, routeId)=>{\n            if (!predicate || predicate(routeId)) {\n                // Cancel the deferred - but do not remove from activeDeferreds here -\n                // we rely on the subscribers to do that so our tests can assert proper\n                // cleanup via _internalActiveDeferreds\n                dfd.cancel();\n                cancelledRouteIds.push(routeId);\n                activeDeferreds.delete(routeId);\n            }\n        });\n        return cancelledRouteIds;\n    }\n    // Opt in to capturing and reporting scroll positions during navigations,\n    // used by the <ScrollRestoration> component\n    function enableScrollRestoration(positions, getPosition, getKey) {\n        savedScrollPositions = positions;\n        getScrollPosition = getPosition;\n        getScrollRestorationKey = getKey || null;\n        // Perform initial hydration scroll restoration, since we miss the boat on\n        // the initial updateState() because we've not yet rendered <ScrollRestoration/>\n        // and therefore have no savedScrollPositions available\n        if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n            initialScrollRestored = true;\n            let y = getSavedScrollPosition(state.location, state.matches);\n            if (y != null) {\n                updateState({\n                    restoreScrollPosition: y\n                });\n            }\n        }\n        return ()=>{\n            savedScrollPositions = null;\n            getScrollPosition = null;\n            getScrollRestorationKey = null;\n        };\n    }\n    function getScrollKey(location, matches) {\n        if (getScrollRestorationKey) {\n            let key = getScrollRestorationKey(location, matches.map((m)=>convertRouteMatchToUiMatch(m, state.loaderData)));\n            return key || location.key;\n        }\n        return location.key;\n    }\n    function saveScrollPosition(location, matches) {\n        if (savedScrollPositions && getScrollPosition) {\n            let key = getScrollKey(location, matches);\n            savedScrollPositions[key] = getScrollPosition();\n        }\n    }\n    function getSavedScrollPosition(location, matches) {\n        if (savedScrollPositions) {\n            let key = getScrollKey(location, matches);\n            let y = savedScrollPositions[key];\n            if (typeof y === \"number\") {\n                return y;\n            }\n        }\n        return null;\n    }\n    function _internalSetRoutes(newRoutes) {\n        manifest = {};\n        inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, undefined, manifest);\n    }\n    router = {\n        get basename () {\n            return basename;\n        },\n        get future () {\n            return future;\n        },\n        get state () {\n            return state;\n        },\n        get routes () {\n            return dataRoutes;\n        },\n        get window () {\n            return routerWindow;\n        },\n        initialize,\n        subscribe,\n        enableScrollRestoration,\n        navigate,\n        fetch,\n        revalidate,\n        // Passthrough to history-aware createHref used by useHref so we get proper\n        // hash-aware URLs in DOM paths\n        createHref: (to)=>init.history.createHref(to),\n        encodeLocation: (to)=>init.history.encodeLocation(to),\n        getFetcher,\n        deleteFetcher: deleteFetcherAndUpdateState,\n        dispose,\n        getBlocker,\n        deleteBlocker,\n        _internalFetchControllers: fetchControllers,\n        _internalActiveDeferreds: activeDeferreds,\n        // TODO: Remove setRoutes, it's temporary to avoid dealing with\n        // updating the tree while validating the update algorithm.\n        _internalSetRoutes\n    };\n    return router;\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\nconst UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\nfunction createStaticHandler(routes, opts) {\n    invariant(routes.length > 0, \"You must provide a non-empty routes array to createStaticHandler\");\n    let manifest = {};\n    let basename = (opts ? opts.basename : null) || \"/\";\n    let mapRouteProperties;\n    if (opts != null && opts.mapRouteProperties) {\n        mapRouteProperties = opts.mapRouteProperties;\n    } else if (opts != null && opts.detectErrorBoundary) {\n        // If they are still using the deprecated version, wrap it with the new API\n        let detectErrorBoundary = opts.detectErrorBoundary;\n        mapRouteProperties = (route)=>({\n                hasErrorBoundary: detectErrorBoundary(route)\n            });\n    } else {\n        mapRouteProperties = defaultMapRouteProperties;\n    }\n    // Config driven behavior flags\n    let future = _extends({\n        v7_relativeSplatPath: false,\n        v7_throwAbortReason: false\n    }, opts ? opts.future : null);\n    let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, undefined, manifest);\n    /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   */ async function query(request, _temp3) {\n        let { requestContext } = _temp3 === void 0 ? {} : _temp3;\n        let url = new URL(request.url);\n        let method = request.method;\n        let location = createLocation(\"\", createPath(url), null, \"default\");\n        let matches = matchRoutes(dataRoutes, location, basename);\n        // SSR supports HEAD requests while SPA doesn't\n        if (!isValidMethod(method) && method !== \"HEAD\") {\n            let error = getInternalRouterError(405, {\n                method\n            });\n            let { matches: methodNotAllowedMatches, route } = getShortCircuitMatches(dataRoutes);\n            return {\n                basename,\n                location,\n                matches: methodNotAllowedMatches,\n                loaderData: {},\n                actionData: null,\n                errors: {\n                    [route.id]: error\n                },\n                statusCode: error.status,\n                loaderHeaders: {},\n                actionHeaders: {},\n                activeDeferreds: null\n            };\n        } else if (!matches) {\n            let error = getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n            let { matches: notFoundMatches, route } = getShortCircuitMatches(dataRoutes);\n            return {\n                basename,\n                location,\n                matches: notFoundMatches,\n                loaderData: {},\n                actionData: null,\n                errors: {\n                    [route.id]: error\n                },\n                statusCode: error.status,\n                loaderHeaders: {},\n                actionHeaders: {},\n                activeDeferreds: null\n            };\n        }\n        let result = await queryImpl(request, location, matches, requestContext);\n        if (isResponse(result)) {\n            return result;\n        }\n        // When returning StaticHandlerContext, we patch back in the location here\n        // since we need it for React Context.  But this helps keep our submit and\n        // loadRouteData operating on a Request instead of a Location\n        return _extends({\n            location,\n            basename\n        }, result);\n    }\n    /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   */ async function queryRoute(request, _temp4) {\n        let { routeId, requestContext } = _temp4 === void 0 ? {} : _temp4;\n        let url = new URL(request.url);\n        let method = request.method;\n        let location = createLocation(\"\", createPath(url), null, \"default\");\n        let matches = matchRoutes(dataRoutes, location, basename);\n        // SSR supports HEAD requests while SPA doesn't\n        if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n            throw getInternalRouterError(405, {\n                method\n            });\n        } else if (!matches) {\n            throw getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n        }\n        let match = routeId ? matches.find((m)=>m.route.id === routeId) : getTargetMatch(matches, location);\n        if (routeId && !match) {\n            throw getInternalRouterError(403, {\n                pathname: location.pathname,\n                routeId\n            });\n        } else if (!match) {\n            // This should never hit I don't think?\n            throw getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n        }\n        let result = await queryImpl(request, location, matches, requestContext, match);\n        if (isResponse(result)) {\n            return result;\n        }\n        let error = result.errors ? Object.values(result.errors)[0] : undefined;\n        if (error !== undefined) {\n            // If we got back result.errors, that means the loader/action threw\n            // _something_ that wasn't a Response, but it's not guaranteed/required\n            // to be an `instanceof Error` either, so we have to use throw here to\n            // preserve the \"error\" state outside of queryImpl.\n            throw error;\n        }\n        // Pick off the right state value to return\n        if (result.actionData) {\n            return Object.values(result.actionData)[0];\n        }\n        if (result.loaderData) {\n            var _result$activeDeferre;\n            let data = Object.values(result.loaderData)[0];\n            if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {\n                data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\n            }\n            return data;\n        }\n        return undefined;\n    }\n    async function queryImpl(request, location, matches, requestContext, routeMatch) {\n        invariant(request.signal, \"query()/queryRoute() requests must contain an AbortController signal\");\n        try {\n            if (isMutationMethod(request.method.toLowerCase())) {\n                let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);\n                return result;\n            }\n            let result = await loadRouteData(request, matches, requestContext, routeMatch);\n            return isResponse(result) ? result : _extends({}, result, {\n                actionData: null,\n                actionHeaders: {}\n            });\n        } catch (e) {\n            // If the user threw/returned a Response in callLoaderOrAction, we throw\n            // it to bail out and then return or throw here based on whether the user\n            // returned or threw\n            if (isQueryRouteResponse(e)) {\n                if (e.type === ResultType.error) {\n                    throw e.response;\n                }\n                return e.response;\n            }\n            // Redirects are always returned since they don't propagate to catch\n            // boundaries\n            if (isRedirectResponse(e)) {\n                return e;\n            }\n            throw e;\n        }\n    }\n    async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {\n        let result;\n        if (!actionMatch.route.action && !actionMatch.route.lazy) {\n            let error = getInternalRouterError(405, {\n                method: request.method,\n                pathname: new URL(request.url).pathname,\n                routeId: actionMatch.route.id\n            });\n            if (isRouteRequest) {\n                throw error;\n            }\n            result = {\n                type: ResultType.error,\n                error\n            };\n        } else {\n            result = await callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath, {\n                isStaticRequest: true,\n                isRouteRequest,\n                requestContext\n            });\n            if (request.signal.aborted) {\n                throwStaticHandlerAbortedError(request, isRouteRequest, future);\n            }\n        }\n        if (isRedirectResult(result)) {\n            // Uhhhh - this should never happen, we should always throw these from\n            // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n            // can get back on the \"throw all redirect responses\" train here should\n            // this ever happen :/\n            throw new Response(null, {\n                status: result.status,\n                headers: {\n                    Location: result.location\n                }\n            });\n        }\n        if (isDeferredResult(result)) {\n            let error = getInternalRouterError(400, {\n                type: \"defer-action\"\n            });\n            if (isRouteRequest) {\n                throw error;\n            }\n            result = {\n                type: ResultType.error,\n                error\n            };\n        }\n        if (isRouteRequest) {\n            // Note: This should only be non-Response values if we get here, since\n            // isRouteRequest should throw any Response received in callLoaderOrAction\n            if (isErrorResult(result)) {\n                throw result.error;\n            }\n            return {\n                matches: [\n                    actionMatch\n                ],\n                loaderData: {},\n                actionData: {\n                    [actionMatch.route.id]: result.data\n                },\n                errors: null,\n                // Note: statusCode + headers are unused here since queryRoute will\n                // return the raw Response or value\n                statusCode: 200,\n                loaderHeaders: {},\n                actionHeaders: {},\n                activeDeferreds: null\n            };\n        }\n        if (isErrorResult(result)) {\n            // Store off the pending error - we use it to determine which loaders\n            // to call and will commit it when we complete the navigation\n            let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n            let context = await loadRouteData(request, matches, requestContext, undefined, {\n                [boundaryMatch.route.id]: result.error\n            });\n            // action status codes take precedence over loader status codes\n            return _extends({}, context, {\n                statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,\n                actionData: null,\n                actionHeaders: _extends({}, result.headers ? {\n                    [actionMatch.route.id]: result.headers\n                } : {})\n            });\n        }\n        // Create a GET request for the loaders\n        let loaderRequest = new Request(request.url, {\n            headers: request.headers,\n            redirect: request.redirect,\n            signal: request.signal\n        });\n        let context = await loadRouteData(loaderRequest, matches, requestContext);\n        return _extends({}, context, result.statusCode ? {\n            statusCode: result.statusCode\n        } : {}, {\n            actionData: {\n                [actionMatch.route.id]: result.data\n            },\n            actionHeaders: _extends({}, result.headers ? {\n                [actionMatch.route.id]: result.headers\n            } : {})\n        });\n    }\n    async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {\n        let isRouteRequest = routeMatch != null;\n        // Short circuit if we have no loaders to run (queryRoute())\n        if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) {\n            throw getInternalRouterError(400, {\n                method: request.method,\n                pathname: new URL(request.url).pathname,\n                routeId: routeMatch == null ? void 0 : routeMatch.route.id\n            });\n        }\n        let requestMatches = routeMatch ? [\n            routeMatch\n        ] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);\n        let matchesToLoad = requestMatches.filter((m)=>m.route.loader || m.route.lazy);\n        // Short circuit if we have no loaders to run (query())\n        if (matchesToLoad.length === 0) {\n            return {\n                matches,\n                // Add a null for all matched routes for proper revalidation on the client\n                loaderData: matches.reduce((acc, m)=>Object.assign(acc, {\n                        [m.route.id]: null\n                    }), {}),\n                errors: pendingActionError || null,\n                statusCode: 200,\n                loaderHeaders: {},\n                activeDeferreds: null\n            };\n        }\n        let results = await Promise.all([\n            ...matchesToLoad.map((match)=>callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath, {\n                    isStaticRequest: true,\n                    isRouteRequest,\n                    requestContext\n                }))\n        ]);\n        if (request.signal.aborted) {\n            throwStaticHandlerAbortedError(request, isRouteRequest, future);\n        }\n        // Process and commit output from loaders\n        let activeDeferreds = new Map();\n        let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds);\n        // Add a null for any non-loader matches for proper revalidation on the client\n        let executedLoaders = new Set(matchesToLoad.map((match)=>match.route.id));\n        matches.forEach((match)=>{\n            if (!executedLoaders.has(match.route.id)) {\n                context.loaderData[match.route.id] = null;\n            }\n        });\n        return _extends({}, context, {\n            matches,\n            activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null\n        });\n    }\n    return {\n        dataRoutes,\n        query,\n        queryRoute\n    };\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */ function getStaticContextFromError(routes, context, error) {\n    let newContext = _extends({}, context, {\n        statusCode: isRouteErrorResponse(error) ? error.status : 500,\n        errors: {\n            [context._deepestRenderedBoundaryId || routes[0].id]: error\n        }\n    });\n    return newContext;\n}\nfunction throwStaticHandlerAbortedError(request, isRouteRequest, future) {\n    if (future.v7_throwAbortReason && request.signal.reason !== undefined) {\n        throw request.signal.reason;\n    }\n    let method = isRouteRequest ? \"queryRoute\" : \"query\";\n    throw new Error(method + \"() call aborted: \" + request.method + \" \" + request.url);\n}\nfunction isSubmissionNavigation(opts) {\n    return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== undefined);\n}\nfunction normalizeTo(location, matches, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {\n    let contextualMatches;\n    let activeRouteMatch;\n    if (fromRouteId) {\n        // Grab matches up to the calling route so our route-relative logic is\n        // relative to the correct source route\n        contextualMatches = [];\n        for (let match of matches){\n            contextualMatches.push(match);\n            if (match.route.id === fromRouteId) {\n                activeRouteMatch = match;\n                break;\n            }\n        }\n    } else {\n        contextualMatches = matches;\n        activeRouteMatch = matches[matches.length - 1];\n    }\n    // Resolve the relative path\n    let path = resolveTo(to ? to : \".\", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location.pathname, basename) || location.pathname, relative === \"path\");\n    // When `to` is not specified we inherit search/hash from the current\n    // location, unlike when to=\".\" and we just inherit the path.\n    // See https://github.com/remix-run/remix/issues/927\n    if (to == null) {\n        path.search = location.search;\n        path.hash = location.hash;\n    }\n    // Add an ?index param for matched index routes if we don't already have one\n    if ((to == null || to === \"\" || to === \".\") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {\n        path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    }\n    // If we're operating within a basename, prepend it to the pathname.  If\n    // this is a root navigation, then just use the raw basename which allows\n    // the basename to have full control over the presence of a trailing slash\n    // on root actions\n    if (prependBasename && basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : joinPaths([\n            basename,\n            path.pathname\n        ]);\n    }\n    return createPath(path);\n}\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {\n    // Return location verbatim on non-submission navigations\n    if (!opts || !isSubmissionNavigation(opts)) {\n        return {\n            path\n        };\n    }\n    if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n        return {\n            path,\n            error: getInternalRouterError(405, {\n                method: opts.formMethod\n            })\n        };\n    }\n    let getInvalidBodyError = ()=>({\n            path,\n            error: getInternalRouterError(400, {\n                type: \"invalid-body\"\n            })\n        });\n    // Create a Submission on non-GET navigations\n    let rawFormMethod = opts.formMethod || \"get\";\n    let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();\n    let formAction = stripHashFromPath(path);\n    if (opts.body !== undefined) {\n        if (opts.formEncType === \"text/plain\") {\n            // text only support POST/PUT/PATCH/DELETE submissions\n            if (!isMutationMethod(formMethod)) {\n                return getInvalidBodyError();\n            }\n            let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n            Array.from(opts.body.entries()).reduce((acc, _ref5)=>{\n                let [name, value] = _ref5;\n                return \"\" + acc + name + \"=\" + value + \"\\n\";\n            }, \"\") : String(opts.body);\n            return {\n                path,\n                submission: {\n                    formMethod,\n                    formAction,\n                    formEncType: opts.formEncType,\n                    formData: undefined,\n                    json: undefined,\n                    text\n                }\n            };\n        } else if (opts.formEncType === \"application/json\") {\n            // json only supports POST/PUT/PATCH/DELETE submissions\n            if (!isMutationMethod(formMethod)) {\n                return getInvalidBodyError();\n            }\n            try {\n                let json = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n                return {\n                    path,\n                    submission: {\n                        formMethod,\n                        formAction,\n                        formEncType: opts.formEncType,\n                        formData: undefined,\n                        json,\n                        text: undefined\n                    }\n                };\n            } catch (e) {\n                return getInvalidBodyError();\n            }\n        }\n    }\n    invariant(typeof FormData === \"function\", \"FormData is not available in this environment\");\n    let searchParams;\n    let formData;\n    if (opts.formData) {\n        searchParams = convertFormDataToSearchParams(opts.formData);\n        formData = opts.formData;\n    } else if (opts.body instanceof FormData) {\n        searchParams = convertFormDataToSearchParams(opts.body);\n        formData = opts.body;\n    } else if (opts.body instanceof URLSearchParams) {\n        searchParams = opts.body;\n        formData = convertSearchParamsToFormData(searchParams);\n    } else if (opts.body == null) {\n        searchParams = new URLSearchParams();\n        formData = new FormData();\n    } else {\n        try {\n            searchParams = new URLSearchParams(opts.body);\n            formData = convertSearchParamsToFormData(searchParams);\n        } catch (e) {\n            return getInvalidBodyError();\n        }\n    }\n    let submission = {\n        formMethod,\n        formAction,\n        formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n        formData,\n        json: undefined,\n        text: undefined\n    };\n    if (isMutationMethod(submission.formMethod)) {\n        return {\n            path,\n            submission\n        };\n    }\n    // Flatten submission onto URLSearchParams for GET submissions\n    let parsedPath = parsePath(path);\n    // On GET navigation submissions we can drop the ?index param from the\n    // resulting location since all loaders will run.  But fetcher GET submissions\n    // only run a single loader so we need to preserve any incoming ?index params\n    if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n        searchParams.append(\"index\", \"\");\n    }\n    parsedPath.search = \"?\" + searchParams;\n    return {\n        path: createPath(parsedPath),\n        submission\n    };\n}\n// Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId) {\n    let boundaryMatches = matches;\n    if (boundaryId) {\n        let index = matches.findIndex((m)=>m.route.id === boundaryId);\n        if (index >= 0) {\n            boundaryMatches = matches.slice(0, index);\n        }\n    }\n    return boundaryMatches;\n}\nfunction getMatchesToLoad(history, state, matches, submission, location, isInitialLoad, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {\n    let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined;\n    let currentUrl = history.createURL(state.location);\n    let nextUrl = history.createURL(location);\n    // Pick navigation matches that are net-new or qualify for revalidation\n    let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;\n    let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n    let navigationMatches = boundaryMatches.filter((match, index)=>{\n        let { route } = match;\n        if (route.lazy) {\n            // We haven't loaded this route yet so we don't know if it's got a loader!\n            return true;\n        }\n        if (route.loader == null) {\n            return false;\n        }\n        if (isInitialLoad) {\n            if (route.loader.hydrate) {\n                return true;\n            }\n            return state.loaderData[route.id] === undefined && // Don't re-run if the loader ran and threw an error\n            (!state.errors || state.errors[route.id] === undefined);\n        }\n        // Always call the loader on new route instances and pending defer cancellations\n        if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some((id)=>id === match.route.id)) {\n            return true;\n        }\n        // This is the default implementation for when we revalidate.  If the route\n        // provides it's own implementation, then we give them full control but\n        // provide this value so they can leverage it if needed after they check\n        // their own specific use cases\n        let currentRouteMatch = state.matches[index];\n        let nextRouteMatch = match;\n        return shouldRevalidateLoader(match, _extends({\n            currentUrl,\n            currentParams: currentRouteMatch.params,\n            nextUrl,\n            nextParams: nextRouteMatch.params\n        }, submission, {\n            actionResult,\n            defaultShouldRevalidate: // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n            isRevalidationRequired || // Clicked the same link, resubmitted a GET form\n            currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders\n            currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\n        }));\n    });\n    // Pick fetcher.loads that need to be revalidated\n    let revalidatingFetchers = [];\n    fetchLoadMatches.forEach((f, key)=>{\n        // Don't revalidate:\n        //  - on initial load (shouldn't be any fetchers then anyway)\n        //  - if fetcher won't be present in the subsequent render\n        //    - no longer matches the URL (v7_fetcherPersist=false)\n        //    - was unmounted but persisted due to v7_fetcherPersist=true\n        if (isInitialLoad || !matches.some((m)=>m.route.id === f.routeId) || deletedFetchers.has(key)) {\n            return;\n        }\n        let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n        // If the fetcher path no longer matches, push it in with null matches so\n        // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n        // currently only a use-case for Remix HMR where the route tree can change\n        // at runtime and remove a route previously loaded via a fetcher\n        if (!fetcherMatches) {\n            revalidatingFetchers.push({\n                key,\n                routeId: f.routeId,\n                path: f.path,\n                matches: null,\n                match: null,\n                controller: null\n            });\n            return;\n        }\n        // Revalidating fetchers are decoupled from the route matches since they\n        // load from a static href.  They revalidate based on explicit revalidation\n        // (submission, useRevalidator, or X-Remix-Revalidate)\n        let fetcher = state.fetchers.get(key);\n        let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n        let shouldRevalidate = false;\n        if (fetchRedirectIds.has(key)) {\n            // Never trigger a revalidation of an actively redirecting fetcher\n            shouldRevalidate = false;\n        } else if (cancelledFetcherLoads.includes(key)) {\n            // Always revalidate if the fetcher was cancelled\n            shouldRevalidate = true;\n        } else if (fetcher && fetcher.state !== \"idle\" && fetcher.data === undefined) {\n            // If the fetcher hasn't ever completed loading yet, then this isn't a\n            // revalidation, it would just be a brand new load if an explicit\n            // revalidation is required\n            shouldRevalidate = isRevalidationRequired;\n        } else {\n            // Otherwise fall back on any user-defined shouldRevalidate, defaulting\n            // to explicit revalidations only\n            shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({\n                currentUrl,\n                currentParams: state.matches[state.matches.length - 1].params,\n                nextUrl,\n                nextParams: matches[matches.length - 1].params\n            }, submission, {\n                actionResult,\n                defaultShouldRevalidate: isRevalidationRequired\n            }));\n        }\n        if (shouldRevalidate) {\n            revalidatingFetchers.push({\n                key,\n                routeId: f.routeId,\n                path: f.path,\n                matches: fetcherMatches,\n                match: fetcherMatch,\n                controller: new AbortController()\n            });\n        }\n    });\n    return [\n        navigationMatches,\n        revalidatingFetchers\n    ];\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n    let isNew = // [a] -> [a, b]\n    !currentMatch || // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id;\n    // Handle the case that we don't have data for a re-used route, potentially\n    // from a prior error or from a cancelled pending deferred\n    let isMissingData = currentLoaderData[match.route.id] === undefined;\n    // Always load if this is a net-new route or we don't yet have data\n    return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n    let currentPath = currentMatch.route.path;\n    return(// param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]);\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n    if (loaderMatch.route.shouldRevalidate) {\n        let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n        if (typeof routeChoice === \"boolean\") {\n            return routeChoice;\n        }\n    }\n    return arg.defaultShouldRevalidate;\n}\n/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */ async function loadLazyRouteModule(route, mapRouteProperties, manifest) {\n    if (!route.lazy) {\n        return;\n    }\n    let lazyRoute = await route.lazy();\n    // If the lazy route function was executed and removed by another parallel\n    // call then we can return - first lazy() to finish wins because the return\n    // value of lazy is expected to be static\n    if (!route.lazy) {\n        return;\n    }\n    let routeToUpdate = manifest[route.id];\n    invariant(routeToUpdate, \"No route found in manifest\");\n    // Update the route in place.  This should be safe because there's no way\n    // we could yet be sitting on this route as we can't get there without\n    // resolving lazy() first.\n    //\n    // This is different than the HMR \"update\" use-case where we may actively be\n    // on the route being updated.  The main concern boils down to \"does this\n    // mutation affect any ongoing navigations or any current state.matches\n    // values?\".  If not, it should be safe to update in place.\n    let routeUpdates = {};\n    for(let lazyRouteProperty in lazyRoute){\n        let staticRouteValue = routeToUpdate[lazyRouteProperty];\n        let isPropertyStaticallyDefined = staticRouteValue !== undefined && // This property isn't static since it should always be updated based\n        // on the route updates\n        lazyRouteProperty !== \"hasErrorBoundary\";\n        warning(!isPropertyStaticallyDefined, 'Route \"' + routeToUpdate.id + '\" has a static property \"' + lazyRouteProperty + '\" ' + \"defined but its lazy function is also returning a value for this property. \" + ('The lazy route property \"' + lazyRouteProperty + '\" will be ignored.'));\n        if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {\n            routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\n        }\n    }\n    // Mutate the route with the provided updates.  Do this first so we pass\n    // the updated version to mapRouteProperties\n    Object.assign(routeToUpdate, routeUpdates);\n    // Mutate the `hasErrorBoundary` property on the route based on the route\n    // updates and remove the `lazy` function so we don't resolve the lazy\n    // route again.\n    Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {\n        lazy: undefined\n    }));\n}\nasync function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties, basename, v7_relativeSplatPath, opts) {\n    if (opts === void 0) {\n        opts = {};\n    }\n    let resultType;\n    let result;\n    let onReject;\n    let runHandler = (handler)=>{\n        // Setup a promise we can race against so that abort signals short circuit\n        let reject;\n        let abortPromise = new Promise((_, r)=>reject = r);\n        onReject = ()=>reject();\n        request.signal.addEventListener(\"abort\", onReject);\n        return Promise.race([\n            handler({\n                request,\n                params: match.params,\n                context: opts.requestContext\n            }),\n            abortPromise\n        ]);\n    };\n    try {\n        let handler = match.route[type];\n        if (match.route.lazy) {\n            if (handler) {\n                // Run statically defined handler in parallel with lazy()\n                let handlerError;\n                let values = await Promise.all([\n                    // If the handler throws, don't let it immediately bubble out,\n                    // since we need to let the lazy() execution finish so we know if this\n                    // route has a boundary that can handle the error\n                    runHandler(handler).catch((e)=>{\n                        handlerError = e;\n                    }),\n                    loadLazyRouteModule(match.route, mapRouteProperties, manifest)\n                ]);\n                if (handlerError) {\n                    throw handlerError;\n                }\n                result = values[0];\n            } else {\n                // Load lazy route module, then run any returned handler\n                await loadLazyRouteModule(match.route, mapRouteProperties, manifest);\n                handler = match.route[type];\n                if (handler) {\n                    // Handler still run even if we got interrupted to maintain consistency\n                    // with un-abortable behavior of handler execution on non-lazy or\n                    // previously-lazy-loaded routes\n                    result = await runHandler(handler);\n                } else if (type === \"action\") {\n                    let url = new URL(request.url);\n                    let pathname = url.pathname + url.search;\n                    throw getInternalRouterError(405, {\n                        method: request.method,\n                        pathname,\n                        routeId: match.route.id\n                    });\n                } else {\n                    // lazy() route has no loader to run.  Short circuit here so we don't\n                    // hit the invariant below that errors on returning undefined.\n                    return {\n                        type: ResultType.data,\n                        data: undefined\n                    };\n                }\n            }\n        } else if (!handler) {\n            let url = new URL(request.url);\n            let pathname = url.pathname + url.search;\n            throw getInternalRouterError(404, {\n                pathname\n            });\n        } else {\n            result = await runHandler(handler);\n        }\n        invariant(result !== undefined, \"You defined \" + (type === \"action\" ? \"an action\" : \"a loader\") + \" for route \" + ('\"' + match.route.id + \"\\\" but didn't return anything from your `\" + type + \"` \") + \"function. Please return a value or `null`.\");\n    } catch (e) {\n        resultType = ResultType.error;\n        result = e;\n    } finally{\n        if (onReject) {\n            request.signal.removeEventListener(\"abort\", onReject);\n        }\n    }\n    if (isResponse(result)) {\n        let status = result.status;\n        // Process redirects\n        if (redirectStatusCodes.has(status)) {\n            let location = result.headers.get(\"Location\");\n            invariant(location, \"Redirects returned/thrown from loaders/actions must have a Location header\");\n            // Support relative routing in internal redirects\n            if (!ABSOLUTE_URL_REGEX.test(location)) {\n                location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, true, location, v7_relativeSplatPath);\n            } else if (!opts.isStaticRequest) {\n                // Strip off the protocol+origin for same-origin + same-basename absolute\n                // redirects. If this is a static request, we can let it go back to the\n                // browser as-is\n                let currentUrl = new URL(request.url);\n                let url = location.startsWith(\"//\") ? new URL(currentUrl.protocol + location) : new URL(location);\n                let isSameBasename = stripBasename(url.pathname, basename) != null;\n                if (url.origin === currentUrl.origin && isSameBasename) {\n                    location = url.pathname + url.search + url.hash;\n                }\n            }\n            // Don't process redirects in the router during static requests requests.\n            // Instead, throw the Response and let the server handle it with an HTTP\n            // redirect.  We also update the Location header in place in this flow so\n            // basename and relative routing is taken into account\n            if (opts.isStaticRequest) {\n                result.headers.set(\"Location\", location);\n                throw result;\n            }\n            return {\n                type: ResultType.redirect,\n                status,\n                location,\n                revalidate: result.headers.get(\"X-Remix-Revalidate\") !== null,\n                reloadDocument: result.headers.get(\"X-Remix-Reload-Document\") !== null\n            };\n        }\n        // For SSR single-route requests, we want to hand Responses back directly\n        // without unwrapping.  We do this with the QueryRouteResponse wrapper\n        // interface so we can know whether it was returned or thrown\n        if (opts.isRouteRequest) {\n            let queryRouteResponse = {\n                type: resultType === ResultType.error ? ResultType.error : ResultType.data,\n                response: result\n            };\n            throw queryRouteResponse;\n        }\n        let data;\n        try {\n            let contentType = result.headers.get(\"Content-Type\");\n            // Check between word boundaries instead of startsWith() due to the last\n            // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n            if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n                if (result.body == null) {\n                    data = null;\n                } else {\n                    data = await result.json();\n                }\n            } else {\n                data = await result.text();\n            }\n        } catch (e) {\n            return {\n                type: ResultType.error,\n                error: e\n            };\n        }\n        if (resultType === ResultType.error) {\n            return {\n                type: resultType,\n                error: new ErrorResponseImpl(status, result.statusText, data),\n                headers: result.headers\n            };\n        }\n        return {\n            type: ResultType.data,\n            data,\n            statusCode: result.status,\n            headers: result.headers\n        };\n    }\n    if (resultType === ResultType.error) {\n        return {\n            type: resultType,\n            error: result\n        };\n    }\n    if (isDeferredData(result)) {\n        var _result$init, _result$init2;\n        return {\n            type: ResultType.deferred,\n            deferredData: result,\n            statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,\n            headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)\n        };\n    }\n    return {\n        type: ResultType.data,\n        data: result\n    };\n}\n// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(history, location, signal, submission) {\n    let url = history.createURL(stripHashFromPath(location)).toString();\n    let init = {\n        signal\n    };\n    if (submission && isMutationMethod(submission.formMethod)) {\n        let { formMethod, formEncType } = submission;\n        // Didn't think we needed this but it turns out unlike other methods, patch\n        // won't be properly normalized to uppercase and results in a 405 error.\n        // See: https://fetch.spec.whatwg.org/#concept-method\n        init.method = formMethod.toUpperCase();\n        if (formEncType === \"application/json\") {\n            init.headers = new Headers({\n                \"Content-Type\": formEncType\n            });\n            init.body = JSON.stringify(submission.json);\n        } else if (formEncType === \"text/plain\") {\n            // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n            init.body = submission.text;\n        } else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\n            // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n            init.body = convertFormDataToSearchParams(submission.formData);\n        } else {\n            // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n            init.body = submission.formData;\n        }\n    }\n    return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n    let searchParams = new URLSearchParams();\n    for (let [key, value] of formData.entries()){\n        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n        searchParams.append(key, typeof value === \"string\" ? value : value.name);\n    }\n    return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n    let formData = new FormData();\n    for (let [key, value] of searchParams.entries()){\n        formData.append(key, value);\n    }\n    return formData;\n}\nfunction processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {\n    // Fill in loaderData/errors from our loaders\n    let loaderData = {};\n    let errors = null;\n    let statusCode;\n    let foundError = false;\n    let loaderHeaders = {};\n    // Process loader results into state.loaderData/state.errors\n    results.forEach((result, index)=>{\n        let id = matchesToLoad[index].route.id;\n        invariant(!isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\n        if (isErrorResult(result)) {\n            // Look upwards from the matched route for the closest ancestor\n            // error boundary, defaulting to the root match\n            let boundaryMatch = findNearestBoundary(matches, id);\n            let error = result.error;\n            // If we have a pending action error, we report it at the highest-route\n            // that throws a loader error, and then clear it out to indicate that\n            // it was consumed\n            if (pendingError) {\n                error = Object.values(pendingError)[0];\n                pendingError = undefined;\n            }\n            errors = errors || {};\n            // Prefer higher error values if lower errors bubble to the same boundary\n            if (errors[boundaryMatch.route.id] == null) {\n                errors[boundaryMatch.route.id] = error;\n            }\n            // Clear our any prior loaderData for the throwing route\n            loaderData[id] = undefined;\n            // Once we find our first (highest) error, we set the status code and\n            // prevent deeper status codes from overriding\n            if (!foundError) {\n                foundError = true;\n                statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n            }\n            if (result.headers) {\n                loaderHeaders[id] = result.headers;\n            }\n        } else {\n            if (isDeferredResult(result)) {\n                activeDeferreds.set(id, result.deferredData);\n                loaderData[id] = result.deferredData.data;\n            } else {\n                loaderData[id] = result.data;\n            }\n            // Error status codes always override success status codes, but if all\n            // loaders are successful we take the deepest status code.\n            if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\n                statusCode = result.statusCode;\n            }\n            if (result.headers) {\n                loaderHeaders[id] = result.headers;\n            }\n        }\n    });\n    // If we didn't consume the pending action error (i.e., all loaders\n    // resolved), then consume it here.  Also clear out any loaderData for the\n    // throwing route\n    if (pendingError) {\n        errors = pendingError;\n        loaderData[Object.keys(pendingError)[0]] = undefined;\n    }\n    return {\n        loaderData,\n        errors,\n        statusCode: statusCode || 200,\n        loaderHeaders\n    };\n}\nfunction processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {\n    let { loaderData, errors } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);\n    // Process results from our revalidating fetchers\n    for(let index = 0; index < revalidatingFetchers.length; index++){\n        let { key, match, controller } = revalidatingFetchers[index];\n        invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, \"Did not find corresponding fetcher result\");\n        let result = fetcherResults[index];\n        // Process fetcher non-redirect errors\n        if (controller && controller.signal.aborted) {\n            continue;\n        } else if (isErrorResult(result)) {\n            let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);\n            if (!(errors && errors[boundaryMatch.route.id])) {\n                errors = _extends({}, errors, {\n                    [boundaryMatch.route.id]: result.error\n                });\n            }\n            state.fetchers.delete(key);\n        } else if (isRedirectResult(result)) {\n            // Should never get here, redirects should get processed above, but we\n            // keep this to type narrow to a success result in the else\n            invariant(false, \"Unhandled fetcher revalidation redirect\");\n        } else if (isDeferredResult(result)) {\n            // Should never get here, deferred data should be awaited for fetchers\n            // in resolveDeferredResults\n            invariant(false, \"Unhandled fetcher deferred data\");\n        } else {\n            let doneFetcher = getDoneFetcher(result.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n    }\n    return {\n        loaderData,\n        errors\n    };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n    let mergedLoaderData = _extends({}, newLoaderData);\n    for (let match of matches){\n        let id = match.route.id;\n        if (newLoaderData.hasOwnProperty(id)) {\n            if (newLoaderData[id] !== undefined) {\n                mergedLoaderData[id] = newLoaderData[id];\n            }\n        } else if (loaderData[id] !== undefined && match.route.loader) {\n            // Preserve existing keys not included in newLoaderData and where a loader\n            // wasn't removed by HMR\n            mergedLoaderData[id] = loaderData[id];\n        }\n        if (errors && errors.hasOwnProperty(id)) {\n            break;\n        }\n    }\n    return mergedLoaderData;\n}\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(matches, routeId) {\n    let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m)=>m.route.id === routeId) + 1) : [\n        ...matches\n    ];\n    return eligibleMatches.reverse().find((m)=>m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n    // Prefer a root layout route if present, otherwise shim in a route object\n    let route = routes.length === 1 ? routes[0] : routes.find((r)=>r.index || !r.path || r.path === \"/\") || {\n        id: \"__shim-error-route__\"\n    };\n    return {\n        matches: [\n            {\n                params: {},\n                pathname: \"\",\n                pathnameBase: \"\",\n                route\n            }\n        ],\n        route\n    };\n}\nfunction getInternalRouterError(status, _temp5) {\n    let { pathname, routeId, method, type } = _temp5 === void 0 ? {} : _temp5;\n    let statusText = \"Unknown Server Error\";\n    let errorMessage = \"Unknown @remix-run/router error\";\n    if (status === 400) {\n        statusText = \"Bad Request\";\n        if (method && pathname && routeId) {\n            errorMessage = \"You made a \" + method + ' request to \"' + pathname + '\" but ' + ('did not provide a `loader` for route \"' + routeId + '\", ') + \"so there is no way to handle the request.\";\n        } else if (type === \"defer-action\") {\n            errorMessage = \"defer() is not supported in actions\";\n        } else if (type === \"invalid-body\") {\n            errorMessage = \"Unable to encode submission body\";\n        }\n    } else if (status === 403) {\n        statusText = \"Forbidden\";\n        errorMessage = 'Route \"' + routeId + '\" does not match URL \"' + pathname + '\"';\n    } else if (status === 404) {\n        statusText = \"Not Found\";\n        errorMessage = 'No route matches URL \"' + pathname + '\"';\n    } else if (status === 405) {\n        statusText = \"Method Not Allowed\";\n        if (method && pathname && routeId) {\n            errorMessage = \"You made a \" + method.toUpperCase() + ' request to \"' + pathname + '\" but ' + ('did not provide an `action` for route \"' + routeId + '\", ') + \"so there is no way to handle the request.\";\n        } else if (method) {\n            errorMessage = 'Invalid request method \"' + method.toUpperCase() + '\"';\n        }\n    }\n    return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\n}\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(results) {\n    for(let i = results.length - 1; i >= 0; i--){\n        let result = results[i];\n        if (isRedirectResult(result)) {\n            return {\n                result,\n                idx: i\n            };\n        }\n    }\n}\nfunction stripHashFromPath(path) {\n    let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n    return createPath(_extends({}, parsedPath, {\n        hash: \"\"\n    }));\n}\nfunction isHashChangeOnly(a, b) {\n    if (a.pathname !== b.pathname || a.search !== b.search) {\n        return false;\n    }\n    if (a.hash === \"\") {\n        // /page -> /page#hash\n        return b.hash !== \"\";\n    } else if (a.hash === b.hash) {\n        // /page#hash -> /page#hash\n        return true;\n    } else if (b.hash !== \"\") {\n        // /page#hash -> /page#other\n        return true;\n    }\n    // If the hash is removed the browser will re-perform a request to the server\n    // /page#hash -> /page\n    return false;\n}\nfunction isDeferredResult(result) {\n    return result.type === ResultType.deferred;\n}\nfunction isErrorResult(result) {\n    return result.type === ResultType.error;\n}\nfunction isRedirectResult(result) {\n    return (result && result.type) === ResultType.redirect;\n}\nfunction isDeferredData(value) {\n    let deferred = value;\n    return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nfunction isResponse(value) {\n    return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isRedirectResponse(result) {\n    if (!isResponse(result)) {\n        return false;\n    }\n    let status = result.status;\n    let location = result.headers.get(\"Location\");\n    return status >= 300 && status <= 399 && location != null;\n}\nfunction isQueryRouteResponse(obj) {\n    return obj && isResponse(obj.response) && (obj.type === ResultType.data || obj.type === ResultType.error);\n}\nfunction isValidMethod(method) {\n    return validRequestMethods.has(method.toLowerCase());\n}\nfunction isMutationMethod(method) {\n    return validMutationMethods.has(method.toLowerCase());\n}\nasync function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {\n    for(let index = 0; index < results.length; index++){\n        let result = results[index];\n        let match = matchesToLoad[index];\n        // If we don't have a match, then we can have a deferred result to do\n        // anything with.  This is for revalidating fetchers where the route was\n        // removed during HMR\n        if (!match) {\n            continue;\n        }\n        let currentMatch = currentMatches.find((m)=>m.route.id === match.route.id);\n        let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n        if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n            // Note: we do not have to touch activeDeferreds here since we race them\n            // against the signal in resolveDeferredData and they'll get aborted\n            // there if needed\n            let signal = signals[index];\n            invariant(signal, \"Expected an AbortSignal for revalidating fetcher deferred result\");\n            await resolveDeferredData(result, signal, isFetcher).then((result)=>{\n                if (result) {\n                    results[index] = result || results[index];\n                }\n            });\n        }\n    }\n}\nasync function resolveDeferredData(result, signal, unwrap) {\n    if (unwrap === void 0) {\n        unwrap = false;\n    }\n    let aborted = await result.deferredData.resolveData(signal);\n    if (aborted) {\n        return;\n    }\n    if (unwrap) {\n        try {\n            return {\n                type: ResultType.data,\n                data: result.deferredData.unwrappedData\n            };\n        } catch (e) {\n            // Handle any TrackedPromise._error values encountered while unwrapping\n            return {\n                type: ResultType.error,\n                error: e\n            };\n        }\n    }\n    return {\n        type: ResultType.data,\n        data: result.deferredData.data\n    };\n}\nfunction hasNakedIndexQuery(search) {\n    return new URLSearchParams(search).getAll(\"index\").some((v)=>v === \"\");\n}\nfunction getTargetMatch(matches, location) {\n    let search = typeof location === \"string\" ? parsePath(location).search : location.search;\n    if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\n        // Return the leaf index route when index is present\n        return matches[matches.length - 1];\n    }\n    // Otherwise grab the deepest \"path contributing\" match (ignoring index and\n    // pathless layout routes)\n    let pathMatches = getPathContributingMatches(matches);\n    return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n    let { formMethod, formAction, formEncType, text, formData, json } = navigation;\n    if (!formMethod || !formAction || !formEncType) {\n        return;\n    }\n    if (text != null) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData: undefined,\n            json: undefined,\n            text\n        };\n    } else if (formData != null) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData,\n            json: undefined,\n            text: undefined\n        };\n    } else if (json !== undefined) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData: undefined,\n            json,\n            text: undefined\n        };\n    }\n}\nfunction getLoadingNavigation(location, submission) {\n    if (submission) {\n        let navigation = {\n            state: \"loading\",\n            location,\n            formMethod: submission.formMethod,\n            formAction: submission.formAction,\n            formEncType: submission.formEncType,\n            formData: submission.formData,\n            json: submission.json,\n            text: submission.text\n        };\n        return navigation;\n    } else {\n        let navigation = {\n            state: \"loading\",\n            location,\n            formMethod: undefined,\n            formAction: undefined,\n            formEncType: undefined,\n            formData: undefined,\n            json: undefined,\n            text: undefined\n        };\n        return navigation;\n    }\n}\nfunction getSubmittingNavigation(location, submission) {\n    let navigation = {\n        state: \"submitting\",\n        location,\n        formMethod: submission.formMethod,\n        formAction: submission.formAction,\n        formEncType: submission.formEncType,\n        formData: submission.formData,\n        json: submission.json,\n        text: submission.text\n    };\n    return navigation;\n}\nfunction getLoadingFetcher(submission, data) {\n    if (submission) {\n        let fetcher = {\n            state: \"loading\",\n            formMethod: submission.formMethod,\n            formAction: submission.formAction,\n            formEncType: submission.formEncType,\n            formData: submission.formData,\n            json: submission.json,\n            text: submission.text,\n            data\n        };\n        return fetcher;\n    } else {\n        let fetcher = {\n            state: \"loading\",\n            formMethod: undefined,\n            formAction: undefined,\n            formEncType: undefined,\n            formData: undefined,\n            json: undefined,\n            text: undefined,\n            data\n        };\n        return fetcher;\n    }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n    let fetcher = {\n        state: \"submitting\",\n        formMethod: submission.formMethod,\n        formAction: submission.formAction,\n        formEncType: submission.formEncType,\n        formData: submission.formData,\n        json: submission.json,\n        text: submission.text,\n        data: existingFetcher ? existingFetcher.data : undefined\n    };\n    return fetcher;\n}\nfunction getDoneFetcher(data) {\n    let fetcher = {\n        state: \"idle\",\n        formMethod: undefined,\n        formAction: undefined,\n        formEncType: undefined,\n        formData: undefined,\n        json: undefined,\n        text: undefined,\n        data\n    };\n    return fetcher;\n}\nfunction restoreAppliedTransitions(_window, transitions) {\n    try {\n        let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);\n        if (sessionPositions) {\n            let json = JSON.parse(sessionPositions);\n            for (let [k, v] of Object.entries(json || {})){\n                if (v && Array.isArray(v)) {\n                    transitions.set(k, new Set(v || []));\n                }\n            }\n        }\n    } catch (e) {\n    // no-op, use default empty object\n    }\n}\nfunction persistAppliedTransitions(_window, transitions) {\n    if (transitions.size > 0) {\n        let json = {};\n        for (let [k, v] of transitions){\n            json[k] = [\n                ...v\n            ];\n        }\n        try {\n            _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));\n        } catch (error) {\n            warning(false, \"Failed to save applied view transitions in sessionStorage (\" + error + \").\");\n        }\n    }\n}\n//#endregion\n //# sourceMappingURL=router.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yb3V0ZXIvZGlzdC9yb3V0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU0E7SUFDUEEsV0FBV0MsT0FBT0MsTUFBTSxHQUFHRCxPQUFPQyxNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVQyxNQUFNO1FBQ2hFLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFDekMsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFO1lBQ3pCLElBQUssSUFBSUksT0FBT0QsT0FBUTtnQkFDdEIsSUFBSVAsT0FBT1MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osUUFBUUMsTUFBTTtvQkFDckRMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7Z0JBQzNCO1lBQ0Y7UUFDRjtRQUNBLE9BQU9MO0lBQ1Q7SUFDQSxPQUFPSixTQUFTYSxLQUFLLENBQUMsSUFBSSxFQUFFUDtBQUM5QjtBQUVBLGdGQUFnRjtBQUNoRiw2QkFBNkI7QUFDN0IsZ0ZBQWdGO0FBQ2hGOztDQUVDLEdBQ0QsSUFBSVE7QUFDSCxVQUFVQSxNQUFNO0lBQ2Y7Ozs7OztHQU1DLEdBQ0RBLE1BQU0sQ0FBQyxNQUFNLEdBQUc7SUFDaEI7Ozs7R0FJQyxHQUNEQSxNQUFNLENBQUMsT0FBTyxHQUFHO0lBQ2pCOzs7R0FHQyxHQUNEQSxNQUFNLENBQUMsVUFBVSxHQUFHO0FBQ3RCLEdBQUdBLFVBQVdBLENBQUFBLFNBQVMsQ0FBQztBQUN4QixNQUFNQyxvQkFBb0I7QUFDMUI7OztDQUdDLEdBQ0QsU0FBU0Msb0JBQW9CQyxPQUFPO0lBQ2xDLElBQUlBLFlBQVksS0FBSyxHQUFHO1FBQ3RCQSxVQUFVLENBQUM7SUFDYjtJQUNBLElBQUksRUFDRkMsaUJBQWlCO1FBQUM7S0FBSSxFQUN0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WUFBWW5hLEdBQUcsQ0FBQ3dDLEdBQUcsSUFBSTdMLElBQUkyRyxLQUFLLEVBQUU7Z0JBQ3BDO1lBQ0Y7UUFDRjtJQUNGLEVBQUUsT0FBT3JJLEdBQUc7SUFDVixrQ0FBa0M7SUFDcEM7QUFDRjtBQUNBLFNBQVN5VSwwQkFBMEJ3USxPQUFPLEVBQUVDLFdBQVc7SUFDckQsSUFBSUEsWUFBWXhYLElBQUksR0FBRyxHQUFHO1FBQ3hCLElBQUlsRCxPQUFPLENBQUM7UUFDWixLQUFLLElBQUksQ0FBQytDLEdBQUdsRixFQUFFLElBQUk2YyxZQUFhO1lBQzlCMWEsSUFBSSxDQUFDK0MsRUFBRSxHQUFHO21CQUFJbEY7YUFBRTtRQUNsQjtRQUNBLElBQUk7WUFDRjRjLFFBQVFHLGNBQWMsQ0FBQ0UsT0FBTyxDQUFDdlYseUJBQXlCblQsS0FBS0MsU0FBUyxDQUFDMk47UUFDekUsRUFBRSxPQUFPdEosT0FBTztZQUNkeEUsUUFBUSxPQUFPLGdFQUFnRXdFLFFBQVE7UUFDekY7SUFDRjtBQUNGO0FBQ0EsWUFBWTtBQUU4dkIsQ0FDMXdCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2dhbWVnbGFuY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yb3V0ZXIvZGlzdC9yb3V0ZXIuanM/NTAzOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEByZW1peC1ydW4vcm91dGVyIHYxLjE1LjNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gVHlwZXMgYW5kIENvbnN0YW50c1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogQWN0aW9ucyByZXByZXNlbnQgdGhlIHR5cGUgb2YgY2hhbmdlIHRvIGEgbG9jYXRpb24gdmFsdWUuXG4gKi9cbnZhciBBY3Rpb247XG4oZnVuY3Rpb24gKEFjdGlvbikge1xuICAvKipcbiAgICogQSBQT1AgaW5kaWNhdGVzIGEgY2hhbmdlIHRvIGFuIGFyYml0cmFyeSBpbmRleCBpbiB0aGUgaGlzdG9yeSBzdGFjaywgc3VjaFxuICAgKiBhcyBhIGJhY2sgb3IgZm9yd2FyZCBuYXZpZ2F0aW9uLiBJdCBkb2VzIG5vdCBkZXNjcmliZSB0aGUgZGlyZWN0aW9uIG9mIHRoZVxuICAgKiBuYXZpZ2F0aW9uLCBvbmx5IHRoYXQgdGhlIGN1cnJlbnQgaW5kZXggY2hhbmdlZC5cbiAgICpcbiAgICogTm90ZTogVGhpcyBpcyB0aGUgZGVmYXVsdCBhY3Rpb24gZm9yIG5ld2x5IGNyZWF0ZWQgaGlzdG9yeSBvYmplY3RzLlxuICAgKi9cbiAgQWN0aW9uW1wiUG9wXCJdID0gXCJQT1BcIjtcbiAgLyoqXG4gICAqIEEgUFVTSCBpbmRpY2F0ZXMgYSBuZXcgZW50cnkgYmVpbmcgYWRkZWQgdG8gdGhlIGhpc3Rvcnkgc3RhY2ssIHN1Y2ggYXMgd2hlblxuICAgKiBhIGxpbmsgaXMgY2xpY2tlZCBhbmQgYSBuZXcgcGFnZSBsb2Fkcy4gV2hlbiB0aGlzIGhhcHBlbnMsIGFsbCBzdWJzZXF1ZW50XG4gICAqIGVudHJpZXMgaW4gdGhlIHN0YWNrIGFyZSBsb3N0LlxuICAgKi9cbiAgQWN0aW9uW1wiUHVzaFwiXSA9IFwiUFVTSFwiO1xuICAvKipcbiAgICogQSBSRVBMQUNFIGluZGljYXRlcyB0aGUgZW50cnkgYXQgdGhlIGN1cnJlbnQgaW5kZXggaW4gdGhlIGhpc3Rvcnkgc3RhY2tcbiAgICogYmVpbmcgcmVwbGFjZWQgYnkgYSBuZXcgb25lLlxuICAgKi9cbiAgQWN0aW9uW1wiUmVwbGFjZVwiXSA9IFwiUkVQTEFDRVwiO1xufSkoQWN0aW9uIHx8IChBY3Rpb24gPSB7fSkpO1xuY29uc3QgUG9wU3RhdGVFdmVudFR5cGUgPSBcInBvcHN0YXRlXCI7XG4vKipcbiAqIE1lbW9yeSBoaXN0b3J5IHN0b3JlcyB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiBtZW1vcnkuIEl0IGlzIGRlc2lnbmVkIGZvciB1c2VcbiAqIGluIHN0YXRlZnVsIG5vbi1icm93c2VyIGVudmlyb25tZW50cyBsaWtlIHRlc3RzIGFuZCBSZWFjdCBOYXRpdmUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3Rvcnkob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGxldCB7XG4gICAgaW5pdGlhbEVudHJpZXMgPSBbXCIvXCJdLFxuICAgIGluaXRpYWxJbmRleCxcbiAgICB2NUNvbXBhdCA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBsZXQgZW50cmllczsgLy8gRGVjbGFyZSBzbyB3ZSBjYW4gYWNjZXNzIGZyb20gY3JlYXRlTWVtb3J5TG9jYXRpb25cbiAgZW50cmllcyA9IGluaXRpYWxFbnRyaWVzLm1hcCgoZW50cnksIGluZGV4KSA9PiBjcmVhdGVNZW1vcnlMb2NhdGlvbihlbnRyeSwgdHlwZW9mIGVudHJ5ID09PSBcInN0cmluZ1wiID8gbnVsbCA6IGVudHJ5LnN0YXRlLCBpbmRleCA9PT0gMCA/IFwiZGVmYXVsdFwiIDogdW5kZWZpbmVkKSk7XG4gIGxldCBpbmRleCA9IGNsYW1wSW5kZXgoaW5pdGlhbEluZGV4ID09IG51bGwgPyBlbnRyaWVzLmxlbmd0aCAtIDEgOiBpbml0aWFsSW5kZXgpO1xuICBsZXQgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgbGV0IGxpc3RlbmVyID0gbnVsbDtcbiAgZnVuY3Rpb24gY2xhbXBJbmRleChuKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sIDApLCBlbnRyaWVzLmxlbmd0aCAtIDEpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgICByZXR1cm4gZW50cmllc1tpbmRleF07XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlTWVtb3J5TG9jYXRpb24odG8sIHN0YXRlLCBrZXkpIHtcbiAgICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgc3RhdGUgPSBudWxsO1xuICAgIH1cbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihlbnRyaWVzID8gZ2V0Q3VycmVudExvY2F0aW9uKCkucGF0aG5hbWUgOiBcIi9cIiwgdG8sIHN0YXRlLCBrZXkpO1xuICAgIHdhcm5pbmcobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSBcIi9cIiwgXCJyZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gbWVtb3J5IGhpc3Rvcnk6IFwiICsgSlNPTi5zdHJpbmdpZnkodG8pKTtcbiAgICByZXR1cm4gbG9jYXRpb247XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSHJlZih0bykge1xuICAgIHJldHVybiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICB9XG4gIGxldCBoaXN0b3J5ID0ge1xuICAgIGdldCBpbmRleCgpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuICAgIGdldCBhY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH0sXG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIGdldEN1cnJlbnRMb2NhdGlvbigpO1xuICAgIH0sXG4gICAgY3JlYXRlSHJlZixcbiAgICBjcmVhdGVVUkwodG8pIHtcbiAgICAgIHJldHVybiBuZXcgVVJMKGNyZWF0ZUhyZWYodG8pLCBcImh0dHA6Ly9sb2NhbGhvc3RcIik7XG4gICAgfSxcbiAgICBlbmNvZGVMb2NhdGlvbih0bykge1xuICAgICAgbGV0IHBhdGggPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG87XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRobmFtZTogcGF0aC5wYXRobmFtZSB8fCBcIlwiLFxuICAgICAgICBzZWFyY2g6IHBhdGguc2VhcmNoIHx8IFwiXCIsXG4gICAgICAgIGhhc2g6IHBhdGguaGFzaCB8fCBcIlwiXG4gICAgICB9O1xuICAgIH0sXG4gICAgcHVzaCh0bywgc3RhdGUpIHtcbiAgICAgIGFjdGlvbiA9IEFjdGlvbi5QdXNoO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSk7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIGVudHJpZXMubGVuZ3RoLCBuZXh0TG9jYXRpb24pO1xuICAgICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvbixcbiAgICAgICAgICBkZWx0YTogMVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlcGxhY2UodG8sIHN0YXRlKSB7XG4gICAgICBhY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcbiAgICAgIGxldCBuZXh0TG9jYXRpb24gPSBjcmVhdGVNZW1vcnlMb2NhdGlvbih0bywgc3RhdGUpO1xuICAgICAgZW50cmllc1tpbmRleF0gPSBuZXh0TG9jYXRpb247XG4gICAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIoe1xuICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICAgIGRlbHRhOiAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ28oZGVsdGEpIHtcbiAgICAgIGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gICAgICBsZXQgbmV4dEluZGV4ID0gY2xhbXBJbmRleChpbmRleCArIGRlbHRhKTtcbiAgICAgIGxldCBuZXh0TG9jYXRpb24gPSBlbnRyaWVzW25leHRJbmRleF07XG4gICAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7XG4gICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sXG4gICAgICAgICAgZGVsdGFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBsaXN0ZW4oZm4pIHtcbiAgICAgIGxpc3RlbmVyID0gZm47XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBsaXN0ZW5lciA9IG51bGw7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG4vKipcbiAqIEJyb3dzZXIgaGlzdG9yeSBzdG9yZXMgdGhlIGxvY2F0aW9uIGluIHJlZ3VsYXIgVVJMcy4gVGhpcyBpcyB0aGUgc3RhbmRhcmQgZm9yXG4gKiBtb3N0IHdlYiBhcHBzLCBidXQgaXQgcmVxdWlyZXMgc29tZSBjb25maWd1cmF0aW9uIG9uIHRoZSBzZXJ2ZXIgdG8gZW5zdXJlIHlvdVxuICogc2VydmUgdGhlIHNhbWUgYXBwIGF0IG11bHRpcGxlIFVSTHMuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNjcmVhdGVicm93c2VyaGlzdG9yeVxuICovXG5mdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlQnJvd3NlckxvY2F0aW9uKHdpbmRvdywgZ2xvYmFsSGlzdG9yeSkge1xuICAgIGxldCB7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIHNlYXJjaCxcbiAgICAgIGhhc2hcbiAgICB9ID0gd2luZG93LmxvY2F0aW9uO1xuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihcIlwiLCB7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIHNlYXJjaCxcbiAgICAgIGhhc2hcbiAgICB9LFxuICAgIC8vIHN0YXRlIGRlZmF1bHRzIHRvIGBudWxsYCBiZWNhdXNlIGB3aW5kb3cuaGlzdG9yeS5zdGF0ZWAgZG9lc1xuICAgIGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS51c3IgfHwgbnVsbCwgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLmtleSB8fCBcImRlZmF1bHRcIik7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlQnJvd3NlckhyZWYod2luZG93LCB0bykge1xuICAgIHJldHVybiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICB9XG4gIHJldHVybiBnZXRVcmxCYXNlZEhpc3RvcnkoY3JlYXRlQnJvd3NlckxvY2F0aW9uLCBjcmVhdGVCcm93c2VySHJlZiwgbnVsbCwgb3B0aW9ucyk7XG59XG4vKipcbiAqIEhhc2ggaGlzdG9yeSBzdG9yZXMgdGhlIGxvY2F0aW9uIGluIHdpbmRvdy5sb2NhdGlvbi5oYXNoLiBUaGlzIG1ha2VzIGl0IGlkZWFsXG4gKiBmb3Igc2l0dWF0aW9ucyB3aGVyZSB5b3UgZG9uJ3Qgd2FudCB0byBzZW5kIHRoZSBsb2NhdGlvbiB0byB0aGUgc2VydmVyIGZvclxuICogc29tZSByZWFzb24sIGVpdGhlciBiZWNhdXNlIHlvdSBkbyBjYW5ub3QgY29uZmlndXJlIGl0IG9yIHRoZSBVUkwgc3BhY2UgaXNcbiAqIHJlc2VydmVkIGZvciBzb21ldGhpbmcgZWxzZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZWhhc2hoaXN0b3J5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVIYXNoTG9jYXRpb24od2luZG93LCBnbG9iYWxIaXN0b3J5KSB7XG4gICAgbGV0IHtcbiAgICAgIHBhdGhuYW1lID0gXCIvXCIsXG4gICAgICBzZWFyY2ggPSBcIlwiLFxuICAgICAgaGFzaCA9IFwiXCJcbiAgICB9ID0gcGFyc2VQYXRoKHdpbmRvdy5sb2NhdGlvbi5oYXNoLnN1YnN0cigxKSk7XG4gICAgLy8gSGFzaCBVUkwgc2hvdWxkIGFsd2F5cyBoYXZlIGEgbGVhZGluZyAvIGp1c3QgbGlrZSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWVcbiAgICAvLyBkb2VzLCBzbyBpZiBhbiBhcHAgZW5kcyB1cCBhdCBhIHJvdXRlIGxpa2UgLyNzb21ldGhpbmcgdGhlbiB3ZSBhZGQgYVxuICAgIC8vIGxlYWRpbmcgc2xhc2ggc28gYWxsIG9mIG91ciBwYXRoLW1hdGNoaW5nIGJlaGF2ZXMgdGhlIHNhbWUgYXMgaWYgaXQgd291bGRcbiAgICAvLyBpbiBhIGJyb3dzZXIgcm91dGVyLiAgVGhpcyBpcyBwYXJ0aWN1bGFybHkgaW1wb3J0YW50IHdoZW4gdGhlcmUgZXhpc3RzIGFcbiAgICAvLyByb290IHNwbGF0IHJvdXRlICg8Um91dGUgcGF0aD1cIipcIj4pIHNpbmNlIHRoYXQgbWF0Y2hlcyBpbnRlcm5hbGx5IGFnYWluc3RcbiAgICAvLyBcIi8qXCIgYW5kIHdlJ2QgZXhwZWN0IC8jc29tZXRoaW5nIHRvIDQwNCBpbiBhIGhhc2ggcm91dGVyIGFwcC5cbiAgICBpZiAoIXBhdGhuYW1lLnN0YXJ0c1dpdGgoXCIvXCIpICYmICFwYXRobmFtZS5zdGFydHNXaXRoKFwiLlwiKSkge1xuICAgICAgcGF0aG5hbWUgPSBcIi9cIiArIHBhdGhuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24oXCJcIiwge1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBzZWFyY2gsXG4gICAgICBoYXNoXG4gICAgfSxcbiAgICAvLyBzdGF0ZSBkZWZhdWx0cyB0byBgbnVsbGAgYmVjYXVzZSBgd2luZG93Lmhpc3Rvcnkuc3RhdGVgIGRvZXNcbiAgICBnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUudXNyIHx8IG51bGwsIGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS5rZXkgfHwgXCJkZWZhdWx0XCIpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUhhc2hIcmVmKHdpbmRvdywgdG8pIHtcbiAgICBsZXQgYmFzZSA9IHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYmFzZVwiKTtcbiAgICBsZXQgaHJlZiA9IFwiXCI7XG4gICAgaWYgKGJhc2UgJiYgYmFzZS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpKSB7XG4gICAgICBsZXQgdXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgICBsZXQgaGFzaEluZGV4ID0gdXJsLmluZGV4T2YoXCIjXCIpO1xuICAgICAgaHJlZiA9IGhhc2hJbmRleCA9PT0gLTEgPyB1cmwgOiB1cmwuc2xpY2UoMCwgaGFzaEluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGhyZWYgKyBcIiNcIiArICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pKTtcbiAgfVxuICBmdW5jdGlvbiB2YWxpZGF0ZUhhc2hMb2NhdGlvbihsb2NhdGlvbiwgdG8pIHtcbiAgICB3YXJuaW5nKGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gXCIvXCIsIFwicmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGhhc2ggaGlzdG9yeS5wdXNoKFwiICsgSlNPTi5zdHJpbmdpZnkodG8pICsgXCIpXCIpO1xuICB9XG4gIHJldHVybiBnZXRVcmxCYXNlZEhpc3RvcnkoY3JlYXRlSGFzaExvY2F0aW9uLCBjcmVhdGVIYXNoSHJlZiwgdmFsaWRhdGVIYXNoTG9jYXRpb24sIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gaW52YXJpYW50KHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuaW5nKGNvbmQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB0cnkge1xuICAgICAgLy8gV2VsY29tZSB0byBkZWJ1Z2dpbmcgaGlzdG9yeSFcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIHRocm93biBhcyBhIGNvbnZlbmllbmNlLCBzbyB5b3UgY2FuIG1vcmUgZWFzaWx5XG4gICAgICAvLyBmaW5kIHRoZSBzb3VyY2UgZm9yIGEgd2FybmluZyB0aGF0IGFwcGVhcnMgaW4gdGhlIGNvbnNvbGUgYnlcbiAgICAgIC8vIGVuYWJsaW5nIFwicGF1c2Ugb24gZXhjZXB0aW9uc1wiIGluIHlvdXIgSmF2YVNjcmlwdCBkZWJ1Z2dlci5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA4KTtcbn1cbi8qKlxuICogRm9yIGJyb3dzZXItYmFzZWQgaGlzdG9yaWVzLCB3ZSBjb21iaW5lIHRoZSBzdGF0ZSBhbmQga2V5IGludG8gYW4gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpIHtcbiAgcmV0dXJuIHtcbiAgICB1c3I6IGxvY2F0aW9uLnN0YXRlLFxuICAgIGtleTogbG9jYXRpb24ua2V5LFxuICAgIGlkeDogaW5kZXhcbiAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIExvY2F0aW9uIG9iamVjdCB3aXRoIGEgdW5pcXVlIGtleSBmcm9tIHRoZSBnaXZlbiBQYXRoXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGN1cnJlbnQsIHRvLCBzdGF0ZSwga2V5KSB7XG4gIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgc3RhdGUgPSBudWxsO1xuICB9XG4gIGxldCBsb2NhdGlvbiA9IF9leHRlbmRzKHtcbiAgICBwYXRobmFtZTogdHlwZW9mIGN1cnJlbnQgPT09IFwic3RyaW5nXCIgPyBjdXJyZW50IDogY3VycmVudC5wYXRobmFtZSxcbiAgICBzZWFyY2g6IFwiXCIsXG4gICAgaGFzaDogXCJcIlxuICB9LCB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG8sIHtcbiAgICBzdGF0ZSxcbiAgICAvLyBUT0RPOiBUaGlzIGNvdWxkIGJlIGNsZWFuZWQgdXAuICBwdXNoL3JlcGxhY2Ugc2hvdWxkIHByb2JhYmx5IGp1c3QgdGFrZVxuICAgIC8vIGZ1bGwgTG9jYXRpb25zIG5vdyBhbmQgYXZvaWQgdGhlIG5lZWQgdG8gcnVuIHRocm91Z2ggdGhpcyBmbG93IGF0IGFsbFxuICAgIC8vIEJ1dCB0aGF0J3MgYSBwcmV0dHkgYmlnIHJlZmFjdG9yIHRvIHRoZSBjdXJyZW50IHRlc3Qgc3VpdGUgc28gZ29pbmcgdG9cbiAgICAvLyBrZWVwIGFzIGlzIGZvciB0aGUgdGltZSBiZWluZyBhbmQganVzdCBsZXQgYW55IGluY29taW5nIGtleXMgdGFrZSBwcmVjZWRlbmNlXG4gICAga2V5OiB0byAmJiB0by5rZXkgfHwga2V5IHx8IGNyZWF0ZUtleSgpXG4gIH0pO1xuICByZXR1cm4gbG9jYXRpb247XG59XG4vKipcbiAqIENyZWF0ZXMgYSBzdHJpbmcgVVJMIHBhdGggZnJvbSB0aGUgZ2l2ZW4gcGF0aG5hbWUsIHNlYXJjaCwgYW5kIGhhc2ggY29tcG9uZW50cy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGF0aChfcmVmKSB7XG4gIGxldCB7XG4gICAgcGF0aG5hbWUgPSBcIi9cIixcbiAgICBzZWFyY2ggPSBcIlwiLFxuICAgIGhhc2ggPSBcIlwiXG4gIH0gPSBfcmVmO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaCAhPT0gXCI/XCIpIHBhdGhuYW1lICs9IHNlYXJjaC5jaGFyQXQoMCkgPT09IFwiP1wiID8gc2VhcmNoIDogXCI/XCIgKyBzZWFyY2g7XG4gIGlmIChoYXNoICYmIGhhc2ggIT09IFwiI1wiKSBwYXRobmFtZSArPSBoYXNoLmNoYXJBdCgwKSA9PT0gXCIjXCIgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xuICByZXR1cm4gcGF0aG5hbWU7XG59XG4vKipcbiAqIFBhcnNlcyBhIHN0cmluZyBVUkwgcGF0aCBpbnRvIGl0cyBzZXBhcmF0ZSBwYXRobmFtZSwgc2VhcmNoLCBhbmQgaGFzaCBjb21wb25lbnRzLlxuICovXG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICBsZXQgcGFyc2VkUGF0aCA9IHt9O1xuICBpZiAocGF0aCkge1xuICAgIGxldCBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCIjXCIpO1xuICAgIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgICAgcGFyc2VkUGF0aC5oYXNoID0gcGF0aC5zdWJzdHIoaGFzaEluZGV4KTtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBoYXNoSW5kZXgpO1xuICAgIH1cbiAgICBsZXQgc2VhcmNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpO1xuICAgIGlmIChzZWFyY2hJbmRleCA+PSAwKSB7XG4gICAgICBwYXJzZWRQYXRoLnNlYXJjaCA9IHBhdGguc3Vic3RyKHNlYXJjaEluZGV4KTtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBzZWFyY2hJbmRleCk7XG4gICAgfVxuICAgIGlmIChwYXRoKSB7XG4gICAgICBwYXJzZWRQYXRoLnBhdGhuYW1lID0gcGF0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnNlZFBhdGg7XG59XG5mdW5jdGlvbiBnZXRVcmxCYXNlZEhpc3RvcnkoZ2V0TG9jYXRpb24sIGNyZWF0ZUhyZWYsIHZhbGlkYXRlTG9jYXRpb24sIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBsZXQge1xuICAgIHdpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LFxuICAgIHY1Q29tcGF0ID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGxldCBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIGxldCBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuICBsZXQgbGlzdGVuZXIgPSBudWxsO1xuICBsZXQgaW5kZXggPSBnZXRJbmRleCgpO1xuICAvLyBJbmRleCBzaG91bGQgb25seSBiZSBudWxsIHdoZW4gd2UgaW5pdGlhbGl6ZS4gSWYgbm90LCBpdCdzIGJlY2F1c2UgdGhlXG4gIC8vIHVzZXIgY2FsbGVkIGhpc3RvcnkucHVzaFN0YXRlIG9yIGhpc3RvcnkucmVwbGFjZVN0YXRlIGRpcmVjdGx5LCBpbiB3aGljaFxuICAvLyBjYXNlIHdlIHNob3VsZCBsb2cgYSB3YXJuaW5nIGFzIGl0IHdpbGwgcmVzdWx0IGluIGJ1Z3MuXG4gIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgaW5kZXggPSAwO1xuICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKF9leHRlbmRzKHt9LCBnbG9iYWxIaXN0b3J5LnN0YXRlLCB7XG4gICAgICBpZHg6IGluZGV4XG4gICAgfSksIFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEluZGV4KCkge1xuICAgIGxldCBzdGF0ZSA9IGdsb2JhbEhpc3Rvcnkuc3RhdGUgfHwge1xuICAgICAgaWR4OiBudWxsXG4gICAgfTtcbiAgICByZXR1cm4gc3RhdGUuaWR4O1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVBvcCgpIHtcbiAgICBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuICAgIGxldCBuZXh0SW5kZXggPSBnZXRJbmRleCgpO1xuICAgIGxldCBkZWx0YSA9IG5leHRJbmRleCA9PSBudWxsID8gbnVsbCA6IG5leHRJbmRleCAtIGluZGV4O1xuICAgIGluZGV4ID0gbmV4dEluZGV4O1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIoe1xuICAgICAgICBhY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLFxuICAgICAgICBkZWx0YVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHB1c2godG8sIHN0YXRlKSB7XG4gICAgYWN0aW9uID0gQWN0aW9uLlB1c2g7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oaGlzdG9yeS5sb2NhdGlvbiwgdG8sIHN0YXRlKTtcbiAgICBpZiAodmFsaWRhdGVMb2NhdGlvbikgdmFsaWRhdGVMb2NhdGlvbihsb2NhdGlvbiwgdG8pO1xuICAgIGluZGV4ID0gZ2V0SW5kZXgoKSArIDE7XG4gICAgbGV0IGhpc3RvcnlTdGF0ZSA9IGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpO1xuICAgIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgIC8vIHRyeS4uLmNhdGNoIGJlY2F1c2UgaU9TIGxpbWl0cyB1cyB0byAxMDAgcHVzaFN0YXRlIGNhbGxzIDovXG4gICAgdHJ5IHtcbiAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKGhpc3RvcnlTdGF0ZSwgXCJcIiwgdXJsKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSWYgdGhlIGV4Y2VwdGlvbiBpcyBiZWNhdXNlIGBzdGF0ZWAgY2FuJ3QgYmUgc2VyaWFsaXplZCwgbGV0IHRoYXQgdGhyb3dcbiAgICAgIC8vIG91dHdhcmRzIGp1c3QgbGlrZSBhIHJlcGxhY2UgY2FsbCB3b3VsZCBzbyB0aGUgZGV2IGtub3dzIHRoZSBjYXVzZVxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvbmF2LWhpc3RvcnktYXBpcy5odG1sI3NoYXJlZC1oaXN0b3J5LXB1c2gvcmVwbGFjZS1zdGF0ZS1zdGVwc1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3RydWN0dXJlZC1kYXRhLmh0bWwjc3RydWN0dXJlZHNlcmlhbGl6ZWludGVybmFsXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBET01FeGNlcHRpb24gJiYgZXJyb3IubmFtZSA9PT0gXCJEYXRhQ2xvbmVFcnJvclwiKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgLy8gVGhleSBhcmUgZ29pbmcgdG8gbG9zZSBzdGF0ZSBoZXJlLCBidXQgdGhlcmUgaXMgbm8gcmVhbFxuICAgICAgLy8gd2F5IHRvIHdhcm4gdGhlbSBhYm91dCBpdCBzaW5jZSB0aGUgcGFnZSB3aWxsIHJlZnJlc2guLi5cbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICB9XG4gICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7XG4gICAgICAgIGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sXG4gICAgICAgIGRlbHRhOiAxXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVwbGFjZSh0bywgc3RhdGUpIHtcbiAgICBhY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihoaXN0b3J5LmxvY2F0aW9uLCB0bywgc3RhdGUpO1xuICAgIGlmICh2YWxpZGF0ZUxvY2F0aW9uKSB2YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCB0byk7XG4gICAgaW5kZXggPSBnZXRJbmRleCgpO1xuICAgIGxldCBoaXN0b3J5U3RhdGUgPSBnZXRIaXN0b3J5U3RhdGUobG9jYXRpb24sIGluZGV4KTtcbiAgICBsZXQgdXJsID0gaGlzdG9yeS5jcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsIFwiXCIsIHVybCk7XG4gICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7XG4gICAgICAgIGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sXG4gICAgICAgIGRlbHRhOiAwXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlVVJMKHRvKSB7XG4gICAgLy8gd2luZG93LmxvY2F0aW9uLm9yaWdpbiBpcyBcIm51bGxcIiAodGhlIGxpdGVyYWwgc3RyaW5nIHZhbHVlKSBpbiBGaXJlZm94XG4gICAgLy8gdW5kZXIgY2VydGFpbiBjb25kaXRpb25zLCBub3RhYmx5IHdoZW4gc2VydmluZyBmcm9tIGEgbG9jYWwgSFRNTCBmaWxlXG4gICAgLy8gU2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg3ODI5N1xuICAgIGxldCBiYXNlID0gd2luZG93LmxvY2F0aW9uLm9yaWdpbiAhPT0gXCJudWxsXCIgPyB3aW5kb3cubG9jYXRpb24ub3JpZ2luIDogd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgbGV0IGhyZWYgPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICAgIC8vIFRyZWF0aW5nIHRoaXMgYXMgYSBmdWxsIFVSTCB3aWxsIHN0cmlwIGFueSB0cmFpbGluZyBzcGFjZXMgc28gd2UgbmVlZCB0b1xuICAgIC8vIHByZS1lbmNvZGUgdGhlbSBzaW5jZSB0aGV5IG1pZ2h0IGJlIHBhcnQgb2YgYSBtYXRjaGluZyBzcGxhdCBwYXJhbSBmcm9tXG4gICAgLy8gYW4gYW5jZXN0b3Igcm91dGVcbiAgICBocmVmID0gaHJlZi5yZXBsYWNlKC8gJC8sIFwiJTIwXCIpO1xuICAgIGludmFyaWFudChiYXNlLCBcIk5vIHdpbmRvdy5sb2NhdGlvbi4ob3JpZ2lufGhyZWYpIGF2YWlsYWJsZSB0byBjcmVhdGUgVVJMIGZvciBocmVmOiBcIiArIGhyZWYpO1xuICAgIHJldHVybiBuZXcgVVJMKGhyZWYsIGJhc2UpO1xuICB9XG4gIGxldCBoaXN0b3J5ID0ge1xuICAgIGdldCBhY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH0sXG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIGdldExvY2F0aW9uKHdpbmRvdywgZ2xvYmFsSGlzdG9yeSk7XG4gICAgfSxcbiAgICBsaXN0ZW4oZm4pIHtcbiAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGhpc3Rvcnkgb25seSBhY2NlcHRzIG9uZSBhY3RpdmUgbGlzdGVuZXJcIik7XG4gICAgICB9XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50VHlwZSwgaGFuZGxlUG9wKTtcbiAgICAgIGxpc3RlbmVyID0gZm47XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50VHlwZSwgaGFuZGxlUG9wKTtcbiAgICAgICAgbGlzdGVuZXIgPSBudWxsO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGNyZWF0ZUhyZWYodG8pIHtcbiAgICAgIHJldHVybiBjcmVhdGVIcmVmKHdpbmRvdywgdG8pO1xuICAgIH0sXG4gICAgY3JlYXRlVVJMLFxuICAgIGVuY29kZUxvY2F0aW9uKHRvKSB7XG4gICAgICAvLyBFbmNvZGUgYSBMb2NhdGlvbiB0aGUgc2FtZSB3YXkgd2luZG93LmxvY2F0aW9uIHdvdWxkXG4gICAgICBsZXQgdXJsID0gY3JlYXRlVVJMKHRvKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhuYW1lOiB1cmwucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaDogdXJsLnNlYXJjaCxcbiAgICAgICAgaGFzaDogdXJsLmhhc2hcbiAgICAgIH07XG4gICAgfSxcbiAgICBwdXNoLFxuICAgIHJlcGxhY2UsXG4gICAgZ28obikge1xuICAgICAgcmV0dXJuIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGlzdG9yeTtcbn1cbi8vI2VuZHJlZ2lvblxuXG52YXIgUmVzdWx0VHlwZTtcbihmdW5jdGlvbiAoUmVzdWx0VHlwZSkge1xuICBSZXN1bHRUeXBlW1wiZGF0YVwiXSA9IFwiZGF0YVwiO1xuICBSZXN1bHRUeXBlW1wiZGVmZXJyZWRcIl0gPSBcImRlZmVycmVkXCI7XG4gIFJlc3VsdFR5cGVbXCJyZWRpcmVjdFwiXSA9IFwicmVkaXJlY3RcIjtcbiAgUmVzdWx0VHlwZVtcImVycm9yXCJdID0gXCJlcnJvclwiO1xufSkoUmVzdWx0VHlwZSB8fCAoUmVzdWx0VHlwZSA9IHt9KSk7XG5jb25zdCBpbW11dGFibGVSb3V0ZUtleXMgPSBuZXcgU2V0KFtcImxhenlcIiwgXCJjYXNlU2Vuc2l0aXZlXCIsIFwicGF0aFwiLCBcImlkXCIsIFwiaW5kZXhcIiwgXCJjaGlsZHJlblwiXSk7XG5mdW5jdGlvbiBpc0luZGV4Um91dGUocm91dGUpIHtcbiAgcmV0dXJuIHJvdXRlLmluZGV4ID09PSB0cnVlO1xufVxuLy8gV2FsayB0aGUgcm91dGUgdHJlZSBnZW5lcmF0aW5nIHVuaXF1ZSBJRHMgd2hlcmUgbmVjZXNzYXJ5LCBzbyB3ZSBhcmUgd29ya2luZ1xuLy8gc29sZWx5IHdpdGggQWdub3N0aWNEYXRhUm91dGVPYmplY3QncyB3aXRoaW4gdGhlIFJvdXRlclxuZnVuY3Rpb24gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhyb3V0ZXMsIG1hcFJvdXRlUHJvcGVydGllcywgcGFyZW50UGF0aCwgbWFuaWZlc3QpIHtcbiAgaWYgKHBhcmVudFBhdGggPT09IHZvaWQgMCkge1xuICAgIHBhcmVudFBhdGggPSBbXTtcbiAgfVxuICBpZiAobWFuaWZlc3QgPT09IHZvaWQgMCkge1xuICAgIG1hbmlmZXN0ID0ge307XG4gIH1cbiAgcmV0dXJuIHJvdXRlcy5tYXAoKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIGxldCB0cmVlUGF0aCA9IFsuLi5wYXJlbnRQYXRoLCBpbmRleF07XG4gICAgbGV0IGlkID0gdHlwZW9mIHJvdXRlLmlkID09PSBcInN0cmluZ1wiID8gcm91dGUuaWQgOiB0cmVlUGF0aC5qb2luKFwiLVwiKTtcbiAgICBpbnZhcmlhbnQocm91dGUuaW5kZXggIT09IHRydWUgfHwgIXJvdXRlLmNoaWxkcmVuLCBcIkNhbm5vdCBzcGVjaWZ5IGNoaWxkcmVuIG9uIGFuIGluZGV4IHJvdXRlXCIpO1xuICAgIGludmFyaWFudCghbWFuaWZlc3RbaWRdLCBcIkZvdW5kIGEgcm91dGUgaWQgY29sbGlzaW9uIG9uIGlkIFxcXCJcIiArIGlkICsgXCJcXFwiLiAgUm91dGUgXCIgKyBcImlkJ3MgbXVzdCBiZSBnbG9iYWxseSB1bmlxdWUgd2l0aGluIERhdGEgUm91dGVyIHVzYWdlc1wiKTtcbiAgICBpZiAoaXNJbmRleFJvdXRlKHJvdXRlKSkge1xuICAgICAgbGV0IGluZGV4Um91dGUgPSBfZXh0ZW5kcyh7fSwgcm91dGUsIG1hcFJvdXRlUHJvcGVydGllcyhyb3V0ZSksIHtcbiAgICAgICAgaWRcbiAgICAgIH0pO1xuICAgICAgbWFuaWZlc3RbaWRdID0gaW5kZXhSb3V0ZTtcbiAgICAgIHJldHVybiBpbmRleFJvdXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGF0aE9yTGF5b3V0Um91dGUgPSBfZXh0ZW5kcyh7fSwgcm91dGUsIG1hcFJvdXRlUHJvcGVydGllcyhyb3V0ZSksIHtcbiAgICAgICAgaWQsXG4gICAgICAgIGNoaWxkcmVuOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgbWFuaWZlc3RbaWRdID0gcGF0aE9yTGF5b3V0Um91dGU7XG4gICAgICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcGF0aE9yTGF5b3V0Um91dGUuY2hpbGRyZW4gPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKHJvdXRlLmNoaWxkcmVuLCBtYXBSb3V0ZVByb3BlcnRpZXMsIHRyZWVQYXRoLCBtYW5pZmVzdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0aE9yTGF5b3V0Um91dGU7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogTWF0Y2hlcyB0aGUgZ2l2ZW4gcm91dGVzIHRvIGEgbG9jYXRpb24gYW5kIHJldHVybnMgdGhlIG1hdGNoIGRhdGEuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9tYXRjaC1yb3V0ZXNcbiAqL1xuZnVuY3Rpb24gbWF0Y2hSb3V0ZXMocm91dGVzLCBsb2NhdGlvbkFyZywgYmFzZW5hbWUpIHtcbiAgaWYgKGJhc2VuYW1lID09PSB2b2lkIDApIHtcbiAgICBiYXNlbmFtZSA9IFwiL1wiO1xuICB9XG4gIGxldCBsb2NhdGlvbiA9IHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcbiAgbGV0IHBhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIiwgYmFzZW5hbWUpO1xuICBpZiAocGF0aG5hbWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBicmFuY2hlcyA9IGZsYXR0ZW5Sb3V0ZXMocm91dGVzKTtcbiAgcmFua1JvdXRlQnJhbmNoZXMoYnJhbmNoZXMpO1xuICBsZXQgbWF0Y2hlcyA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBtYXRjaGVzID09IG51bGwgJiYgaSA8IGJyYW5jaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gSW5jb21pbmcgcGF0aG5hbWVzIGFyZSBnZW5lcmFsbHkgZW5jb2RlZCBmcm9tIGVpdGhlciB3aW5kb3cubG9jYXRpb25cbiAgICAvLyBvciBmcm9tIHJvdXRlci5uYXZpZ2F0ZSwgYnV0IHdlIHdhbnQgdG8gbWF0Y2ggYWdhaW5zdCB0aGUgdW5lbmNvZGVkXG4gICAgLy8gcGF0aHMgaW4gdGhlIHJvdXRlIGRlZmluaXRpb25zLiAgTWVtb3J5IHJvdXRlciBsb2NhdGlvbnMgd29uJ3QgYmVcbiAgICAvLyBlbmNvZGVkIGhlcmUgYnV0IHRoZXJlIGFsc28gc2hvdWxkbid0IGJlIGFueXRoaW5nIHRvIGRlY29kZSBzbyB0aGlzXG4gICAgLy8gc2hvdWxkIGJlIGEgc2FmZSBvcGVyYXRpb24uICBUaGlzIGF2b2lkcyBuZWVkaW5nIG1hdGNoUm91dGVzIHRvIGJlXG4gICAgLy8gaGlzdG9yeS1hd2FyZS5cbiAgICBsZXQgZGVjb2RlZCA9IGRlY29kZVBhdGgocGF0aG5hbWUpO1xuICAgIG1hdGNoZXMgPSBtYXRjaFJvdXRlQnJhbmNoKGJyYW5jaGVzW2ldLCBkZWNvZGVkKTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn1cbmZ1bmN0aW9uIGNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoKG1hdGNoLCBsb2FkZXJEYXRhKSB7XG4gIGxldCB7XG4gICAgcm91dGUsXG4gICAgcGF0aG5hbWUsXG4gICAgcGFyYW1zXG4gIH0gPSBtYXRjaDtcbiAgcmV0dXJuIHtcbiAgICBpZDogcm91dGUuaWQsXG4gICAgcGF0aG5hbWUsXG4gICAgcGFyYW1zLFxuICAgIGRhdGE6IGxvYWRlckRhdGFbcm91dGUuaWRdLFxuICAgIGhhbmRsZTogcm91dGUuaGFuZGxlXG4gIH07XG59XG5mdW5jdGlvbiBmbGF0dGVuUm91dGVzKHJvdXRlcywgYnJhbmNoZXMsIHBhcmVudHNNZXRhLCBwYXJlbnRQYXRoKSB7XG4gIGlmIChicmFuY2hlcyA9PT0gdm9pZCAwKSB7XG4gICAgYnJhbmNoZXMgPSBbXTtcbiAgfVxuICBpZiAocGFyZW50c01ldGEgPT09IHZvaWQgMCkge1xuICAgIHBhcmVudHNNZXRhID0gW107XG4gIH1cbiAgaWYgKHBhcmVudFBhdGggPT09IHZvaWQgMCkge1xuICAgIHBhcmVudFBhdGggPSBcIlwiO1xuICB9XG4gIGxldCBmbGF0dGVuUm91dGUgPSAocm91dGUsIGluZGV4LCByZWxhdGl2ZVBhdGgpID0+IHtcbiAgICBsZXQgbWV0YSA9IHtcbiAgICAgIHJlbGF0aXZlUGF0aDogcmVsYXRpdmVQYXRoID09PSB1bmRlZmluZWQgPyByb3V0ZS5wYXRoIHx8IFwiXCIgOiByZWxhdGl2ZVBhdGgsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiByb3V0ZS5jYXNlU2Vuc2l0aXZlID09PSB0cnVlLFxuICAgICAgY2hpbGRyZW5JbmRleDogaW5kZXgsXG4gICAgICByb3V0ZVxuICAgIH07XG4gICAgaWYgKG1ldGEucmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICBpbnZhcmlhbnQobWV0YS5yZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChwYXJlbnRQYXRoKSwgXCJBYnNvbHV0ZSByb3V0ZSBwYXRoIFxcXCJcIiArIG1ldGEucmVsYXRpdmVQYXRoICsgXCJcXFwiIG5lc3RlZCB1bmRlciBwYXRoIFwiICsgKFwiXFxcIlwiICsgcGFyZW50UGF0aCArIFwiXFxcIiBpcyBub3QgdmFsaWQuIEFuIGFic29sdXRlIGNoaWxkIHJvdXRlIHBhdGggXCIpICsgXCJtdXN0IHN0YXJ0IHdpdGggdGhlIGNvbWJpbmVkIHBhdGggb2YgYWxsIGl0cyBwYXJlbnQgcm91dGVzLlwiKTtcbiAgICAgIG1ldGEucmVsYXRpdmVQYXRoID0gbWV0YS5yZWxhdGl2ZVBhdGguc2xpY2UocGFyZW50UGF0aC5sZW5ndGgpO1xuICAgIH1cbiAgICBsZXQgcGF0aCA9IGpvaW5QYXRocyhbcGFyZW50UGF0aCwgbWV0YS5yZWxhdGl2ZVBhdGhdKTtcbiAgICBsZXQgcm91dGVzTWV0YSA9IHBhcmVudHNNZXRhLmNvbmNhdChtZXRhKTtcbiAgICAvLyBBZGQgdGhlIGNoaWxkcmVuIGJlZm9yZSBhZGRpbmcgdGhpcyByb3V0ZSB0byB0aGUgYXJyYXksIHNvIHdlIHRyYXZlcnNlIHRoZVxuICAgIC8vIHJvdXRlIHRyZWUgZGVwdGgtZmlyc3QgYW5kIGNoaWxkIHJvdXRlcyBhcHBlYXIgYmVmb3JlIHRoZWlyIHBhcmVudHMgaW5cbiAgICAvLyB0aGUgXCJmbGF0dGVuZWRcIiB2ZXJzaW9uLlxuICAgIGlmIChyb3V0ZS5jaGlsZHJlbiAmJiByb3V0ZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAvLyBPdXIgdHlwZXMga25vdyBiZXR0ZXIsIGJ1dCBydW50aW1lIEpTIG1heSBub3QhXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICByb3V0ZS5pbmRleCAhPT0gdHJ1ZSwgXCJJbmRleCByb3V0ZXMgbXVzdCBub3QgaGF2ZSBjaGlsZCByb3V0ZXMuIFBsZWFzZSByZW1vdmUgXCIgKyAoXCJhbGwgY2hpbGQgcm91dGVzIGZyb20gcm91dGUgcGF0aCBcXFwiXCIgKyBwYXRoICsgXCJcXFwiLlwiKSk7XG4gICAgICBmbGF0dGVuUm91dGVzKHJvdXRlLmNoaWxkcmVuLCBicmFuY2hlcywgcm91dGVzTWV0YSwgcGF0aCk7XG4gICAgfVxuICAgIC8vIFJvdXRlcyB3aXRob3V0IGEgcGF0aCBzaG91bGRuJ3QgZXZlciBtYXRjaCBieSB0aGVtc2VsdmVzIHVubGVzcyB0aGV5IGFyZVxuICAgIC8vIGluZGV4IHJvdXRlcywgc28gZG9uJ3QgYWRkIHRoZW0gdG8gdGhlIGxpc3Qgb2YgcG9zc2libGUgYnJhbmNoZXMuXG4gICAgaWYgKHJvdXRlLnBhdGggPT0gbnVsbCAmJiAhcm91dGUuaW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYnJhbmNoZXMucHVzaCh7XG4gICAgICBwYXRoLFxuICAgICAgc2NvcmU6IGNvbXB1dGVTY29yZShwYXRoLCByb3V0ZS5pbmRleCksXG4gICAgICByb3V0ZXNNZXRhXG4gICAgfSk7XG4gIH07XG4gIHJvdXRlcy5mb3JFYWNoKChyb3V0ZSwgaW5kZXgpID0+IHtcbiAgICB2YXIgX3JvdXRlJHBhdGg7XG4gICAgLy8gY29hcnNlLWdyYWluIGNoZWNrIGZvciBvcHRpb25hbCBwYXJhbXNcbiAgICBpZiAocm91dGUucGF0aCA9PT0gXCJcIiB8fCAhKChfcm91dGUkcGF0aCA9IHJvdXRlLnBhdGgpICE9IG51bGwgJiYgX3JvdXRlJHBhdGguaW5jbHVkZXMoXCI/XCIpKSkge1xuICAgICAgZmxhdHRlblJvdXRlKHJvdXRlLCBpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGV4cGxvZGVkIG9mIGV4cGxvZGVPcHRpb25hbFNlZ21lbnRzKHJvdXRlLnBhdGgpKSB7XG4gICAgICAgIGZsYXR0ZW5Sb3V0ZShyb3V0ZSwgaW5kZXgsIGV4cGxvZGVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYnJhbmNoZXM7XG59XG4vKipcbiAqIENvbXB1dGVzIGFsbCBjb21iaW5hdGlvbnMgb2Ygb3B0aW9uYWwgcGF0aCBzZWdtZW50cyBmb3IgYSBnaXZlbiBwYXRoLFxuICogZXhjbHVkaW5nIGNvbWJpbmF0aW9ucyB0aGF0IGFyZSBhbWJpZ3VvdXMgYW5kIG9mIGxvd2VyIHByaW9yaXR5LlxuICpcbiAqIEZvciBleGFtcGxlLCBgL29uZS86dHdvPy90aHJlZS86Zm91cj8vOmZpdmU/YCBleHBsb2RlcyB0bzpcbiAqIC0gYC9vbmUvdGhyZWVgXG4gKiAtIGAvb25lLzp0d28vdGhyZWVgXG4gKiAtIGAvb25lL3RocmVlLzpmb3VyYFxuICogLSBgL29uZS90aHJlZS86Zml2ZWBcbiAqIC0gYC9vbmUvOnR3by90aHJlZS86Zm91cmBcbiAqIC0gYC9vbmUvOnR3by90aHJlZS86Zml2ZWBcbiAqIC0gYC9vbmUvdGhyZWUvOmZvdXIvOmZpdmVgXG4gKiAtIGAvb25lLzp0d28vdGhyZWUvOmZvdXIvOmZpdmVgXG4gKi9cbmZ1bmN0aW9uIGV4cGxvZGVPcHRpb25hbFNlZ21lbnRzKHBhdGgpIHtcbiAgbGV0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcbiAgbGV0IFtmaXJzdCwgLi4ucmVzdF0gPSBzZWdtZW50cztcbiAgLy8gT3B0aW9uYWwgcGF0aCBzZWdtZW50cyBhcmUgZGVub3RlZCBieSBhIHRyYWlsaW5nIGA/YFxuICBsZXQgaXNPcHRpb25hbCA9IGZpcnN0LmVuZHNXaXRoKFwiP1wiKTtcbiAgLy8gQ29tcHV0ZSB0aGUgY29ycmVzcG9uZGluZyByZXF1aXJlZCBzZWdtZW50OiBgZm9vP2AgLT4gYGZvb2BcbiAgbGV0IHJlcXVpcmVkID0gZmlyc3QucmVwbGFjZSgvXFw/JC8sIFwiXCIpO1xuICBpZiAocmVzdC5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJbnRlcHJldCBlbXB0eSBzdHJpbmcgYXMgb21pdHRpbmcgYW4gb3B0aW9uYWwgc2VnbWVudFxuICAgIC8vIGBbXCJvbmVcIiwgXCJcIiwgXCJ0aHJlZVwiXWAgY29ycmVzcG9uZHMgdG8gb21pdHRpbmcgYDp0d29gIGZyb20gYC9vbmUvOnR3bz8vdGhyZWVgIC0+IGAvb25lL3RocmVlYFxuICAgIHJldHVybiBpc09wdGlvbmFsID8gW3JlcXVpcmVkLCBcIlwiXSA6IFtyZXF1aXJlZF07XG4gIH1cbiAgbGV0IHJlc3RFeHBsb2RlZCA9IGV4cGxvZGVPcHRpb25hbFNlZ21lbnRzKHJlc3Quam9pbihcIi9cIikpO1xuICBsZXQgcmVzdWx0ID0gW107XG4gIC8vIEFsbCBjaGlsZCBwYXRocyB3aXRoIHRoZSBwcmVmaXguICBEbyB0aGlzIGZvciBhbGwgY2hpbGRyZW4gYmVmb3JlIHRoZVxuICAvLyBvcHRpb25hbCB2ZXJzaW9uIGZvciBhbGwgY2hpbGRyZW4sIHNvIHdlIGdldCBjb25zaXN0ZW50IG9yZGVyaW5nIHdoZXJlIHRoZVxuICAvLyBwYXJlbnQgb3B0aW9uYWwgYXNwZWN0IGlzIHByZWZlcnJlZCBhcyByZXF1aXJlZC4gIE90aGVyd2lzZSwgd2UgY2FuIGdldFxuICAvLyBjaGlsZCBzZWN0aW9ucyBpbnRlcnNwZXJzZWQgd2hlcmUgZGVlcGVyIG9wdGlvbmFsIHNlZ21lbnRzIGFyZSBoaWdoZXIgdGhhblxuICAvLyBwYXJlbnQgb3B0aW9uYWwgc2VnbWVudHMsIHdoZXJlIGZvciBleGFtcGxlLCAvOnR3byB3b3VsZCBleHBsb2RlIF9lYXJsaWVyX1xuICAvLyB0aGVuIC86b25lLiAgQnkgYWx3YXlzIGluY2x1ZGluZyB0aGUgcGFyZW50IGFzIHJlcXVpcmVkIF9mb3IgYWxsIGNoaWxkcmVuX1xuICAvLyBmaXJzdCwgd2UgYXZvaWQgdGhpcyBpc3N1ZVxuICByZXN1bHQucHVzaCguLi5yZXN0RXhwbG9kZWQubWFwKHN1YnBhdGggPT4gc3VicGF0aCA9PT0gXCJcIiA/IHJlcXVpcmVkIDogW3JlcXVpcmVkLCBzdWJwYXRoXS5qb2luKFwiL1wiKSkpO1xuICAvLyBUaGVuLCBpZiB0aGlzIGlzIGFuIG9wdGlvbmFsIHZhbHVlLCBhZGQgYWxsIGNoaWxkIHZlcnNpb25zIHdpdGhvdXRcbiAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICByZXN1bHQucHVzaCguLi5yZXN0RXhwbG9kZWQpO1xuICB9XG4gIC8vIGZvciBhYnNvbHV0ZSBwYXRocywgZW5zdXJlIGAvYCBpbnN0ZWFkIG9mIGVtcHR5IHNlZ21lbnRcbiAgcmV0dXJuIHJlc3VsdC5tYXAoZXhwbG9kZWQgPT4gcGF0aC5zdGFydHNXaXRoKFwiL1wiKSAmJiBleHBsb2RlZCA9PT0gXCJcIiA/IFwiL1wiIDogZXhwbG9kZWQpO1xufVxuZnVuY3Rpb24gcmFua1JvdXRlQnJhbmNoZXMoYnJhbmNoZXMpIHtcbiAgYnJhbmNoZXMuc29ydCgoYSwgYikgPT4gYS5zY29yZSAhPT0gYi5zY29yZSA/IGIuc2NvcmUgLSBhLnNjb3JlIC8vIEhpZ2hlciBzY29yZSBmaXJzdFxuICA6IGNvbXBhcmVJbmRleGVzKGEucm91dGVzTWV0YS5tYXAobWV0YSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpLCBiLnJvdXRlc01ldGEubWFwKG1ldGEgPT4gbWV0YS5jaGlsZHJlbkluZGV4KSkpO1xufVxuY29uc3QgcGFyYW1SZSA9IC9eOltcXHctXSskLztcbmNvbnN0IGR5bmFtaWNTZWdtZW50VmFsdWUgPSAzO1xuY29uc3QgaW5kZXhSb3V0ZVZhbHVlID0gMjtcbmNvbnN0IGVtcHR5U2VnbWVudFZhbHVlID0gMTtcbmNvbnN0IHN0YXRpY1NlZ21lbnRWYWx1ZSA9IDEwO1xuY29uc3Qgc3BsYXRQZW5hbHR5ID0gLTI7XG5jb25zdCBpc1NwbGF0ID0gcyA9PiBzID09PSBcIipcIjtcbmZ1bmN0aW9uIGNvbXB1dGVTY29yZShwYXRoLCBpbmRleCkge1xuICBsZXQgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgbGV0IGluaXRpYWxTY29yZSA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgaWYgKHNlZ21lbnRzLnNvbWUoaXNTcGxhdCkpIHtcbiAgICBpbml0aWFsU2NvcmUgKz0gc3BsYXRQZW5hbHR5O1xuICB9XG4gIGlmIChpbmRleCkge1xuICAgIGluaXRpYWxTY29yZSArPSBpbmRleFJvdXRlVmFsdWU7XG4gIH1cbiAgcmV0dXJuIHNlZ21lbnRzLmZpbHRlcihzID0+ICFpc1NwbGF0KHMpKS5yZWR1Y2UoKHNjb3JlLCBzZWdtZW50KSA9PiBzY29yZSArIChwYXJhbVJlLnRlc3Qoc2VnbWVudCkgPyBkeW5hbWljU2VnbWVudFZhbHVlIDogc2VnbWVudCA9PT0gXCJcIiA/IGVtcHR5U2VnbWVudFZhbHVlIDogc3RhdGljU2VnbWVudFZhbHVlKSwgaW5pdGlhbFNjb3JlKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVJbmRleGVzKGEsIGIpIHtcbiAgbGV0IHNpYmxpbmdzID0gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuc2xpY2UoMCwgLTEpLmV2ZXJ5KChuLCBpKSA9PiBuID09PSBiW2ldKTtcbiAgcmV0dXJuIHNpYmxpbmdzID9cbiAgLy8gSWYgdHdvIHJvdXRlcyBhcmUgc2libGluZ3MsIHdlIHNob3VsZCB0cnkgdG8gbWF0Y2ggdGhlIGVhcmxpZXIgc2libGluZ1xuICAvLyBmaXJzdC4gVGhpcyBhbGxvd3MgcGVvcGxlIHRvIGhhdmUgZmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlciB0aGUgbWF0Y2hpbmdcbiAgLy8gYmVoYXZpb3IgYnkgc2ltcGx5IHB1dHRpbmcgcm91dGVzIHdpdGggaWRlbnRpY2FsIHBhdGhzIGluIHRoZSBvcmRlciB0aGV5XG4gIC8vIHdhbnQgdGhlbSB0cmllZC5cbiAgYVthLmxlbmd0aCAtIDFdIC0gYltiLmxlbmd0aCAtIDFdIDpcbiAgLy8gT3RoZXJ3aXNlLCBpdCBkb2Vzbid0IHJlYWxseSBtYWtlIHNlbnNlIHRvIHJhbmsgbm9uLXNpYmxpbmdzIGJ5IGluZGV4LFxuICAvLyBzbyB0aGV5IHNvcnQgZXF1YWxseS5cbiAgMDtcbn1cbmZ1bmN0aW9uIG1hdGNoUm91dGVCcmFuY2goYnJhbmNoLCBwYXRobmFtZSkge1xuICBsZXQge1xuICAgIHJvdXRlc01ldGFcbiAgfSA9IGJyYW5jaDtcbiAgbGV0IG1hdGNoZWRQYXJhbXMgPSB7fTtcbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IFwiL1wiO1xuICBsZXQgbWF0Y2hlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlc01ldGEubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgbWV0YSA9IHJvdXRlc01ldGFbaV07XG4gICAgbGV0IGVuZCA9IGkgPT09IHJvdXRlc01ldGEubGVuZ3RoIC0gMTtcbiAgICBsZXQgcmVtYWluaW5nUGF0aG5hbWUgPSBtYXRjaGVkUGF0aG5hbWUgPT09IFwiL1wiID8gcGF0aG5hbWUgOiBwYXRobmFtZS5zbGljZShtYXRjaGVkUGF0aG5hbWUubGVuZ3RoKSB8fCBcIi9cIjtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaFBhdGgoe1xuICAgICAgcGF0aDogbWV0YS5yZWxhdGl2ZVBhdGgsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiBtZXRhLmNhc2VTZW5zaXRpdmUsXG4gICAgICBlbmRcbiAgICB9LCByZW1haW5pbmdQYXRobmFtZSk7XG4gICAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG4gICAgT2JqZWN0LmFzc2lnbihtYXRjaGVkUGFyYW1zLCBtYXRjaC5wYXJhbXMpO1xuICAgIGxldCByb3V0ZSA9IG1ldGEucm91dGU7XG4gICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgIC8vIFRPRE86IENhbiB0aGlzIGFzIGJlIGF2b2lkZWQ/XG4gICAgICBwYXJhbXM6IG1hdGNoZWRQYXJhbXMsXG4gICAgICBwYXRobmFtZTogam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lXSksXG4gICAgICBwYXRobmFtZUJhc2U6IG5vcm1hbGl6ZVBhdGhuYW1lKGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKSksXG4gICAgICByb3V0ZVxuICAgIH0pO1xuICAgIGlmIChtYXRjaC5wYXRobmFtZUJhc2UgIT09IFwiL1wiKSB7XG4gICAgICBtYXRjaGVkUGF0aG5hbWUgPSBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVCYXNlXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgcGF0aCB3aXRoIHBhcmFtcyBpbnRlcnBvbGF0ZWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9nZW5lcmF0ZS1wYXRoXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlUGF0aChvcmlnaW5hbFBhdGgsIHBhcmFtcykge1xuICBpZiAocGFyYW1zID09PSB2b2lkIDApIHtcbiAgICBwYXJhbXMgPSB7fTtcbiAgfVxuICBsZXQgcGF0aCA9IG9yaWdpbmFsUGF0aDtcbiAgaWYgKHBhdGguZW5kc1dpdGgoXCIqXCIpICYmIHBhdGggIT09IFwiKlwiICYmICFwYXRoLmVuZHNXaXRoKFwiLypcIikpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCBcIlJvdXRlIHBhdGggXFxcIlwiICsgcGF0aCArIFwiXFxcIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBcIiArIChcIlxcXCJcIiArIHBhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIikgKyBcIlxcXCIgYmVjYXVzZSB0aGUgYCpgIGNoYXJhY3RlciBtdXN0IFwiKSArIFwiYWx3YXlzIGZvbGxvdyBhIGAvYCBpbiB0aGUgcGF0dGVybi4gVG8gZ2V0IHJpZCBvZiB0aGlzIHdhcm5pbmcsIFwiICsgKFwicGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcXFwiXCIgKyBwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpICsgXCJcXFwiLlwiKSk7XG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIik7XG4gIH1cbiAgLy8gZW5zdXJlIGAvYCBpcyBhZGRlZCBhdCB0aGUgYmVnaW5uaW5nIGlmIHRoZSBwYXRoIGlzIGFic29sdXRlXG4gIGNvbnN0IHByZWZpeCA9IHBhdGguc3RhcnRzV2l0aChcIi9cIikgPyBcIi9cIiA6IFwiXCI7XG4gIGNvbnN0IHN0cmluZ2lmeSA9IHAgPT4gcCA9PSBudWxsID8gXCJcIiA6IHR5cGVvZiBwID09PSBcInN0cmluZ1wiID8gcCA6IFN0cmluZyhwKTtcbiAgY29uc3Qgc2VnbWVudHMgPSBwYXRoLnNwbGl0KC9cXC8rLykubWFwKChzZWdtZW50LCBpbmRleCwgYXJyYXkpID0+IHtcbiAgICBjb25zdCBpc0xhc3RTZWdtZW50ID0gaW5kZXggPT09IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgLy8gb25seSBhcHBseSB0aGUgc3BsYXQgaWYgaXQncyB0aGUgbGFzdCBzZWdtZW50XG4gICAgaWYgKGlzTGFzdFNlZ21lbnQgJiYgc2VnbWVudCA9PT0gXCIqXCIpIHtcbiAgICAgIGNvbnN0IHN0YXIgPSBcIipcIjtcbiAgICAgIC8vIEFwcGx5IHRoZSBzcGxhdFxuICAgICAgcmV0dXJuIHN0cmluZ2lmeShwYXJhbXNbc3Rhcl0pO1xuICAgIH1cbiAgICBjb25zdCBrZXlNYXRjaCA9IHNlZ21lbnQubWF0Y2goL146KFtcXHctXSspKFxcPz8pJC8pO1xuICAgIGlmIChrZXlNYXRjaCkge1xuICAgICAgY29uc3QgWywga2V5LCBvcHRpb25hbF0gPSBrZXlNYXRjaDtcbiAgICAgIGxldCBwYXJhbSA9IHBhcmFtc1trZXldO1xuICAgICAgaW52YXJpYW50KG9wdGlvbmFsID09PSBcIj9cIiB8fCBwYXJhbSAhPSBudWxsLCBcIk1pc3NpbmcgXFxcIjpcIiArIGtleSArIFwiXFxcIiBwYXJhbVwiKTtcbiAgICAgIHJldHVybiBzdHJpbmdpZnkocGFyYW0pO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgYW55IG9wdGlvbmFsIG1hcmtlcnMgZnJvbSBvcHRpb25hbCBzdGF0aWMgc2VnbWVudHNcbiAgICByZXR1cm4gc2VnbWVudC5yZXBsYWNlKC9cXD8kL2csIFwiXCIpO1xuICB9KVxuICAvLyBSZW1vdmUgZW1wdHkgc2VnbWVudHNcbiAgLmZpbHRlcihzZWdtZW50ID0+ICEhc2VnbWVudCk7XG4gIHJldHVybiBwcmVmaXggKyBzZWdtZW50cy5qb2luKFwiL1wiKTtcbn1cbi8qKlxuICogUGVyZm9ybXMgcGF0dGVybiBtYXRjaGluZyBvbiBhIFVSTCBwYXRobmFtZSBhbmQgcmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dFxuICogdGhlIG1hdGNoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvbWF0Y2gtcGF0aFxuICovXG5mdW5jdGlvbiBtYXRjaFBhdGgocGF0dGVybiwgcGF0aG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgcGF0dGVybiA9IHtcbiAgICAgIHBhdGg6IHBhdHRlcm4sXG4gICAgICBjYXNlU2Vuc2l0aXZlOiBmYWxzZSxcbiAgICAgIGVuZDogdHJ1ZVxuICAgIH07XG4gIH1cbiAgbGV0IFttYXRjaGVyLCBjb21waWxlZFBhcmFtc10gPSBjb21waWxlUGF0aChwYXR0ZXJuLnBhdGgsIHBhdHRlcm4uY2FzZVNlbnNpdGl2ZSwgcGF0dGVybi5lbmQpO1xuICBsZXQgbWF0Y2ggPSBwYXRobmFtZS5tYXRjaChtYXRjaGVyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG4gIGxldCBtYXRjaGVkUGF0aG5hbWUgPSBtYXRjaFswXTtcbiAgbGV0IHBhdGhuYW1lQmFzZSA9IG1hdGNoZWRQYXRobmFtZS5yZXBsYWNlKC8oLilcXC8rJC8sIFwiJDFcIik7XG4gIGxldCBjYXB0dXJlR3JvdXBzID0gbWF0Y2guc2xpY2UoMSk7XG4gIGxldCBwYXJhbXMgPSBjb21waWxlZFBhcmFtcy5yZWR1Y2UoKG1lbW8sIF9yZWYsIGluZGV4KSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhcmFtTmFtZSxcbiAgICAgIGlzT3B0aW9uYWxcbiAgICB9ID0gX3JlZjtcbiAgICAvLyBXZSBuZWVkIHRvIGNvbXB1dGUgdGhlIHBhdGhuYW1lQmFzZSBoZXJlIHVzaW5nIHRoZSByYXcgc3BsYXQgdmFsdWVcbiAgICAvLyBpbnN0ZWFkIG9mIHVzaW5nIHBhcmFtc1tcIipcIl0gbGF0ZXIgYmVjYXVzZSBpdCB3aWxsIGJlIGRlY29kZWQgdGhlblxuICAgIGlmIChwYXJhbU5hbWUgPT09IFwiKlwiKSB7XG4gICAgICBsZXQgc3BsYXRWYWx1ZSA9IGNhcHR1cmVHcm91cHNbaW5kZXhdIHx8IFwiXCI7XG4gICAgICBwYXRobmFtZUJhc2UgPSBtYXRjaGVkUGF0aG5hbWUuc2xpY2UoMCwgbWF0Y2hlZFBhdGhuYW1lLmxlbmd0aCAtIHNwbGF0VmFsdWUubGVuZ3RoKS5yZXBsYWNlKC8oLilcXC8rJC8sIFwiJDFcIik7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gY2FwdHVyZUdyb3Vwc1tpbmRleF07XG4gICAgaWYgKGlzT3B0aW9uYWwgJiYgIXZhbHVlKSB7XG4gICAgICBtZW1vW3BhcmFtTmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lbW9bcGFyYW1OYW1lXSA9ICh2YWx1ZSB8fCBcIlwiKS5yZXBsYWNlKC8lMkYvZywgXCIvXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbWVtbztcbiAgfSwge30pO1xuICByZXR1cm4ge1xuICAgIHBhcmFtcyxcbiAgICBwYXRobmFtZTogbWF0Y2hlZFBhdGhuYW1lLFxuICAgIHBhdGhuYW1lQmFzZSxcbiAgICBwYXR0ZXJuXG4gIH07XG59XG5mdW5jdGlvbiBjb21waWxlUGF0aChwYXRoLCBjYXNlU2Vuc2l0aXZlLCBlbmQpIHtcbiAgaWYgKGNhc2VTZW5zaXRpdmUgPT09IHZvaWQgMCkge1xuICAgIGNhc2VTZW5zaXRpdmUgPSBmYWxzZTtcbiAgfVxuICBpZiAoZW5kID09PSB2b2lkIDApIHtcbiAgICBlbmQgPSB0cnVlO1xuICB9XG4gIHdhcm5pbmcocGF0aCA9PT0gXCIqXCIgfHwgIXBhdGguZW5kc1dpdGgoXCIqXCIpIHx8IHBhdGguZW5kc1dpdGgoXCIvKlwiKSwgXCJSb3V0ZSBwYXRoIFxcXCJcIiArIHBhdGggKyBcIlxcXCIgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIGl0IHdlcmUgXCIgKyAoXCJcXFwiXCIgKyBwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpICsgXCJcXFwiIGJlY2F1c2UgdGhlIGAqYCBjaGFyYWN0ZXIgbXVzdCBcIikgKyBcImFsd2F5cyBmb2xsb3cgYSBgL2AgaW4gdGhlIHBhdHRlcm4uIFRvIGdldCByaWQgb2YgdGhpcyB3YXJuaW5nLCBcIiArIChcInBsZWFzZSBjaGFuZ2UgdGhlIHJvdXRlIHBhdGggdG8gXFxcIlwiICsgcGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKSArIFwiXFxcIi5cIikpO1xuICBsZXQgcGFyYW1zID0gW107XG4gIGxldCByZWdleHBTb3VyY2UgPSBcIl5cIiArIHBhdGgucmVwbGFjZSgvXFwvKlxcKj8kLywgXCJcIikgLy8gSWdub3JlIHRyYWlsaW5nIC8gYW5kIC8qLCB3ZSdsbCBoYW5kbGUgaXQgYmVsb3dcbiAgLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpIC8vIE1ha2Ugc3VyZSBpdCBoYXMgYSBsZWFkaW5nIC9cbiAgLnJlcGxhY2UoL1tcXFxcLiorXiR7fXwoKVtcXF1dL2csIFwiXFxcXCQmXCIpIC8vIEVzY2FwZSBzcGVjaWFsIHJlZ2V4IGNoYXJzXG4gIC5yZXBsYWNlKC9cXC86KFtcXHctXSspKFxcPyk/L2csIChfLCBwYXJhbU5hbWUsIGlzT3B0aW9uYWwpID0+IHtcbiAgICBwYXJhbXMucHVzaCh7XG4gICAgICBwYXJhbU5hbWUsXG4gICAgICBpc09wdGlvbmFsOiBpc09wdGlvbmFsICE9IG51bGxcbiAgICB9KTtcbiAgICByZXR1cm4gaXNPcHRpb25hbCA/IFwiLz8oW15cXFxcL10rKT9cIiA6IFwiLyhbXlxcXFwvXSspXCI7XG4gIH0pO1xuICBpZiAocGF0aC5lbmRzV2l0aChcIipcIikpIHtcbiAgICBwYXJhbXMucHVzaCh7XG4gICAgICBwYXJhbU5hbWU6IFwiKlwiXG4gICAgfSk7XG4gICAgcmVnZXhwU291cmNlICs9IHBhdGggPT09IFwiKlwiIHx8IHBhdGggPT09IFwiLypcIiA/IFwiKC4qKSRcIiAvLyBBbHJlYWR5IG1hdGNoZWQgdGhlIGluaXRpYWwgLywganVzdCBtYXRjaCB0aGUgcmVzdFxuICAgIDogXCIoPzpcXFxcLyguKyl8XFxcXC8qKSRcIjsgLy8gRG9uJ3QgaW5jbHVkZSB0aGUgLyBpbiBwYXJhbXNbXCIqXCJdXG4gIH0gZWxzZSBpZiAoZW5kKSB7XG4gICAgLy8gV2hlbiBtYXRjaGluZyB0byB0aGUgZW5kLCBpZ25vcmUgdHJhaWxpbmcgc2xhc2hlc1xuICAgIHJlZ2V4cFNvdXJjZSArPSBcIlxcXFwvKiRcIjtcbiAgfSBlbHNlIGlmIChwYXRoICE9PSBcIlwiICYmIHBhdGggIT09IFwiL1wiKSB7XG4gICAgLy8gSWYgb3VyIHBhdGggaXMgbm9uLWVtcHR5IGFuZCBjb250YWlucyBhbnl0aGluZyBiZXlvbmQgYW4gaW5pdGlhbCBzbGFzaCxcbiAgICAvLyB0aGVuIHdlIGhhdmUgX3NvbWVfIGZvcm0gb2YgcGF0aCBpbiBvdXIgcmVnZXgsIHNvIHdlIHNob3VsZCBleHBlY3QgdG9cbiAgICAvLyBtYXRjaCBvbmx5IGlmIHdlIGZpbmQgdGhlIGVuZCBvZiB0aGlzIHBhdGggc2VnbWVudC4gIExvb2sgZm9yIGFuIG9wdGlvbmFsXG4gICAgLy8gbm9uLWNhcHR1cmVkIHRyYWlsaW5nIHNsYXNoICh0byBtYXRjaCBhIHBvcnRpb24gb2YgdGhlIFVSTCkgb3IgdGhlIGVuZFxuICAgIC8vIG9mIHRoZSBwYXRoIChpZiB3ZSd2ZSBtYXRjaGVkIHRvIHRoZSBlbmQpLiAgV2UgdXNlZCB0byBkbyB0aGlzIHdpdGggYVxuICAgIC8vIHdvcmQgYm91bmRhcnkgYnV0IHRoYXQgZ2l2ZXMgZmFsc2UgcG9zaXRpdmVzIG9uIHJvdXRlcyBsaWtlXG4gICAgLy8gL3VzZXItcHJlZmVyZW5jZXMgc2luY2UgYC1gIGNvdW50cyBhcyBhIHdvcmQgYm91bmRhcnkuXG4gICAgcmVnZXhwU291cmNlICs9IFwiKD86KD89XFxcXC98JCkpXCI7XG4gIH0gZWxzZSA7XG4gIGxldCBtYXRjaGVyID0gbmV3IFJlZ0V4cChyZWdleHBTb3VyY2UsIGNhc2VTZW5zaXRpdmUgPyB1bmRlZmluZWQgOiBcImlcIik7XG4gIHJldHVybiBbbWF0Y2hlciwgcGFyYW1zXTtcbn1cbmZ1bmN0aW9uIGRlY29kZVBhdGgodmFsdWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoXCIvXCIpLm1hcCh2ID0+IGRlY29kZVVSSUNvbXBvbmVudCh2KS5yZXBsYWNlKC9cXC8vZywgXCIlMkZcIikpLmpvaW4oXCIvXCIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHdhcm5pbmcoZmFsc2UsIFwiVGhlIFVSTCBwYXRoIFxcXCJcIiArIHZhbHVlICsgXCJcXFwiIGNvdWxkIG5vdCBiZSBkZWNvZGVkIGJlY2F1c2UgaXQgaXMgaXMgYSBcIiArIFwibWFsZm9ybWVkIFVSTCBzZWdtZW50LiBUaGlzIGlzIHByb2JhYmx5IGR1ZSB0byBhIGJhZCBwZXJjZW50IFwiICsgKFwiZW5jb2RpbmcgKFwiICsgZXJyb3IgKyBcIikuXCIpKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShwYXRobmFtZSwgYmFzZW5hbWUpIHtcbiAgaWYgKGJhc2VuYW1lID09PSBcIi9cIikgcmV0dXJuIHBhdGhuYW1lO1xuICBpZiAoIXBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChiYXNlbmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIFdlIHdhbnQgdG8gbGVhdmUgdHJhaWxpbmcgc2xhc2ggYmVoYXZpb3IgaW4gdGhlIHVzZXIncyBjb250cm9sLCBzbyBpZiB0aGV5XG4gIC8vIHNwZWNpZnkgYSBiYXNlbmFtZSB3aXRoIGEgdHJhaWxpbmcgc2xhc2gsIHdlIHNob3VsZCBzdXBwb3J0IGl0XG4gIGxldCBzdGFydEluZGV4ID0gYmFzZW5hbWUuZW5kc1dpdGgoXCIvXCIpID8gYmFzZW5hbWUubGVuZ3RoIC0gMSA6IGJhc2VuYW1lLmxlbmd0aDtcbiAgbGV0IG5leHRDaGFyID0gcGF0aG5hbWUuY2hhckF0KHN0YXJ0SW5kZXgpO1xuICBpZiAobmV4dENoYXIgJiYgbmV4dENoYXIgIT09IFwiL1wiKSB7XG4gICAgLy8gcGF0aG5hbWUgZG9lcyBub3Qgc3RhcnQgd2l0aCBiYXNlbmFtZS9cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gcGF0aG5hbWUuc2xpY2Uoc3RhcnRJbmRleCkgfHwgXCIvXCI7XG59XG4vKipcbiAqIFJldHVybnMgYSByZXNvbHZlZCBwYXRoIG9iamVjdCByZWxhdGl2ZSB0byB0aGUgZ2l2ZW4gcGF0aG5hbWUuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9yZXNvbHZlLXBhdGhcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVBhdGgodG8sIGZyb21QYXRobmFtZSkge1xuICBpZiAoZnJvbVBhdGhuYW1lID09PSB2b2lkIDApIHtcbiAgICBmcm9tUGF0aG5hbWUgPSBcIi9cIjtcbiAgfVxuICBsZXQge1xuICAgIHBhdGhuYW1lOiB0b1BhdGhuYW1lLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCJcbiAgfSA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0bztcbiAgbGV0IHBhdGhuYW1lID0gdG9QYXRobmFtZSA/IHRvUGF0aG5hbWUuc3RhcnRzV2l0aChcIi9cIikgPyB0b1BhdGhuYW1lIDogcmVzb2x2ZVBhdGhuYW1lKHRvUGF0aG5hbWUsIGZyb21QYXRobmFtZSkgOiBmcm9tUGF0aG5hbWU7XG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBub3JtYWxpemVTZWFyY2goc2VhcmNoKSxcbiAgICBoYXNoOiBub3JtYWxpemVIYXNoKGhhc2gpXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlUGF0aG5hbWUocmVsYXRpdmVQYXRoLCBmcm9tUGF0aG5hbWUpIHtcbiAgbGV0IHNlZ21lbnRzID0gZnJvbVBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgXCJcIikuc3BsaXQoXCIvXCIpO1xuICBsZXQgcmVsYXRpdmVTZWdtZW50cyA9IHJlbGF0aXZlUGF0aC5zcGxpdChcIi9cIik7XG4gIHJlbGF0aXZlU2VnbWVudHMuZm9yRWFjaChzZWdtZW50ID0+IHtcbiAgICBpZiAoc2VnbWVudCA9PT0gXCIuLlwiKSB7XG4gICAgICAvLyBLZWVwIHRoZSByb290IFwiXCIgc2VnbWVudCBzbyB0aGUgcGF0aG5hbWUgc3RhcnRzIGF0IC9cbiAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAxKSBzZWdtZW50cy5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKHNlZ21lbnQgIT09IFwiLlwiKSB7XG4gICAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzZWdtZW50cy5sZW5ndGggPiAxID8gc2VnbWVudHMuam9pbihcIi9cIikgOiBcIi9cIjtcbn1cbmZ1bmN0aW9uIGdldEludmFsaWRQYXRoRXJyb3IoY2hhciwgZmllbGQsIGRlc3QsIHBhdGgpIHtcbiAgcmV0dXJuIFwiQ2Fubm90IGluY2x1ZGUgYSAnXCIgKyBjaGFyICsgXCInIGNoYXJhY3RlciBpbiBhIG1hbnVhbGx5IHNwZWNpZmllZCBcIiArIChcImB0by5cIiArIGZpZWxkICsgXCJgIGZpZWxkIFtcIiArIEpTT04uc3RyaW5naWZ5KHBhdGgpICsgXCJdLiAgUGxlYXNlIHNlcGFyYXRlIGl0IG91dCB0byB0aGUgXCIpICsgKFwiYHRvLlwiICsgZGVzdCArIFwiYCBmaWVsZC4gQWx0ZXJuYXRpdmVseSB5b3UgbWF5IHByb3ZpZGUgdGhlIGZ1bGwgcGF0aCBhcyBcIikgKyBcImEgc3RyaW5nIGluIDxMaW5rIHRvPVxcXCIuLi5cXFwiPiBhbmQgdGhlIHJvdXRlciB3aWxsIHBhcnNlIGl0IGZvciB5b3UuXCI7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogV2hlbiBwcm9jZXNzaW5nIHJlbGF0aXZlIG5hdmlnYXRpb24gd2Ugd2FudCB0byBpZ25vcmUgYW5jZXN0b3Igcm91dGVzIHRoYXRcbiAqIGRvIG5vdCBjb250cmlidXRlIHRvIHRoZSBwYXRoLCBzdWNoIHRoYXQgaW5kZXgvcGF0aGxlc3MgbGF5b3V0IHJvdXRlcyBkb24ndFxuICogaW50ZXJmZXJlLlxuICpcbiAqIEZvciBleGFtcGxlLCB3aGVuIG1vdmluZyBhIHJvdXRlIGVsZW1lbnQgaW50byBhbiBpbmRleCByb3V0ZSBhbmQvb3IgYVxuICogcGF0aGxlc3MgbGF5b3V0IHJvdXRlLCByZWxhdGl2ZSBsaW5rIGJlaGF2aW9yIGNvbnRhaW5lZCB3aXRoaW4gc2hvdWxkIHN0YXlcbiAqIHRoZSBzYW1lLiAgQm90aCBvZiB0aGUgZm9sbG93aW5nIGV4YW1wbGVzIHNob3VsZCBsaW5rIGJhY2sgdG8gdGhlIHJvb3Q6XG4gKlxuICogICA8Um91dGUgcGF0aD1cIi9cIj5cbiAqICAgICA8Um91dGUgcGF0aD1cImFjY291bnRzXCIgZWxlbWVudD17PExpbmsgdG89XCIuLlwifT5cbiAqICAgPC9Sb3V0ZT5cbiAqXG4gKiAgIDxSb3V0ZSBwYXRoPVwiL1wiPlxuICogICAgIDxSb3V0ZSBwYXRoPVwiYWNjb3VudHNcIj5cbiAqICAgICAgIDxSb3V0ZSBlbGVtZW50PXs8QWNjb3VudHNMYXlvdXQgLz59PiAgICAgICAvLyA8LS0gRG9lcyBub3QgY29udHJpYnV0ZVxuICogICAgICAgICA8Um91dGUgaW5kZXggZWxlbWVudD17PExpbmsgdG89XCIuLlwifSAvPiAgLy8gPC0tIERvZXMgbm90IGNvbnRyaWJ1dGVcbiAqICAgICAgIDwvUm91dGVcbiAqICAgICA8L1JvdXRlPlxuICogICA8L1JvdXRlPlxuICovXG5mdW5jdGlvbiBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKSB7XG4gIHJldHVybiBtYXRjaGVzLmZpbHRlcigobWF0Y2gsIGluZGV4KSA9PiBpbmRleCA9PT0gMCB8fCBtYXRjaC5yb3V0ZS5wYXRoICYmIG1hdGNoLnJvdXRlLnBhdGgubGVuZ3RoID4gMCk7XG59XG4vLyBSZXR1cm4gdGhlIGFycmF5IG9mIHBhdGhuYW1lcyBmb3IgdGhlIGN1cnJlbnQgcm91dGUgbWF0Y2hlcyAtIHVzZWQgdG9cbi8vIGdlbmVyYXRlIHRoZSByb3V0ZVBhdGhuYW1lcyBpbnB1dCBmb3IgcmVzb2x2ZVRvKClcbmZ1bmN0aW9uIGdldFJlc29sdmVUb01hdGNoZXMobWF0Y2hlcywgdjdfcmVsYXRpdmVTcGxhdFBhdGgpIHtcbiAgbGV0IHBhdGhNYXRjaGVzID0gZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMobWF0Y2hlcyk7XG4gIC8vIFdoZW4gdjdfcmVsYXRpdmVTcGxhdFBhdGggaXMgZW5hYmxlZCwgdXNlIHRoZSBmdWxsIHBhdGhuYW1lIGZvciB0aGUgbGVhZlxuICAvLyBtYXRjaCBzbyB3ZSBpbmNsdWRlIHNwbGF0IHZhbHVlcyBmb3IgXCIuXCIgbGlua3MuICBTZWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVhY3Qtcm91dGVyL2lzc3Vlcy8xMTA1MiNpc3N1ZWNvbW1lbnQtMTgzNjU4OTMyOVxuICBpZiAodjdfcmVsYXRpdmVTcGxhdFBhdGgpIHtcbiAgICByZXR1cm4gcGF0aE1hdGNoZXMubWFwKChtYXRjaCwgaWR4KSA9PiBpZHggPT09IG1hdGNoZXMubGVuZ3RoIC0gMSA/IG1hdGNoLnBhdGhuYW1lIDogbWF0Y2gucGF0aG5hbWVCYXNlKTtcbiAgfVxuICByZXR1cm4gcGF0aE1hdGNoZXMubWFwKG1hdGNoID0+IG1hdGNoLnBhdGhuYW1lQmFzZSk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVUbyh0b0FyZywgcm91dGVQYXRobmFtZXMsIGxvY2F0aW9uUGF0aG5hbWUsIGlzUGF0aFJlbGF0aXZlKSB7XG4gIGlmIChpc1BhdGhSZWxhdGl2ZSA9PT0gdm9pZCAwKSB7XG4gICAgaXNQYXRoUmVsYXRpdmUgPSBmYWxzZTtcbiAgfVxuICBsZXQgdG87XG4gIGlmICh0eXBlb2YgdG9BcmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0byA9IHBhcnNlUGF0aCh0b0FyZyk7XG4gIH0gZWxzZSB7XG4gICAgdG8gPSBfZXh0ZW5kcyh7fSwgdG9BcmcpO1xuICAgIGludmFyaWFudCghdG8ucGF0aG5hbWUgfHwgIXRvLnBhdGhuYW1lLmluY2x1ZGVzKFwiP1wiKSwgZ2V0SW52YWxpZFBhdGhFcnJvcihcIj9cIiwgXCJwYXRobmFtZVwiLCBcInNlYXJjaFwiLCB0bykpO1xuICAgIGludmFyaWFudCghdG8ucGF0aG5hbWUgfHwgIXRvLnBhdGhuYW1lLmluY2x1ZGVzKFwiI1wiKSwgZ2V0SW52YWxpZFBhdGhFcnJvcihcIiNcIiwgXCJwYXRobmFtZVwiLCBcImhhc2hcIiwgdG8pKTtcbiAgICBpbnZhcmlhbnQoIXRvLnNlYXJjaCB8fCAhdG8uc2VhcmNoLmluY2x1ZGVzKFwiI1wiKSwgZ2V0SW52YWxpZFBhdGhFcnJvcihcIiNcIiwgXCJzZWFyY2hcIiwgXCJoYXNoXCIsIHRvKSk7XG4gIH1cbiAgbGV0IGlzRW1wdHlQYXRoID0gdG9BcmcgPT09IFwiXCIgfHwgdG8ucGF0aG5hbWUgPT09IFwiXCI7XG4gIGxldCB0b1BhdGhuYW1lID0gaXNFbXB0eVBhdGggPyBcIi9cIiA6IHRvLnBhdGhuYW1lO1xuICBsZXQgZnJvbTtcbiAgLy8gUm91dGluZyBpcyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwYXRobmFtZSBpZiBleHBsaWNpdGx5IHJlcXVlc3RlZC5cbiAgLy9cbiAgLy8gSWYgYSBwYXRobmFtZSBpcyBleHBsaWNpdGx5IHByb3ZpZGVkIGluIGB0b2AsIGl0IHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGVcbiAgLy8gcm91dGUgY29udGV4dC4gVGhpcyBpcyBleHBsYWluZWQgaW4gYE5vdGUgb24gYDxMaW5rIHRvPmAgdmFsdWVzYCBpbiBvdXJcbiAgLy8gbWlncmF0aW9uIGd1aWRlIGZyb20gdjUgYXMgYSBtZWFucyBvZiBkaXNhbWJpZ3VhdGlvbiBiZXR3ZWVuIGB0b2AgdmFsdWVzXG4gIC8vIHRoYXQgYmVnaW4gd2l0aCBgL2AgYW5kIHRob3NlIHRoYXQgZG8gbm90LiBIb3dldmVyLCB0aGlzIGlzIHByb2JsZW1hdGljIGZvclxuICAvLyBgdG9gIHZhbHVlcyB0aGF0IGRvIG5vdCBwcm92aWRlIGEgcGF0aG5hbWUuIGB0b2AgY2FuIHNpbXBseSBiZSBhIHNlYXJjaCBvclxuICAvLyBoYXNoIHN0cmluZywgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGQgYXNzdW1lIHRoYXQgdGhlIG5hdmlnYXRpb24gaXMgcmVsYXRpdmVcbiAgLy8gdG8gdGhlIGN1cnJlbnQgbG9jYXRpb24ncyBwYXRobmFtZSBhbmQgKm5vdCogdGhlIHJvdXRlIHBhdGhuYW1lLlxuICBpZiAodG9QYXRobmFtZSA9PSBudWxsKSB7XG4gICAgZnJvbSA9IGxvY2F0aW9uUGF0aG5hbWU7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHJvdXRlUGF0aG5hbWVJbmRleCA9IHJvdXRlUGF0aG5hbWVzLmxlbmd0aCAtIDE7XG4gICAgLy8gV2l0aCByZWxhdGl2ZT1cInJvdXRlXCIgKHRoZSBkZWZhdWx0KSwgZWFjaCBsZWFkaW5nIC4uIHNlZ21lbnQgbWVhbnNcbiAgICAvLyBcImdvIHVwIG9uZSByb3V0ZVwiIGluc3RlYWQgb2YgXCJnbyB1cCBvbmUgVVJMIHNlZ21lbnRcIi4gIFRoaXMgaXMgYSBrZXlcbiAgICAvLyBkaWZmZXJlbmNlIGZyb20gaG93IDxhIGhyZWY+IHdvcmtzIGFuZCBhIG1ham9yIHJlYXNvbiB3ZSBjYWxsIHRoaXMgYVxuICAgIC8vIFwidG9cIiB2YWx1ZSBpbnN0ZWFkIG9mIGEgXCJocmVmXCIuXG4gICAgaWYgKCFpc1BhdGhSZWxhdGl2ZSAmJiB0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuLlwiKSkge1xuICAgICAgbGV0IHRvU2VnbWVudHMgPSB0b1BhdGhuYW1lLnNwbGl0KFwiL1wiKTtcbiAgICAgIHdoaWxlICh0b1NlZ21lbnRzWzBdID09PSBcIi4uXCIpIHtcbiAgICAgICAgdG9TZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICByb3V0ZVBhdGhuYW1lSW5kZXggLT0gMTtcbiAgICAgIH1cbiAgICAgIHRvLnBhdGhuYW1lID0gdG9TZWdtZW50cy5qb2luKFwiL1wiKTtcbiAgICB9XG4gICAgZnJvbSA9IHJvdXRlUGF0aG5hbWVJbmRleCA+PSAwID8gcm91dGVQYXRobmFtZXNbcm91dGVQYXRobmFtZUluZGV4XSA6IFwiL1wiO1xuICB9XG4gIGxldCBwYXRoID0gcmVzb2x2ZVBhdGgodG8sIGZyb20pO1xuICAvLyBFbnN1cmUgdGhlIHBhdGhuYW1lIGhhcyBhIHRyYWlsaW5nIHNsYXNoIGlmIHRoZSBvcmlnaW5hbCBcInRvXCIgaGFkIG9uZVxuICBsZXQgaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoID0gdG9QYXRobmFtZSAmJiB0b1BhdGhuYW1lICE9PSBcIi9cIiAmJiB0b1BhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKTtcbiAgLy8gT3IgaWYgdGhpcyB3YXMgYSBsaW5rIHRvIHRoZSBjdXJyZW50IHBhdGggd2hpY2ggaGFzIGEgdHJhaWxpbmcgc2xhc2hcbiAgbGV0IGhhc0N1cnJlbnRUcmFpbGluZ1NsYXNoID0gKGlzRW1wdHlQYXRoIHx8IHRvUGF0aG5hbWUgPT09IFwiLlwiKSAmJiBsb2NhdGlvblBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKTtcbiAgaWYgKCFwYXRoLnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSAmJiAoaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoIHx8IGhhc0N1cnJlbnRUcmFpbGluZ1NsYXNoKSkge1xuICAgIHBhdGgucGF0aG5hbWUgKz0gXCIvXCI7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFRvUGF0aG5hbWUodG8pIHtcbiAgLy8gRW1wdHkgc3RyaW5ncyBzaG91bGQgYmUgdHJlYXRlZCB0aGUgc2FtZSBhcyAvIHBhdGhzXG4gIHJldHVybiB0byA9PT0gXCJcIiB8fCB0by5wYXRobmFtZSA9PT0gXCJcIiA/IFwiL1wiIDogdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKS5wYXRobmFtZSA6IHRvLnBhdGhuYW1lO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBqb2luUGF0aHMgPSBwYXRocyA9PiBwYXRocy5qb2luKFwiL1wiKS5yZXBsYWNlKC9cXC9cXC8rL2csIFwiL1wiKTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgbm9ybWFsaXplUGF0aG5hbWUgPSBwYXRobmFtZSA9PiBwYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBub3JtYWxpemVTZWFyY2ggPSBzZWFyY2ggPT4gIXNlYXJjaCB8fCBzZWFyY2ggPT09IFwiP1wiID8gXCJcIiA6IHNlYXJjaC5zdGFydHNXaXRoKFwiP1wiKSA/IHNlYXJjaCA6IFwiP1wiICsgc2VhcmNoO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBub3JtYWxpemVIYXNoID0gaGFzaCA9PiAhaGFzaCB8fCBoYXNoID09PSBcIiNcIiA/IFwiXCIgOiBoYXNoLnN0YXJ0c1dpdGgoXCIjXCIpID8gaGFzaCA6IFwiI1wiICsgaGFzaDtcbi8qKlxuICogVGhpcyBpcyBhIHNob3J0Y3V0IGZvciBjcmVhdGluZyBgYXBwbGljYXRpb24vanNvbmAgcmVzcG9uc2VzLiBDb252ZXJ0cyBgZGF0YWBcbiAqIHRvIEpTT04gYW5kIHNldHMgdGhlIGBDb250ZW50LVR5cGVgIGhlYWRlci5cbiAqL1xuY29uc3QganNvbiA9IGZ1bmN0aW9uIGpzb24oZGF0YSwgaW5pdCkge1xuICBpZiAoaW5pdCA9PT0gdm9pZCAwKSB7XG4gICAgaW5pdCA9IHt9O1xuICB9XG4gIGxldCByZXNwb25zZUluaXQgPSB0eXBlb2YgaW5pdCA9PT0gXCJudW1iZXJcIiA/IHtcbiAgICBzdGF0dXM6IGluaXRcbiAgfSA6IGluaXQ7XG4gIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVzcG9uc2VJbml0LmhlYWRlcnMpO1xuICBpZiAoIWhlYWRlcnMuaGFzKFwiQ29udGVudC1UeXBlXCIpKSB7XG4gICAgaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpO1xuICB9XG4gIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSksIF9leHRlbmRzKHt9LCByZXNwb25zZUluaXQsIHtcbiAgICBoZWFkZXJzXG4gIH0pKTtcbn07XG5jbGFzcyBBYm9ydGVkRGVmZXJyZWRFcnJvciBleHRlbmRzIEVycm9yIHt9XG5jbGFzcyBEZWZlcnJlZERhdGEge1xuICBjb25zdHJ1Y3RvcihkYXRhLCByZXNwb25zZUluaXQpIHtcbiAgICB0aGlzLnBlbmRpbmdLZXlzU2V0ID0gbmV3IFNldCgpO1xuICAgIHRoaXMuc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5kZWZlcnJlZEtleXMgPSBbXTtcbiAgICBpbnZhcmlhbnQoZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShkYXRhKSwgXCJkZWZlcigpIG9ubHkgYWNjZXB0cyBwbGFpbiBvYmplY3RzXCIpO1xuICAgIC8vIFNldCB1cCBhbiBBYm9ydENvbnRyb2xsZXIgKyBQcm9taXNlIHdlIGNhbiByYWNlIGFnYWluc3QgdG8gZXhpdCBlYXJseVxuICAgIC8vIGNhbmNlbGxhdGlvblxuICAgIGxldCByZWplY3Q7XG4gICAgdGhpcy5hYm9ydFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcikgPT4gcmVqZWN0ID0gcik7XG4gICAgdGhpcy5jb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBvbkFib3J0ID0gKCkgPT4gcmVqZWN0KG5ldyBBYm9ydGVkRGVmZXJyZWRFcnJvcihcIkRlZmVycmVkIGRhdGEgYWJvcnRlZFwiKSk7XG4gICAgdGhpcy51bmxpc3RlbkFib3J0U2lnbmFsID0gKCkgPT4gdGhpcy5jb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgdGhpcy5jb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgdGhpcy5kYXRhID0gT2JqZWN0LmVudHJpZXMoZGF0YSkucmVkdWNlKChhY2MsIF9yZWYyKSA9PiB7XG4gICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjI7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY2MsIHtcbiAgICAgICAgW2tleV06IHRoaXMudHJhY2tQcm9taXNlKGtleSwgdmFsdWUpXG4gICAgICB9KTtcbiAgICB9LCB7fSk7XG4gICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgLy8gQWxsIGluY29taW5nIHZhbHVlcyB3ZXJlIHJlc29sdmVkXG4gICAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwoKTtcbiAgICB9XG4gICAgdGhpcy5pbml0ID0gcmVzcG9uc2VJbml0O1xuICB9XG4gIHRyYWNrUHJvbWlzZShrZXksIHZhbHVlKSB7XG4gICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB0aGlzLmRlZmVycmVkS2V5cy5wdXNoKGtleSk7XG4gICAgdGhpcy5wZW5kaW5nS2V5c1NldC5hZGQoa2V5KTtcbiAgICAvLyBXZSBzdG9yZSBhIGxpdHRsZSB3cmFwcGVyIHByb21pc2UgdGhhdCB3aWxsIGJlIGV4dGVuZGVkIHdpdGhcbiAgICAvLyBfZGF0YS9fZXJyb3IgcHJvcHMgdXBvbiByZXNvbHZlL3JlamVjdFxuICAgIGxldCBwcm9taXNlID0gUHJvbWlzZS5yYWNlKFt2YWx1ZSwgdGhpcy5hYm9ydFByb21pc2VdKS50aGVuKGRhdGEgPT4gdGhpcy5vblNldHRsZShwcm9taXNlLCBrZXksIHVuZGVmaW5lZCwgZGF0YSksIGVycm9yID0+IHRoaXMub25TZXR0bGUocHJvbWlzZSwga2V5LCBlcnJvcikpO1xuICAgIC8vIFJlZ2lzdGVyIHJlamVjdGlvbiBsaXN0ZW5lcnMgdG8gYXZvaWQgdW5jYXVnaHQgcHJvbWlzZSByZWplY3Rpb25zIG9uXG4gICAgLy8gZXJyb3JzIG9yIGFib3J0ZWQgZGVmZXJyZWQgdmFsdWVzXG4gICAgcHJvbWlzZS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwge1xuICAgICAgZ2V0OiAoKSA9PiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgb25TZXR0bGUocHJvbWlzZSwga2V5LCBlcnJvciwgZGF0YSkge1xuICAgIGlmICh0aGlzLmNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQgJiYgZXJyb3IgaW5zdGFuY2VvZiBBYm9ydGVkRGVmZXJyZWRFcnJvcikge1xuICAgICAgdGhpcy51bmxpc3RlbkFib3J0U2lnbmFsKCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IGVycm9yXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICAgIHRoaXMucGVuZGluZ0tleXNTZXQuZGVsZXRlKGtleSk7XG4gICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgLy8gTm90aGluZyBsZWZ0IHRvIGFib3J0IVxuICAgICAgdGhpcy51bmxpc3RlbkFib3J0U2lnbmFsKCk7XG4gICAgfVxuICAgIC8vIElmIHRoZSBwcm9taXNlIHdhcyByZXNvbHZlZC9yZWplY3RlZCB3aXRoIHVuZGVmaW5lZCwgd2UnbGwgdGhyb3cgYW4gZXJyb3IgYXMgeW91XG4gICAgLy8gc2hvdWxkIGFsd2F5cyByZXNvbHZlIHdpdGggYSB2YWx1ZSBvciBudWxsXG4gICAgaWYgKGVycm9yID09PSB1bmRlZmluZWQgJiYgZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgdW5kZWZpbmVkRXJyb3IgPSBuZXcgRXJyb3IoXCJEZWZlcnJlZCBkYXRhIGZvciBrZXkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHJlc29sdmVkL3JlamVjdGVkIHdpdGggYHVuZGVmaW5lZGAsIFwiICsgXCJ5b3UgbXVzdCByZXNvbHZlL3JlamVjdCB3aXRoIGEgdmFsdWUgb3IgYG51bGxgLlwiKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gdW5kZWZpbmVkRXJyb3JcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbWl0KGZhbHNlLCBrZXkpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHVuZGVmaW5lZEVycm9yKTtcbiAgICB9XG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2Vycm9yXCIsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiBlcnJvclxuICAgICAgfSk7XG4gICAgICB0aGlzLmVtaXQoZmFsc2UsIGtleSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZGF0YVwiLCB7XG4gICAgICBnZXQ6ICgpID0+IGRhdGFcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoZmFsc2UsIGtleSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgZW1pdChhYm9ydGVkLCBzZXR0bGVkS2V5KSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5mb3JFYWNoKHN1YnNjcmliZXIgPT4gc3Vic2NyaWJlcihhYm9ydGVkLCBzZXR0bGVkS2V5KSk7XG4gIH1cbiAgc3Vic2NyaWJlKGZuKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5hZGQoZm4pO1xuICAgIHJldHVybiAoKSA9PiB0aGlzLnN1YnNjcmliZXJzLmRlbGV0ZShmbik7XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgIHRoaXMucGVuZGluZ0tleXNTZXQuZm9yRWFjaCgodiwgaykgPT4gdGhpcy5wZW5kaW5nS2V5c1NldC5kZWxldGUoaykpO1xuICAgIHRoaXMuZW1pdCh0cnVlKTtcbiAgfVxuICBhc3luYyByZXNvbHZlRGF0YShzaWduYWwpIHtcbiAgICBsZXQgYWJvcnRlZCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5kb25lKSB7XG4gICAgICBsZXQgb25BYm9ydCA9ICgpID0+IHRoaXMuY2FuY2VsKCk7XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgICAgYWJvcnRlZCA9IGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB0aGlzLnN1YnNjcmliZShhYm9ydGVkID0+IHtcbiAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgICAgICAgIGlmIChhYm9ydGVkIHx8IHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShhYm9ydGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhYm9ydGVkO1xuICB9XG4gIGdldCBkb25lKCkge1xuICAgIHJldHVybiB0aGlzLnBlbmRpbmdLZXlzU2V0LnNpemUgPT09IDA7XG4gIH1cbiAgZ2V0IHVud3JhcHBlZERhdGEoKSB7XG4gICAgaW52YXJpYW50KHRoaXMuZGF0YSAhPT0gbnVsbCAmJiB0aGlzLmRvbmUsIFwiQ2FuIG9ubHkgdW53cmFwIGRhdGEgb24gaW5pdGlhbGl6ZWQgYW5kIHNldHRsZWQgZGVmZXJyZWRzXCIpO1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLmRhdGEpLnJlZHVjZSgoYWNjLCBfcmVmMykgPT4ge1xuICAgICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWYzO1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWNjLCB7XG4gICAgICAgIFtrZXldOiB1bndyYXBUcmFja2VkUHJvbWlzZSh2YWx1ZSlcbiAgICAgIH0pO1xuICAgIH0sIHt9KTtcbiAgfVxuICBnZXQgcGVuZGluZ0tleXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wZW5kaW5nS2V5c1NldCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVHJhY2tlZFByb21pc2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSAmJiB2YWx1ZS5fdHJhY2tlZCA9PT0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVud3JhcFRyYWNrZWRQcm9taXNlKHZhbHVlKSB7XG4gIGlmICghaXNUcmFja2VkUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlLl9lcnJvcikge1xuICAgIHRocm93IHZhbHVlLl9lcnJvcjtcbiAgfVxuICByZXR1cm4gdmFsdWUuX2RhdGE7XG59XG5jb25zdCBkZWZlciA9IGZ1bmN0aW9uIGRlZmVyKGRhdGEsIGluaXQpIHtcbiAgaWYgKGluaXQgPT09IHZvaWQgMCkge1xuICAgIGluaXQgPSB7fTtcbiAgfVxuICBsZXQgcmVzcG9uc2VJbml0ID0gdHlwZW9mIGluaXQgPT09IFwibnVtYmVyXCIgPyB7XG4gICAgc3RhdHVzOiBpbml0XG4gIH0gOiBpbml0O1xuICByZXR1cm4gbmV3IERlZmVycmVkRGF0YShkYXRhLCByZXNwb25zZUluaXQpO1xufTtcbi8qKlxuICogQSByZWRpcmVjdCByZXNwb25zZS4gU2V0cyB0aGUgc3RhdHVzIGNvZGUgYW5kIHRoZSBgTG9jYXRpb25gIGhlYWRlci5cbiAqIERlZmF1bHRzIHRvIFwiMzAyIEZvdW5kXCIuXG4gKi9cbmNvbnN0IHJlZGlyZWN0ID0gZnVuY3Rpb24gcmVkaXJlY3QodXJsLCBpbml0KSB7XG4gIGlmIChpbml0ID09PSB2b2lkIDApIHtcbiAgICBpbml0ID0gMzAyO1xuICB9XG4gIGxldCByZXNwb25zZUluaXQgPSBpbml0O1xuICBpZiAodHlwZW9mIHJlc3BvbnNlSW5pdCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJlc3BvbnNlSW5pdCA9IHtcbiAgICAgIHN0YXR1czogcmVzcG9uc2VJbml0XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcG9uc2VJbml0LnN0YXR1cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJlc3BvbnNlSW5pdC5zdGF0dXMgPSAzMDI7XG4gIH1cbiAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZUluaXQuaGVhZGVycyk7XG4gIGhlYWRlcnMuc2V0KFwiTG9jYXRpb25cIiwgdXJsKTtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCBfZXh0ZW5kcyh7fSwgcmVzcG9uc2VJbml0LCB7XG4gICAgaGVhZGVyc1xuICB9KSk7XG59O1xuLyoqXG4gKiBBIHJlZGlyZWN0IHJlc3BvbnNlIHRoYXQgd2lsbCBmb3JjZSBhIGRvY3VtZW50IHJlbG9hZCB0byB0aGUgbmV3IGxvY2F0aW9uLlxuICogU2V0cyB0aGUgc3RhdHVzIGNvZGUgYW5kIHRoZSBgTG9jYXRpb25gIGhlYWRlci5cbiAqIERlZmF1bHRzIHRvIFwiMzAyIEZvdW5kXCIuXG4gKi9cbmNvbnN0IHJlZGlyZWN0RG9jdW1lbnQgPSAodXJsLCBpbml0KSA9PiB7XG4gIGxldCByZXNwb25zZSA9IHJlZGlyZWN0KHVybCwgaW5pdCk7XG4gIHJlc3BvbnNlLmhlYWRlcnMuc2V0KFwiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIiwgXCJ0cnVlXCIpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogVXRpbGl0eSBjbGFzcyB3ZSB1c2UgdG8gaG9sZCBhdXRvLXVud3JhcHBlZCA0eHgvNXh4IFJlc3BvbnNlIGJvZGllc1xuICpcbiAqIFdlIGRvbid0IGV4cG9ydCB0aGUgY2xhc3MgZm9yIHB1YmxpYyB1c2Ugc2luY2UgaXQncyBhbiBpbXBsZW1lbnRhdGlvblxuICogZGV0YWlsLCBidXQgd2UgZXhwb3J0IHRoZSBpbnRlcmZhY2UgYWJvdmUgc28gZm9sa3MgY2FuIGJ1aWxkIHRoZWlyIG93blxuICogYWJzdHJhY3Rpb25zIGFyb3VuZCBpbnN0YW5jZXMgdmlhIGlzUm91dGVFcnJvclJlc3BvbnNlKClcbiAqL1xuY2xhc3MgRXJyb3JSZXNwb25zZUltcGwge1xuICBjb25zdHJ1Y3RvcihzdGF0dXMsIHN0YXR1c1RleHQsIGRhdGEsIGludGVybmFsKSB7XG4gICAgaWYgKGludGVybmFsID09PSB2b2lkIDApIHtcbiAgICAgIGludGVybmFsID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQgfHwgXCJcIjtcbiAgICB0aGlzLmludGVybmFsID0gaW50ZXJuYWw7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YS50b1N0cmluZygpO1xuICAgICAgdGhpcy5lcnJvciA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBlcnJvciBpcyBhbiBFcnJvclJlc3BvbnNlIGdlbmVyYXRlZCBmcm9tIGEgNHh4LzV4eFxuICogUmVzcG9uc2UgdGhyb3duIGZyb20gYW4gYWN0aW9uL2xvYWRlclxuICovXG5mdW5jdGlvbiBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikge1xuICByZXR1cm4gZXJyb3IgIT0gbnVsbCAmJiB0eXBlb2YgZXJyb3Iuc3RhdHVzID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBlcnJvci5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlcnJvci5pbnRlcm5hbCA9PT0gXCJib29sZWFuXCIgJiYgXCJkYXRhXCIgaW4gZXJyb3I7XG59XG5cbmNvbnN0IHZhbGlkTXV0YXRpb25NZXRob2RzQXJyID0gW1wicG9zdFwiLCBcInB1dFwiLCBcInBhdGNoXCIsIFwiZGVsZXRlXCJdO1xuY29uc3QgdmFsaWRNdXRhdGlvbk1ldGhvZHMgPSBuZXcgU2V0KHZhbGlkTXV0YXRpb25NZXRob2RzQXJyKTtcbmNvbnN0IHZhbGlkUmVxdWVzdE1ldGhvZHNBcnIgPSBbXCJnZXRcIiwgLi4udmFsaWRNdXRhdGlvbk1ldGhvZHNBcnJdO1xuY29uc3QgdmFsaWRSZXF1ZXN0TWV0aG9kcyA9IG5ldyBTZXQodmFsaWRSZXF1ZXN0TWV0aG9kc0Fycik7XG5jb25zdCByZWRpcmVjdFN0YXR1c0NvZGVzID0gbmV3IFNldChbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdKTtcbmNvbnN0IHJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2RlcyA9IG5ldyBTZXQoWzMwNywgMzA4XSk7XG5jb25zdCBJRExFX05BVklHQVRJT04gPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgbG9jYXRpb246IHVuZGVmaW5lZCxcbiAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gIGpzb246IHVuZGVmaW5lZCxcbiAgdGV4dDogdW5kZWZpbmVkXG59O1xuY29uc3QgSURMRV9GRVRDSEVSID0ge1xuICBzdGF0ZTogXCJpZGxlXCIsXG4gIGRhdGE6IHVuZGVmaW5lZCxcbiAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gIGpzb246IHVuZGVmaW5lZCxcbiAgdGV4dDogdW5kZWZpbmVkXG59O1xuY29uc3QgSURMRV9CTE9DS0VSID0ge1xuICBzdGF0ZTogXCJ1bmJsb2NrZWRcIixcbiAgcHJvY2VlZDogdW5kZWZpbmVkLFxuICByZXNldDogdW5kZWZpbmVkLFxuICBsb2NhdGlvbjogdW5kZWZpbmVkXG59O1xuY29uc3QgQUJTT0xVVEVfVVJMX1JFR0VYID0gL14oPzpbYS16XVthLXowLTkrLi1dKjp8XFwvXFwvKS9pO1xuY29uc3QgZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllcyA9IHJvdXRlID0+ICh7XG4gIGhhc0Vycm9yQm91bmRhcnk6IEJvb2xlYW4ocm91dGUuaGFzRXJyb3JCb3VuZGFyeSlcbn0pO1xuY29uc3QgVFJBTlNJVElPTlNfU1RPUkFHRV9LRVkgPSBcInJlbWl4LXJvdXRlci10cmFuc2l0aW9uc1wiO1xuLy8jZW5kcmVnaW9uXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIGNyZWF0ZVJvdXRlclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogQ3JlYXRlIGEgcm91dGVyIGFuZCBsaXN0ZW4gdG8gaGlzdG9yeSBQT1AgbmF2aWdhdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUm91dGVyKGluaXQpIHtcbiAgY29uc3Qgcm91dGVyV2luZG93ID0gaW5pdC53aW5kb3cgPyBpbml0LndpbmRvdyA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiByb3V0ZXJXaW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHJvdXRlcldpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygcm91dGVyV2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG4gIGNvbnN0IGlzU2VydmVyID0gIWlzQnJvd3NlcjtcbiAgaW52YXJpYW50KGluaXQucm91dGVzLmxlbmd0aCA+IDAsIFwiWW91IG11c3QgcHJvdmlkZSBhIG5vbi1lbXB0eSByb3V0ZXMgYXJyYXkgdG8gY3JlYXRlUm91dGVyXCIpO1xuICBsZXQgbWFwUm91dGVQcm9wZXJ0aWVzO1xuICBpZiAoaW5pdC5tYXBSb3V0ZVByb3BlcnRpZXMpIHtcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMgPSBpbml0Lm1hcFJvdXRlUHJvcGVydGllcztcbiAgfSBlbHNlIGlmIChpbml0LmRldGVjdEVycm9yQm91bmRhcnkpIHtcbiAgICAvLyBJZiB0aGV5IGFyZSBzdGlsbCB1c2luZyB0aGUgZGVwcmVjYXRlZCB2ZXJzaW9uLCB3cmFwIGl0IHdpdGggdGhlIG5ldyBBUElcbiAgICBsZXQgZGV0ZWN0RXJyb3JCb3VuZGFyeSA9IGluaXQuZGV0ZWN0RXJyb3JCb3VuZGFyeTtcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMgPSByb3V0ZSA9PiAoe1xuICAgICAgaGFzRXJyb3JCb3VuZGFyeTogZGV0ZWN0RXJyb3JCb3VuZGFyeShyb3V0ZSlcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMgPSBkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzO1xuICB9XG4gIC8vIFJvdXRlcyBrZXllZCBieSBJRFxuICBsZXQgbWFuaWZlc3QgPSB7fTtcbiAgLy8gUm91dGVzIGluIHRyZWUgZm9ybWF0IGZvciBtYXRjaGluZ1xuICBsZXQgZGF0YVJvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoaW5pdC5yb3V0ZXMsIG1hcFJvdXRlUHJvcGVydGllcywgdW5kZWZpbmVkLCBtYW5pZmVzdCk7XG4gIGxldCBpbkZsaWdodERhdGFSb3V0ZXM7XG4gIGxldCBiYXNlbmFtZSA9IGluaXQuYmFzZW5hbWUgfHwgXCIvXCI7XG4gIC8vIENvbmZpZyBkcml2ZW4gYmVoYXZpb3IgZmxhZ3NcbiAgbGV0IGZ1dHVyZSA9IF9leHRlbmRzKHtcbiAgICB2N19mZXRjaGVyUGVyc2lzdDogZmFsc2UsXG4gICAgdjdfbm9ybWFsaXplRm9ybU1ldGhvZDogZmFsc2UsXG4gICAgdjdfcGFydGlhbEh5ZHJhdGlvbjogZmFsc2UsXG4gICAgdjdfcHJlcGVuZEJhc2VuYW1lOiBmYWxzZSxcbiAgICB2N19yZWxhdGl2ZVNwbGF0UGF0aDogZmFsc2VcbiAgfSwgaW5pdC5mdXR1cmUpO1xuICAvLyBDbGVhbnVwIGZ1bmN0aW9uIGZvciBoaXN0b3J5XG4gIGxldCB1bmxpc3Rlbkhpc3RvcnkgPSBudWxsO1xuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIGZ1bmN0aW9ucyB0byBjYWxsIG9uIGFsbCBzdGF0ZSBjaGFuZ2VzXG4gIGxldCBzdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbiAgLy8gRXh0ZXJuYWxseS1wcm92aWRlZCBvYmplY3QgdG8gaG9sZCBzY3JvbGwgcmVzdG9yYXRpb24gbG9jYXRpb25zIGR1cmluZyByb3V0aW5nXG4gIGxldCBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IG51bGw7XG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgZnVuY3Rpb24gdG8gZ2V0IHNjcm9sbCByZXN0b3JhdGlvbiBrZXlzXG4gIGxldCBnZXRTY3JvbGxSZXN0b3JhdGlvbktleSA9IG51bGw7XG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgZnVuY3Rpb24gdG8gZ2V0IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXG4gIGxldCBnZXRTY3JvbGxQb3NpdGlvbiA9IG51bGw7XG4gIC8vIE9uZS10aW1lIGZsYWcgdG8gY29udHJvbCB0aGUgaW5pdGlhbCBoeWRyYXRpb24gc2Nyb2xsIHJlc3RvcmF0aW9uLiAgQmVjYXVzZVxuICAvLyB3ZSBkb24ndCBnZXQgdGhlIHNhdmVkIHBvc2l0aW9ucyBmcm9tIDxTY3JvbGxSZXN0b3JhdGlvbiAvPiB1bnRpbCBfYWZ0ZXJfXG4gIC8vIHRoZSBpbml0aWFsIHJlbmRlciwgd2UgbmVlZCB0byBtYW51YWxseSB0cmlnZ2VyIGEgc2VwYXJhdGUgdXBkYXRlU3RhdGUgdG9cbiAgLy8gc2VuZCBhbG9uZyB0aGUgcmVzdG9yZVNjcm9sbFBvc2l0aW9uXG4gIC8vIFNldCB0byB0cnVlIGlmIHdlIGhhdmUgYGh5ZHJhdGlvbkRhdGFgIHNpbmNlIHdlIGFzc3VtZSB3ZSB3ZXJlIFNTUidkIGFuZCB0aGF0XG4gIC8vIFNTUiBkaWQgdGhlIGluaXRpYWwgc2Nyb2xsIHJlc3RvcmF0aW9uLlxuICBsZXQgaW5pdGlhbFNjcm9sbFJlc3RvcmVkID0gaW5pdC5oeWRyYXRpb25EYXRhICE9IG51bGw7XG4gIGxldCBpbml0aWFsTWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGluaXQuaGlzdG9yeS5sb2NhdGlvbiwgYmFzZW5hbWUpO1xuICBsZXQgaW5pdGlhbEVycm9ycyA9IG51bGw7XG4gIGlmIChpbml0aWFsTWF0Y2hlcyA9PSBudWxsKSB7XG4gICAgLy8gSWYgd2UgZG8gbm90IG1hdGNoIGEgdXNlci1wcm92aWRlZC1yb3V0ZSwgZmFsbCBiYWNrIHRvIHRoZSByb290XG4gICAgLy8gdG8gYWxsb3cgdGhlIGVycm9yIGJvdW5kYXJ5IHRvIHRha2Ugb3ZlclxuICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICBwYXRobmFtZTogaW5pdC5oaXN0b3J5LmxvY2F0aW9uLnBhdGhuYW1lXG4gICAgfSk7XG4gICAgbGV0IHtcbiAgICAgIG1hdGNoZXMsXG4gICAgICByb3V0ZVxuICAgIH0gPSBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKGRhdGFSb3V0ZXMpO1xuICAgIGluaXRpYWxNYXRjaGVzID0gbWF0Y2hlcztcbiAgICBpbml0aWFsRXJyb3JzID0ge1xuICAgICAgW3JvdXRlLmlkXTogZXJyb3JcbiAgICB9O1xuICB9XG4gIGxldCBpbml0aWFsaXplZDtcbiAgbGV0IGhhc0xhenlSb3V0ZXMgPSBpbml0aWFsTWF0Y2hlcy5zb21lKG0gPT4gbS5yb3V0ZS5sYXp5KTtcbiAgbGV0IGhhc0xvYWRlcnMgPSBpbml0aWFsTWF0Y2hlcy5zb21lKG0gPT4gbS5yb3V0ZS5sb2FkZXIpO1xuICBpZiAoaGFzTGF6eVJvdXRlcykge1xuICAgIC8vIEFsbCBpbml0aWFsTWF0Y2hlcyBuZWVkIHRvIGJlIGxvYWRlZCBiZWZvcmUgd2UncmUgcmVhZHkuICBJZiB3ZSBoYXZlIGxhenlcbiAgICAvLyBmdW5jdGlvbnMgYXJvdW5kIHN0aWxsIHRoZW4gd2UnbGwgbmVlZCB0byBydW4gdGhlbSBpbiBpbml0aWFsaXplKClcbiAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKCFoYXNMb2FkZXJzKSB7XG4gICAgLy8gSWYgd2UndmUgZ290IG5vIGxvYWRlcnMgdG8gcnVuLCB0aGVuIHdlJ3JlIGdvb2QgdG8gZ29cbiAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gIH0gZWxzZSBpZiAoZnV0dXJlLnY3X3BhcnRpYWxIeWRyYXRpb24pIHtcbiAgICAvLyBJZiBwYXJ0aWFsIGh5ZHJhdGlvbiBpcyBlbmFibGVkLCB3ZSdyZSBpbml0aWFsaXplZCBzbyBsb25nIGFzIHdlIHdlcmVcbiAgICAvLyBwcm92aWRlZCB3aXRoIGh5ZHJhdGlvbkRhdGEgZm9yIGV2ZXJ5IHJvdXRlIHdpdGggYSBsb2FkZXIsIGFuZCBubyBsb2FkZXJzXG4gICAgLy8gd2VyZSBtYXJrZWQgZm9yIGV4cGxpY2l0IGh5ZHJhdGlvblxuICAgIGxldCBsb2FkZXJEYXRhID0gaW5pdC5oeWRyYXRpb25EYXRhID8gaW5pdC5oeWRyYXRpb25EYXRhLmxvYWRlckRhdGEgOiBudWxsO1xuICAgIGxldCBlcnJvcnMgPSBpbml0Lmh5ZHJhdGlvbkRhdGEgPyBpbml0Lmh5ZHJhdGlvbkRhdGEuZXJyb3JzIDogbnVsbDtcbiAgICBsZXQgaXNSb3V0ZUluaXRpYWxpemVkID0gbSA9PiB7XG4gICAgICAvLyBObyBsb2FkZXIsIG5vdGhpbmcgdG8gaW5pdGlhbGl6ZVxuICAgICAgaWYgKCFtLnJvdXRlLmxvYWRlcikgcmV0dXJuIHRydWU7XG4gICAgICAvLyBFeHBsaWNpdGx5IG9wdGluZy1pbiB0byBydW5uaW5nIG9uIGh5ZHJhdGlvblxuICAgICAgaWYgKG0ucm91dGUubG9hZGVyLmh5ZHJhdGUgPT09IHRydWUpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIE90aGVyd2lzZSwgaW5pdGlhbGl6ZWQgaWYgaHlkcmF0ZWQgd2l0aCBkYXRhIG9yIGFuIGVycm9yXG4gICAgICByZXR1cm4gbG9hZGVyRGF0YSAmJiBsb2FkZXJEYXRhW20ucm91dGUuaWRdICE9PSB1bmRlZmluZWQgfHwgZXJyb3JzICYmIGVycm9yc1ttLnJvdXRlLmlkXSAhPT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLy8gSWYgZXJyb3JzIGV4aXN0LCBkb24ndCBjb25zaWRlciByb3V0ZXMgYmVsb3cgdGhlIGJvdW5kYXJ5XG4gICAgaWYgKGVycm9ycykge1xuICAgICAgbGV0IGlkeCA9IGluaXRpYWxNYXRjaGVzLmZpbmRJbmRleChtID0+IGVycm9yc1ttLnJvdXRlLmlkXSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgIGluaXRpYWxpemVkID0gaW5pdGlhbE1hdGNoZXMuc2xpY2UoMCwgaWR4ICsgMSkuZXZlcnkoaXNSb3V0ZUluaXRpYWxpemVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdGlhbGl6ZWQgPSBpbml0aWFsTWF0Y2hlcy5ldmVyeShpc1JvdXRlSW5pdGlhbGl6ZWQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXaXRob3V0IHBhcnRpYWwgaHlkcmF0aW9uIC0gd2UncmUgaW5pdGlhbGl6ZWQgaWYgd2Ugd2VyZSBwcm92aWRlZCBhbnlcbiAgICAvLyBoeWRyYXRpb25EYXRhIC0gd2hpY2ggaXMgZXhwZWN0ZWQgdG8gYmUgY29tcGxldGVcbiAgICBpbml0aWFsaXplZCA9IGluaXQuaHlkcmF0aW9uRGF0YSAhPSBudWxsO1xuICB9XG4gIGxldCByb3V0ZXI7XG4gIGxldCBzdGF0ZSA9IHtcbiAgICBoaXN0b3J5QWN0aW9uOiBpbml0Lmhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBpbml0Lmhpc3RvcnkubG9jYXRpb24sXG4gICAgbWF0Y2hlczogaW5pdGlhbE1hdGNoZXMsXG4gICAgaW5pdGlhbGl6ZWQsXG4gICAgbmF2aWdhdGlvbjogSURMRV9OQVZJR0FUSU9OLFxuICAgIC8vIERvbid0IHJlc3RvcmUgb24gaW5pdGlhbCB1cGRhdGVTdGF0ZSgpIGlmIHdlIHdlcmUgU1NSJ2RcbiAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IGluaXQuaHlkcmF0aW9uRGF0YSAhPSBudWxsID8gZmFsc2UgOiBudWxsLFxuICAgIHByZXZlbnRTY3JvbGxSZXNldDogZmFsc2UsXG4gICAgcmV2YWxpZGF0aW9uOiBcImlkbGVcIixcbiAgICBsb2FkZXJEYXRhOiBpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmxvYWRlckRhdGEgfHwge30sXG4gICAgYWN0aW9uRGF0YTogaW5pdC5oeWRyYXRpb25EYXRhICYmIGluaXQuaHlkcmF0aW9uRGF0YS5hY3Rpb25EYXRhIHx8IG51bGwsXG4gICAgZXJyb3JzOiBpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmVycm9ycyB8fCBpbml0aWFsRXJyb3JzLFxuICAgIGZldGNoZXJzOiBuZXcgTWFwKCksXG4gICAgYmxvY2tlcnM6IG5ldyBNYXAoKVxuICB9O1xuICAvLyAtLSBTdGF0ZWZ1bCBpbnRlcm5hbCB2YXJpYWJsZXMgdG8gbWFuYWdlIG5hdmlnYXRpb25zIC0tXG4gIC8vIEN1cnJlbnQgbmF2aWdhdGlvbiBpbiBwcm9ncmVzcyAodG8gYmUgY29tbWl0dGVkIGluIGNvbXBsZXRlTmF2aWdhdGlvbilcbiAgbGV0IHBlbmRpbmdBY3Rpb24gPSBBY3Rpb24uUG9wO1xuICAvLyBTaG91bGQgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiBwcmV2ZW50IHRoZSBzY3JvbGwgcmVzZXQgaWYgc2Nyb2xsIGNhbm5vdFxuICAvLyBiZSByZXN0b3JlZD9cbiAgbGV0IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSBmYWxzZTtcbiAgLy8gQWJvcnRDb250cm9sbGVyIGZvciB0aGUgYWN0aXZlIG5hdmlnYXRpb25cbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcjtcbiAgLy8gU2hvdWxkIHRoZSBjdXJyZW50IG5hdmlnYXRpb24gZW5hYmxlIGRvY3VtZW50LnN0YXJ0Vmlld1RyYW5zaXRpb24/XG4gIGxldCBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkID0gZmFsc2U7XG4gIC8vIFN0b3JlIGFwcGxpZWQgdmlldyB0cmFuc2l0aW9ucyBzbyB3ZSBjYW4gYXBwbHkgdGhlbSBvbiBQT1BcbiAgbGV0IGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMgPSBuZXcgTWFwKCk7XG4gIC8vIENsZWFudXAgZnVuY3Rpb24gZm9yIHBlcnNpc3RpbmcgYXBwbGllZCB0cmFuc2l0aW9ucyB0byBzZXNzaW9uU3RvcmFnZVxuICBsZXQgcmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyID0gbnVsbDtcbiAgLy8gV2UgdXNlIHRoaXMgdG8gYXZvaWQgdG91Y2hpbmcgaGlzdG9yeSBpbiBjb21wbGV0ZU5hdmlnYXRpb24gaWYgYVxuICAvLyByZXZhbGlkYXRpb24gaXMgZW50aXJlbHkgdW5pbnRlcnJ1cHRlZFxuICBsZXQgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG4gIC8vIFVzZSB0aGlzIGludGVybmFsIGZsYWcgdG8gZm9yY2UgcmV2YWxpZGF0aW9uIG9mIGFsbCBsb2FkZXJzOlxuICAvLyAgLSBzdWJtaXNzaW9ucyAoY29tcGxldGVkIG9yIGludGVycnVwdGVkKVxuICAvLyAgLSB1c2VSZXZhbGlkYXRvcigpXG4gIC8vICAtIFgtUmVtaXgtUmV2YWxpZGF0ZSAoZnJvbSByZWRpcmVjdClcbiAgbGV0IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcbiAgLy8gVXNlIHRoaXMgaW50ZXJuYWwgYXJyYXkgdG8gY2FwdHVyZSByb3V0ZXMgdGhhdCByZXF1aXJlIHJldmFsaWRhdGlvbiBkdWVcbiAgLy8gdG8gYSBjYW5jZWxsZWQgZGVmZXJyZWQgb24gYWN0aW9uIHN1Ym1pc3Npb25cbiAgbGV0IGNhbmNlbGxlZERlZmVycmVkUm91dGVzID0gW107XG4gIC8vIFVzZSB0aGlzIGludGVybmFsIGFycmF5IHRvIGNhcHR1cmUgZmV0Y2hlciBsb2FkcyB0aGF0IHdlcmUgY2FuY2VsbGVkIGJ5IGFuXG4gIC8vIGFjdGlvbiBuYXZpZ2F0aW9uIGFuZCByZXF1aXJlIHJldmFsaWRhdGlvblxuICBsZXQgY2FuY2VsbGVkRmV0Y2hlckxvYWRzID0gW107XG4gIC8vIEFib3J0Q29udHJvbGxlcnMgZm9yIGFueSBpbi1mbGlnaHQgZmV0Y2hlcnNcbiAgbGV0IGZldGNoQ29udHJvbGxlcnMgPSBuZXcgTWFwKCk7XG4gIC8vIFRyYWNrIGxvYWRzIGJhc2VkIG9uIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHN0YXJ0ZWRcbiAgbGV0IGluY3JlbWVudGluZ0xvYWRJZCA9IDA7XG4gIC8vIFRyYWNrIHRoZSBvdXRzdGFuZGluZyBwZW5kaW5nIG5hdmlnYXRpb24gZGF0YSBsb2FkIHRvIGJlIGNvbXBhcmVkIGFnYWluc3RcbiAgLy8gdGhlIGdsb2JhbGx5IGluY3JlbWVudGluZyBsb2FkIHdoZW4gYSBmZXRjaGVyIGxvYWQgbGFuZHMgYWZ0ZXIgYSBjb21wbGV0ZWRcbiAgLy8gbmF2aWdhdGlvblxuICBsZXQgcGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPSAtMTtcbiAgLy8gRmV0Y2hlcnMgdGhhdCB0cmlnZ2VyZWQgZGF0YSByZWxvYWRzIGFzIGEgcmVzdWx0IG9mIHRoZWlyIGFjdGlvbnNcbiAgbGV0IGZldGNoUmVsb2FkSWRzID0gbmV3IE1hcCgpO1xuICAvLyBGZXRjaGVycyB0aGF0IHRyaWdnZXJlZCByZWRpcmVjdCBuYXZpZ2F0aW9uc1xuICBsZXQgZmV0Y2hSZWRpcmVjdElkcyA9IG5ldyBTZXQoKTtcbiAgLy8gTW9zdCByZWNlbnQgaHJlZi9tYXRjaCBmb3IgZmV0Y2hlci5sb2FkIGNhbGxzIGZvciBmZXRjaGVyc1xuICBsZXQgZmV0Y2hMb2FkTWF0Y2hlcyA9IG5ldyBNYXAoKTtcbiAgLy8gUmVmLWNvdW50IG1vdW50ZWQgZmV0Y2hlcnMgc28gd2Uga25vdyB3aGVuIGl0J3Mgb2sgdG8gY2xlYW4gdGhlbSB1cFxuICBsZXQgYWN0aXZlRmV0Y2hlcnMgPSBuZXcgTWFwKCk7XG4gIC8vIEZldGNoZXJzIHRoYXQgaGF2ZSByZXF1ZXN0ZWQgYSBkZWxldGUgd2hlbiB1c2luZyB2N19mZXRjaGVyUGVyc2lzdCxcbiAgLy8gdGhleSdsbCBiZSBvZmZpY2lhbGx5IHJlbW92ZWQgYWZ0ZXIgdGhleSByZXR1cm4gdG8gaWRsZVxuICBsZXQgZGVsZXRlZEZldGNoZXJzID0gbmV3IFNldCgpO1xuICAvLyBTdG9yZSBEZWZlcnJlZERhdGEgaW5zdGFuY2VzIGZvciBhY3RpdmUgcm91dGUgbWF0Y2hlcy4gIFdoZW4gYVxuICAvLyByb3V0ZSBsb2FkZXIgcmV0dXJucyBkZWZlcigpIHdlIHN0aWNrIG9uZSBpbiBoZXJlLiAgVGhlbiwgd2hlbiBhIG5lc3RlZFxuICAvLyBwcm9taXNlIHJlc29sdmVzIHdlIHVwZGF0ZSBsb2FkZXJEYXRhLiAgSWYgYSBuZXcgbmF2aWdhdGlvbiBzdGFydHMgd2VcbiAgLy8gY2FuY2VsIGFjdGl2ZSBkZWZlcnJlZHMgZm9yIGVsaW1pbmF0ZWQgcm91dGVzLlxuICBsZXQgYWN0aXZlRGVmZXJyZWRzID0gbmV3IE1hcCgpO1xuICAvLyBTdG9yZSBibG9ja2VyIGZ1bmN0aW9ucyBpbiBhIHNlcGFyYXRlIE1hcCBvdXRzaWRlIG9mIHJvdXRlciBzdGF0ZSBzaW5jZVxuICAvLyB3ZSBkb24ndCBuZWVkIHRvIHVwZGF0ZSBVSSBzdGF0ZSBpZiB0aGV5IGNoYW5nZVxuICBsZXQgYmxvY2tlckZ1bmN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgLy8gRmxhZyB0byBpZ25vcmUgdGhlIG5leHQgaGlzdG9yeSB1cGRhdGUsIHNvIHdlIGNhbiByZXZlcnQgdGhlIFVSTCBjaGFuZ2Ugb25cbiAgLy8gYSBQT1AgbmF2aWdhdGlvbiB0aGF0IHdhcyBibG9ja2VkIGJ5IHRoZSB1c2VyIHdpdGhvdXQgdG91Y2hpbmcgcm91dGVyIHN0YXRlXG4gIGxldCBpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSA9IGZhbHNlO1xuICAvLyBJbml0aWFsaXplIHRoZSByb3V0ZXIsIGFsbCBzaWRlIGVmZmVjdHMgc2hvdWxkIGJlIGtpY2tlZCBvZmYgZnJvbSBoZXJlLlxuICAvLyBJbXBsZW1lbnRlZCBhcyBhIEZsdWVudCBBUEkgZm9yIGVhc2Ugb2Y6XG4gIC8vICAgbGV0IHJvdXRlciA9IGNyZWF0ZVJvdXRlcihpbml0KS5pbml0aWFsaXplKCk7XG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgLy8gSWYgaGlzdG9yeSBpbmZvcm1zIHVzIG9mIGEgUE9QIG5hdmlnYXRpb24sIHN0YXJ0IHRoZSBuYXZpZ2F0aW9uIGJ1dCBkbyBub3QgdXBkYXRlXG4gICAgLy8gc3RhdGUuICBXZSdsbCB1cGRhdGUgb3VyIG93biBzdGF0ZSBvbmNlIHRoZSBuYXZpZ2F0aW9uIGNvbXBsZXRlc1xuICAgIHVubGlzdGVuSGlzdG9yeSA9IGluaXQuaGlzdG9yeS5saXN0ZW4oX3JlZiA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBhY3Rpb246IGhpc3RvcnlBY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBkZWx0YVxuICAgICAgfSA9IF9yZWY7XG4gICAgICAvLyBJZ25vcmUgdGhpcyBldmVudCBpZiBpdCB3YXMganVzdCB1cyByZXNldHRpbmcgdGhlIFVSTCBmcm9tIGFcbiAgICAgIC8vIGJsb2NrZWQgUE9QIG5hdmlnYXRpb25cbiAgICAgIGlmIChpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSkge1xuICAgICAgICBpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3YXJuaW5nKGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA9PT0gMCB8fCBkZWx0YSAhPSBudWxsLCBcIllvdSBhcmUgdHJ5aW5nIHRvIHVzZSBhIGJsb2NrZXIgb24gYSBQT1AgbmF2aWdhdGlvbiB0byBhIGxvY2F0aW9uIFwiICsgXCJ0aGF0IHdhcyBub3QgY3JlYXRlZCBieSBAcmVtaXgtcnVuL3JvdXRlci4gVGhpcyB3aWxsIGZhaWwgc2lsZW50bHkgaW4gXCIgKyBcInByb2R1Y3Rpb24uIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgYXJlIG5hdmlnYXRpbmcgb3V0c2lkZSB0aGUgcm91dGVyIFwiICsgXCJ2aWEgYHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZWAvYHdpbmRvdy5sb2NhdGlvbi5oYXNoYCBpbnN0ZWFkIG9mIHVzaW5nIFwiICsgXCJyb3V0ZXIgbmF2aWdhdGlvbiBBUElzLiAgVGhpcyBjYW4gYWxzbyBoYXBwZW4gaWYgeW91IGFyZSB1c2luZyBcIiArIFwiY3JlYXRlSGFzaFJvdXRlciBhbmQgdGhlIHVzZXIgbWFudWFsbHkgY2hhbmdlcyB0aGUgVVJMLlwiKTtcbiAgICAgIGxldCBibG9ja2VyS2V5ID0gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKHtcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgbmV4dExvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgaGlzdG9yeUFjdGlvblxuICAgICAgfSk7XG4gICAgICBpZiAoYmxvY2tlcktleSAmJiBkZWx0YSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFJlc3RvcmUgdGhlIFVSTCB0byBtYXRjaCB0aGUgY3VycmVudCBVSSwgYnV0IGRvbid0IHVwZGF0ZSByb3V0ZXIgc3RhdGVcbiAgICAgICAgaWdub3JlTmV4dEhpc3RvcnlVcGRhdGUgPSB0cnVlO1xuICAgICAgICBpbml0Lmhpc3RvcnkuZ28oZGVsdGEgKiAtMSk7XG4gICAgICAgIC8vIFB1dCB0aGUgYmxvY2tlciBpbnRvIGEgYmxvY2tlZCBzdGF0ZVxuICAgICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgICBzdGF0ZTogXCJibG9ja2VkXCIsXG4gICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgcHJvY2VlZCgpIHtcbiAgICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICAgICAgICBzdGF0ZTogXCJwcm9jZWVkaW5nXCIsXG4gICAgICAgICAgICAgIHByb2NlZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgcmVzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgbG9jYXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUmUtZG8gdGhlIHNhbWUgUE9QIG5hdmlnYXRpb24gd2UganVzdCBibG9ja2VkXG4gICAgICAgICAgICBpbml0Lmhpc3RvcnkuZ28oZGVsdGEpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICBsZXQgYmxvY2tlcnMgPSBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKTtcbiAgICAgICAgICAgIGJsb2NrZXJzLnNldChibG9ja2VyS2V5LCBJRExFX0JMT0NLRVIpO1xuICAgICAgICAgICAgdXBkYXRlU3RhdGUoe1xuICAgICAgICAgICAgICBibG9ja2Vyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXJ0TmF2aWdhdGlvbihoaXN0b3J5QWN0aW9uLCBsb2NhdGlvbik7XG4gICAgfSk7XG4gICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgLy8gRklYTUU6IFRoaXMgZmVlbHMgZ3Jvc3MuICBIb3cgY2FuIHdlIGNsZWFudXAgdGhlIGxpbmVzIGJldHdlZW5cbiAgICAgIC8vIHNjcm9sbFJlc3RvcmF0aW9uL2FwcGxpZWRUcmFuc2l0aW9ucyBwZXJzaXN0YW5jZT9cbiAgICAgIHJlc3RvcmVBcHBsaWVkVHJhbnNpdGlvbnMocm91dGVyV2luZG93LCBhcHBsaWVkVmlld1RyYW5zaXRpb25zKTtcbiAgICAgIGxldCBfc2F2ZUFwcGxpZWRUcmFuc2l0aW9ucyA9ICgpID0+IHBlcnNpc3RBcHBsaWVkVHJhbnNpdGlvbnMocm91dGVyV2luZG93LCBhcHBsaWVkVmlld1RyYW5zaXRpb25zKTtcbiAgICAgIHJvdXRlcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgX3NhdmVBcHBsaWVkVHJhbnNpdGlvbnMpO1xuICAgICAgcmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyID0gKCkgPT4gcm91dGVyV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBfc2F2ZUFwcGxpZWRUcmFuc2l0aW9ucyk7XG4gICAgfVxuICAgIC8vIEtpY2sgb2ZmIGluaXRpYWwgZGF0YSBsb2FkIGlmIG5lZWRlZC4gIFVzZSBQb3AgdG8gYXZvaWQgbW9kaWZ5aW5nIGhpc3RvcnlcbiAgICAvLyBOb3RlIHdlIGRvbid0IGRvIGFueSBoYW5kbGluZyBvZiBsYXp5IGhlcmUuICBGb3IgU1BBJ3MgaXQnbGwgZ2V0IGhhbmRsZWRcbiAgICAvLyBpbiB0aGUgbm9ybWFsIG5hdmlnYXRpb24gZmxvdy4gIEZvciBTU1IgaXQncyBleHBlY3RlZCB0aGF0IGxhenkgbW9kdWxlcyBhcmVcbiAgICAvLyByZXNvbHZlZCBwcmlvciB0byByb3V0ZXIgY3JlYXRpb24gc2luY2Ugd2UgY2FuJ3QgZ28gaW50byBhIGZhbGxiYWNrRWxlbWVudFxuICAgIC8vIFVJIGZvciBTU1InZCBhcHBzXG4gICAgaWYgKCFzdGF0ZS5pbml0aWFsaXplZCkge1xuICAgICAgc3RhcnROYXZpZ2F0aW9uKEFjdGlvbi5Qb3AsIHN0YXRlLmxvY2F0aW9uLCB7XG4gICAgICAgIGluaXRpYWxIeWRyYXRpb246IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcm91dGVyO1xuICB9XG4gIC8vIENsZWFuIHVwIGEgcm91dGVyIGFuZCBpdCdzIHNpZGUgZWZmZWN0c1xuICBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIGlmICh1bmxpc3Rlbkhpc3RvcnkpIHtcbiAgICAgIHVubGlzdGVuSGlzdG9yeSgpO1xuICAgIH1cbiAgICBpZiAocmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyKSB7XG4gICAgICByZW1vdmVQYWdlSGlkZUV2ZW50TGlzdGVuZXIoKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlcnMuY2xlYXIoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgJiYgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLmFib3J0KCk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuZm9yRWFjaCgoXywga2V5KSA9PiBkZWxldGVGZXRjaGVyKGtleSkpO1xuICAgIHN0YXRlLmJsb2NrZXJzLmZvckVhY2goKF8sIGtleSkgPT4gZGVsZXRlQmxvY2tlcihrZXkpKTtcbiAgfVxuICAvLyBTdWJzY3JpYmUgdG8gc3RhdGUgdXBkYXRlcyBmb3IgdGhlIHJvdXRlclxuICBmdW5jdGlvbiBzdWJzY3JpYmUoZm4pIHtcbiAgICBzdWJzY3JpYmVycy5hZGQoZm4pO1xuICAgIHJldHVybiAoKSA9PiBzdWJzY3JpYmVycy5kZWxldGUoZm4pO1xuICB9XG4gIC8vIFVwZGF0ZSBvdXIgc3RhdGUgYW5kIG5vdGlmeSB0aGUgY2FsbGluZyBjb250ZXh0IG9mIHRoZSBjaGFuZ2VcbiAgZnVuY3Rpb24gdXBkYXRlU3RhdGUobmV3U3RhdGUsIG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIHN0YXRlID0gX2V4dGVuZHMoe30sIHN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgLy8gUHJlcCBmZXRjaGVyIGNsZWFudXAgc28gd2UgY2FuIHRlbGwgdGhlIFVJIHdoaWNoIGZldGNoZXIgZGF0YSBlbnRyaWVzXG4gICAgLy8gY2FuIGJlIHJlbW92ZWRcbiAgICBsZXQgY29tcGxldGVkRmV0Y2hlcnMgPSBbXTtcbiAgICBsZXQgZGVsZXRlZEZldGNoZXJzS2V5cyA9IFtdO1xuICAgIGlmIChmdXR1cmUudjdfZmV0Y2hlclBlcnNpc3QpIHtcbiAgICAgIHN0YXRlLmZldGNoZXJzLmZvckVhY2goKGZldGNoZXIsIGtleSkgPT4ge1xuICAgICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgICBpZiAoZGVsZXRlZEZldGNoZXJzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAvLyBVbm1vdW50ZWQgZnJvbSB0aGUgVUkgYW5kIGNhbiBiZSB0b3RhbGx5IHJlbW92ZWRcbiAgICAgICAgICAgIGRlbGV0ZWRGZXRjaGVyc0tleXMucHVzaChrZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZXR1cm5lZCB0byBpZGxlIGJ1dCBzdGlsbCBtb3VudGVkIGluIHRoZSBVSSwgc28gc2VtaS1yZW1haW5zIGZvclxuICAgICAgICAgICAgLy8gcmV2YWxpZGF0aW9ucyBhbmQgc3VjaFxuICAgICAgICAgICAgY29tcGxldGVkRmV0Y2hlcnMucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEl0ZXJhdGUgb3ZlciBhIGxvY2FsIGNvcHkgc28gdGhhdCBpZiBmbHVzaFN5bmMgaXMgdXNlZCBhbmQgd2UgZW5kIHVwXG4gICAgLy8gcmVtb3ZpbmcgYW5kIGFkZGluZyBhIG5ldyBzdWJzY3JpYmVyIGR1ZSB0byB0aGUgdXNlQ2FsbGJhY2sgZGVwZW5kZW5jaWVzLFxuICAgIC8vIHdlIGRvbid0IGdldCBvdXJzZWx2ZXMgaW50byBhIGxvb3AgY2FsbGluZyB0aGUgbmV3IHN1YnNjcmliZXIgaW1tZWRpYXRlbHlcbiAgICBbLi4uc3Vic2NyaWJlcnNdLmZvckVhY2goc3Vic2NyaWJlciA9PiBzdWJzY3JpYmVyKHN0YXRlLCB7XG4gICAgICBkZWxldGVkRmV0Y2hlcnM6IGRlbGV0ZWRGZXRjaGVyc0tleXMsXG4gICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbk9wdHM6IG9wdHMudmlld1RyYW5zaXRpb25PcHRzLFxuICAgICAgdW5zdGFibGVfZmx1c2hTeW5jOiBvcHRzLmZsdXNoU3luYyA9PT0gdHJ1ZVxuICAgIH0pKTtcbiAgICAvLyBSZW1vdmUgaWRsZSBmZXRjaGVycyBmcm9tIHN0YXRlIHNpbmNlIHdlIG9ubHkgY2FyZSBhYm91dCBpbi1mbGlnaHQgZmV0Y2hlcnMuXG4gICAgaWYgKGZ1dHVyZS52N19mZXRjaGVyUGVyc2lzdCkge1xuICAgICAgY29tcGxldGVkRmV0Y2hlcnMuZm9yRWFjaChrZXkgPT4gc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSkpO1xuICAgICAgZGVsZXRlZEZldGNoZXJzS2V5cy5mb3JFYWNoKGtleSA9PiBkZWxldGVGZXRjaGVyKGtleSkpO1xuICAgIH1cbiAgfVxuICAvLyBDb21wbGV0ZSBhIG5hdmlnYXRpb24gcmV0dXJuaW5nIHRoZSBzdGF0ZS5uYXZpZ2F0aW9uIGJhY2sgdG8gdGhlIElETEVfTkFWSUdBVElPTlxuICAvLyBhbmQgc2V0dGluZyBzdGF0ZS5baGlzdG9yeUFjdGlvbi9sb2NhdGlvbi9tYXRjaGVzXSB0byB0aGUgbmV3IHJvdXRlLlxuICAvLyAtIExvY2F0aW9uIGlzIGEgcmVxdWlyZWQgcGFyYW1cbiAgLy8gLSBOYXZpZ2F0aW9uIHdpbGwgYWx3YXlzIGJlIHNldCB0byBJRExFX05BVklHQVRJT05cbiAgLy8gLSBDYW4gcGFzcyBhbnkgb3RoZXIgc3RhdGUgaW4gbmV3U3RhdGVcbiAgZnVuY3Rpb24gY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCBuZXdTdGF0ZSwgX3RlbXApIHtcbiAgICB2YXIgX2xvY2F0aW9uJHN0YXRlLCBfbG9jYXRpb24kc3RhdGUyO1xuICAgIGxldCB7XG4gICAgICBmbHVzaFN5bmNcbiAgICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gICAgLy8gRGVkdWNlIGlmIHdlJ3JlIGluIGEgbG9hZGluZy9hY3Rpb25SZWxvYWQgc3RhdGU6XG4gICAgLy8gLSBXZSBoYXZlIGNvbW1pdHRlZCBhY3Rpb25EYXRhIGluIHRoZSBzdG9yZVxuICAgIC8vIC0gVGhlIGN1cnJlbnQgbmF2aWdhdGlvbiB3YXMgYSBtdXRhdGlvbiBzdWJtaXNzaW9uXG4gICAgLy8gLSBXZSdyZSBwYXN0IHRoZSBzdWJtaXR0aW5nIHN0YXRlIGFuZCBpbnRvIHRoZSBsb2FkaW5nIHN0YXRlXG4gICAgLy8gLSBUaGUgbG9jYXRpb24gYmVpbmcgbG9hZGVkIGlzIG5vdCB0aGUgcmVzdWx0IG9mIGEgcmVkaXJlY3RcbiAgICBsZXQgaXNBY3Rpb25SZWxvYWQgPSBzdGF0ZS5hY3Rpb25EYXRhICE9IG51bGwgJiYgc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kICE9IG51bGwgJiYgaXNNdXRhdGlvbk1ldGhvZChzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QpICYmIHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiICYmICgoX2xvY2F0aW9uJHN0YXRlID0gbG9jYXRpb24uc3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfbG9jYXRpb24kc3RhdGUuX2lzUmVkaXJlY3QpICE9PSB0cnVlO1xuICAgIGxldCBhY3Rpb25EYXRhO1xuICAgIGlmIChuZXdTdGF0ZS5hY3Rpb25EYXRhKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMobmV3U3RhdGUuYWN0aW9uRGF0YSkubGVuZ3RoID4gMCkge1xuICAgICAgICBhY3Rpb25EYXRhID0gbmV3U3RhdGUuYWN0aW9uRGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVtcHR5IGFjdGlvbkRhdGEgLT4gY2xlYXIgcHJpb3IgYWN0aW9uRGF0YSBkdWUgdG8gYW4gYWN0aW9uIGVycm9yXG4gICAgICAgIGFjdGlvbkRhdGEgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNBY3Rpb25SZWxvYWQpIHtcbiAgICAgIC8vIEtlZXAgdGhlIGN1cnJlbnQgZGF0YSBpZiB3ZSdyZSB3cmFwcGluZyB1cCB0aGUgYWN0aW9uIHJlbG9hZFxuICAgICAgYWN0aW9uRGF0YSA9IHN0YXRlLmFjdGlvbkRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENsZWFyIGFjdGlvbkRhdGEgb24gYW55IG90aGVyIGNvbXBsZXRlZCBuYXZpZ2F0aW9uc1xuICAgICAgYWN0aW9uRGF0YSA9IG51bGw7XG4gICAgfVxuICAgIC8vIEFsd2F5cyBwcmVzZXJ2ZSBhbnkgZXhpc3RpbmcgbG9hZGVyRGF0YSBmcm9tIHJlLXVzZWQgcm91dGVzXG4gICAgbGV0IGxvYWRlckRhdGEgPSBuZXdTdGF0ZS5sb2FkZXJEYXRhID8gbWVyZ2VMb2FkZXJEYXRhKHN0YXRlLmxvYWRlckRhdGEsIG5ld1N0YXRlLmxvYWRlckRhdGEsIG5ld1N0YXRlLm1hdGNoZXMgfHwgW10sIG5ld1N0YXRlLmVycm9ycykgOiBzdGF0ZS5sb2FkZXJEYXRhO1xuICAgIC8vIE9uIGEgc3VjY2Vzc2Z1bCBuYXZpZ2F0aW9uIHdlIGNhbiBhc3N1bWUgd2UgZ290IHRocm91Z2ggYWxsIGJsb2NrZXJzXG4gICAgLy8gc28gd2UgY2FuIHN0YXJ0IGZyZXNoXG4gICAgbGV0IGJsb2NrZXJzID0gc3RhdGUuYmxvY2tlcnM7XG4gICAgaWYgKGJsb2NrZXJzLnNpemUgPiAwKSB7XG4gICAgICBibG9ja2VycyA9IG5ldyBNYXAoYmxvY2tlcnMpO1xuICAgICAgYmxvY2tlcnMuZm9yRWFjaCgoXywgaykgPT4gYmxvY2tlcnMuc2V0KGssIElETEVfQkxPQ0tFUikpO1xuICAgIH1cbiAgICAvLyBBbHdheXMgcmVzcGVjdCB0aGUgdXNlciBmbGFnLiAgT3RoZXJ3aXNlIGRvbid0IHJlc2V0IG9uIG11dGF0aW9uXG4gICAgLy8gc3VibWlzc2lvbiBuYXZpZ2F0aW9ucyB1bmxlc3MgdGhleSByZWRpcmVjdFxuICAgIGxldCBwcmV2ZW50U2Nyb2xsUmVzZXQgPSBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlIHx8IHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCAhPSBudWxsICYmIGlzTXV0YXRpb25NZXRob2Qoc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kKSAmJiAoKF9sb2NhdGlvbiRzdGF0ZTIgPSBsb2NhdGlvbi5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sb2NhdGlvbiRzdGF0ZTIuX2lzUmVkaXJlY3QpICE9PSB0cnVlO1xuICAgIGlmIChpbkZsaWdodERhdGFSb3V0ZXMpIHtcbiAgICAgIGRhdGFSb3V0ZXMgPSBpbkZsaWdodERhdGFSb3V0ZXM7XG4gICAgICBpbkZsaWdodERhdGFSb3V0ZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24pIDsgZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gQWN0aW9uLlBvcCkgOyBlbHNlIGlmIChwZW5kaW5nQWN0aW9uID09PSBBY3Rpb24uUHVzaCkge1xuICAgICAgaW5pdC5oaXN0b3J5LnB1c2gobG9jYXRpb24sIGxvY2F0aW9uLnN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEFjdGlvbi5SZXBsYWNlKSB7XG4gICAgICBpbml0Lmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbiwgbG9jYXRpb24uc3RhdGUpO1xuICAgIH1cbiAgICBsZXQgdmlld1RyYW5zaXRpb25PcHRzO1xuICAgIC8vIE9uIFBPUCwgZW5hYmxlIHRyYW5zaXRpb25zIGlmIHRoZXkgd2VyZSBlbmFibGVkIG9uIHRoZSBvcmlnaW5hbCBuYXZpZ2F0aW9uXG4gICAgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEFjdGlvbi5Qb3ApIHtcbiAgICAgIC8vIEZvcndhcmQgdGFrZXMgcHJlY2VkZW5jZSBzbyB0aGV5IGJlaGF2ZSBsaWtlIHRoZSBvcmlnaW5hbCBuYXZpZ2F0aW9uXG4gICAgICBsZXQgcHJpb3JQYXRocyA9IGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuZ2V0KHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIGlmIChwcmlvclBhdGhzICYmIHByaW9yUGF0aHMuaGFzKGxvY2F0aW9uLnBhdGhuYW1lKSkge1xuICAgICAgICB2aWV3VHJhbnNpdGlvbk9wdHMgPSB7XG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IGxvY2F0aW9uXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuaGFzKGxvY2F0aW9uLnBhdGhuYW1lKSkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgcHJldmlvdXMgZm9yd2FyZCBuYXYsIGFzc3VtZSB3ZSdyZSBwb3BwaW5nIGJhY2sgdG9cbiAgICAgICAgLy8gdGhlIG5ldyBsb2NhdGlvbiBhbmQgZW5hYmxlIGlmIHRoYXQgbG9jYXRpb24gcHJldmlvdXNseSBlbmFibGVkXG4gICAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyA9IHtcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogc3RhdGUubG9jYXRpb25cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQpIHtcbiAgICAgIC8vIFN0b3JlIHRoZSBhcHBsaWVkIHRyYW5zaXRpb24gb24gUFVTSC9SRVBMQUNFXG4gICAgICBsZXQgdG9QYXRocyA9IGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuZ2V0KHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIGlmICh0b1BhdGhzKSB7XG4gICAgICAgIHRvUGF0aHMuYWRkKGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvUGF0aHMgPSBuZXcgU2V0KFtsb2NhdGlvbi5wYXRobmFtZV0pO1xuICAgICAgICBhcHBsaWVkVmlld1RyYW5zaXRpb25zLnNldChzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSwgdG9QYXRocyk7XG4gICAgICB9XG4gICAgICB2aWV3VHJhbnNpdGlvbk9wdHMgPSB7XG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICAgIG5leHRMb2NhdGlvbjogbG9jYXRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKF9leHRlbmRzKHt9LCBuZXdTdGF0ZSwge1xuICAgICAgYWN0aW9uRGF0YSxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBoaXN0b3J5QWN0aW9uOiBwZW5kaW5nQWN0aW9uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBpbml0aWFsaXplZDogdHJ1ZSxcbiAgICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IGdldFNhdmVkU2Nyb2xsUG9zaXRpb24obG9jYXRpb24sIG5ld1N0YXRlLm1hdGNoZXMgfHwgc3RhdGUubWF0Y2hlcyksXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICBibG9ja2Vyc1xuICAgIH0pLCB7XG4gICAgICB2aWV3VHJhbnNpdGlvbk9wdHMsXG4gICAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyA9PT0gdHJ1ZVxuICAgIH0pO1xuICAgIC8vIFJlc2V0IHN0YXRlZnVsIG5hdmlnYXRpb24gdmFyc1xuICAgIHBlbmRpbmdBY3Rpb24gPSBBY3Rpb24uUG9wO1xuICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSBmYWxzZTtcbiAgICBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkID0gZmFsc2U7XG4gICAgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICAgIGNhbmNlbGxlZERlZmVycmVkUm91dGVzID0gW107XG4gICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzID0gW107XG4gIH1cbiAgLy8gVHJpZ2dlciBhIG5hdmlnYXRpb24gZXZlbnQsIHdoaWNoIGNhbiBlaXRoZXIgYmUgYSBudW1lcmljYWwgUE9QIG9yIGEgUFVTSFxuICAvLyByZXBsYWNlIHdpdGggYW4gb3B0aW9uYWwgc3VibWlzc2lvblxuICBhc3luYyBmdW5jdGlvbiBuYXZpZ2F0ZSh0bywgb3B0cykge1xuICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGluaXQuaGlzdG9yeS5nbyh0byk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVRvKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzLCBiYXNlbmFtZSwgZnV0dXJlLnY3X3ByZXBlbmRCYXNlbmFtZSwgdG8sIGZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aCwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5mcm9tUm91dGVJZCwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZWxhdGl2ZSk7XG4gICAgbGV0IHtcbiAgICAgIHBhdGgsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgZXJyb3JcbiAgICB9ID0gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKGZ1dHVyZS52N19ub3JtYWxpemVGb3JtTWV0aG9kLCBmYWxzZSwgbm9ybWFsaXplZFBhdGgsIG9wdHMpO1xuICAgIGxldCBjdXJyZW50TG9jYXRpb24gPSBzdGF0ZS5sb2NhdGlvbjtcbiAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oc3RhdGUubG9jYXRpb24sIHBhdGgsIG9wdHMgJiYgb3B0cy5zdGF0ZSk7XG4gICAgLy8gV2hlbiB1c2luZyBuYXZpZ2F0ZSBhcyBhIFBVU0gvUkVQTEFDRSB3ZSBhcmVuJ3QgcmVhZGluZyBhbiBhbHJlYWR5LWVuY29kZWRcbiAgICAvLyBVUkwgZnJvbSB3aW5kb3cubG9jYXRpb24sIHNvIHdlIG5lZWQgdG8gZW5jb2RlIGl0IGhlcmUgc28gdGhlIGJlaGF2aW9yXG4gICAgLy8gcmVtYWlucyB0aGUgc2FtZSBhcyBQT1AgYW5kIG5vbi1kYXRhLXJvdXRlciB1c2FnZXMuICBuZXcgVVJMKCkgZG9lcyBhbGxcbiAgICAvLyB0aGUgc2FtZSBlbmNvZGluZyB3ZSdkIGdldCBmcm9tIGEgaGlzdG9yeS5wdXNoU3RhdGUvd2luZG93LmxvY2F0aW9uIHJlYWRcbiAgICAvLyB3aXRob3V0IGhhdmluZyB0byB0b3VjaCBoaXN0b3J5XG4gICAgbmV4dExvY2F0aW9uID0gX2V4dGVuZHMoe30sIG5leHRMb2NhdGlvbiwgaW5pdC5oaXN0b3J5LmVuY29kZUxvY2F0aW9uKG5leHRMb2NhdGlvbikpO1xuICAgIGxldCB1c2VyUmVwbGFjZSA9IG9wdHMgJiYgb3B0cy5yZXBsYWNlICE9IG51bGwgPyBvcHRzLnJlcGxhY2UgOiB1bmRlZmluZWQ7XG4gICAgbGV0IGhpc3RvcnlBY3Rpb24gPSBBY3Rpb24uUHVzaDtcbiAgICBpZiAodXNlclJlcGxhY2UgPT09IHRydWUpIHtcbiAgICAgIGhpc3RvcnlBY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcbiAgICB9IGVsc2UgaWYgKHVzZXJSZXBsYWNlID09PSBmYWxzZSkgOyBlbHNlIGlmIChzdWJtaXNzaW9uICE9IG51bGwgJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpICYmIHN1Ym1pc3Npb24uZm9ybUFjdGlvbiA9PT0gc3RhdGUubG9jYXRpb24ucGF0aG5hbWUgKyBzdGF0ZS5sb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgIC8vIEJ5IGRlZmF1bHQgb24gc3VibWlzc2lvbnMgdG8gdGhlIGN1cnJlbnQgbG9jYXRpb24gd2UgUkVQTEFDRSBzbyB0aGF0XG4gICAgICAvLyB1c2VycyBkb24ndCBoYXZlIHRvIGRvdWJsZS1jbGljayB0aGUgYmFjayBidXR0b24gdG8gZ2V0IHRvIHRoZSBwcmlvclxuICAgICAgLy8gbG9jYXRpb24uICBJZiB0aGUgdXNlciByZWRpcmVjdHMgdG8gYSBkaWZmZXJlbnQgbG9jYXRpb24gZnJvbSB0aGVcbiAgICAgIC8vIGFjdGlvbi9sb2FkZXIgdGhpcyB3aWxsIGJlIGlnbm9yZWQgYW5kIHRoZSByZWRpcmVjdCB3aWxsIGJlIGEgUFVTSFxuICAgICAgaGlzdG9yeUFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgIH1cbiAgICBsZXQgcHJldmVudFNjcm9sbFJlc2V0ID0gb3B0cyAmJiBcInByZXZlbnRTY3JvbGxSZXNldFwiIGluIG9wdHMgPyBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgZmx1c2hTeW5jID0gKG9wdHMgJiYgb3B0cy51bnN0YWJsZV9mbHVzaFN5bmMpID09PSB0cnVlO1xuICAgIGxldCBibG9ja2VyS2V5ID0gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICB9KTtcbiAgICBpZiAoYmxvY2tlcktleSkge1xuICAgICAgLy8gUHV0IHRoZSBibG9ja2VyIGludG8gYSBibG9ja2VkIHN0YXRlXG4gICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgc3RhdGU6IFwiYmxvY2tlZFwiLFxuICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICBwcm9jZWVkKCkge1xuICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICAgICAgc3RhdGU6IFwicHJvY2VlZGluZ1wiLFxuICAgICAgICAgICAgcHJvY2VlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBTZW5kIHRoZSBzYW1lIG5hdmlnYXRpb24gdGhyb3VnaFxuICAgICAgICAgIG5hdmlnYXRlKHRvLCBvcHRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgbGV0IGJsb2NrZXJzID0gbmV3IE1hcChzdGF0ZS5ibG9ja2Vycyk7XG4gICAgICAgICAgYmxvY2tlcnMuc2V0KGJsb2NrZXJLZXksIElETEVfQkxPQ0tFUik7XG4gICAgICAgICAgdXBkYXRlU3RhdGUoe1xuICAgICAgICAgICAgYmxvY2tlcnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbmV4dExvY2F0aW9uLCB7XG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgLy8gU2VuZCB0aHJvdWdoIHRoZSBmb3JtRGF0YSBzZXJpYWxpemF0aW9uIGVycm9yIGlmIHdlIGhhdmUgb25lIHNvIHdlIGNhblxuICAgICAgLy8gcmVuZGVyIGF0IHRoZSByaWdodCBlcnJvciBib3VuZGFyeSBhZnRlciB3ZSBtYXRjaCByb3V0ZXNcbiAgICAgIHBlbmRpbmdFcnJvcjogZXJyb3IsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICByZXBsYWNlOiBvcHRzICYmIG9wdHMucmVwbGFjZSxcbiAgICAgIGVuYWJsZVZpZXdUcmFuc2l0aW9uOiBvcHRzICYmIG9wdHMudW5zdGFibGVfdmlld1RyYW5zaXRpb24sXG4gICAgICBmbHVzaFN5bmNcbiAgICB9KTtcbiAgfVxuICAvLyBSZXZhbGlkYXRlIGFsbCBjdXJyZW50IGxvYWRlcnMuICBJZiBhIG5hdmlnYXRpb24gaXMgaW4gcHJvZ3Jlc3Mgb3IgaWYgdGhpc1xuICAvLyBpcyBpbnRlcnJ1cHRlZCBieSBhIG5hdmlnYXRpb24sIGFsbG93IHRoaXMgdG8gXCJzdWNjZWVkXCIgYnkgY2FsbGluZyBhbGxcbiAgLy8gbG9hZGVycyBkdXJpbmcgdGhlIG5leHQgbG9hZGVyIHJvdW5kXG4gIGZ1bmN0aW9uIHJldmFsaWRhdGUoKSB7XG4gICAgaW50ZXJydXB0QWN0aXZlTG9hZHMoKTtcbiAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICByZXZhbGlkYXRpb246IFwibG9hZGluZ1wiXG4gICAgfSk7XG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IHN1Ym1pdHRpbmcgYW4gYWN0aW9uLCB3ZSBkb24ndCBuZWVkIHRvIHN0YXJ0IGEgbmV3XG4gICAgLy8gbmF2aWdhdGlvbiwgd2UnbGwganVzdCBsZXQgdGhlIGZvbGxvdyB1cCBsb2FkZXIgZXhlY3V0aW9uIGNhbGwgYWxsIGxvYWRlcnNcbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJzdWJtaXR0aW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGluIGFuIGlkbGUgc3RhdGUsIHN0YXJ0IGEgbmV3IG5hdmlnYXRpb24gZm9yIHRoZSBjdXJyZW50XG4gICAgLy8gYWN0aW9uL2xvY2F0aW9uIGFuZCBtYXJrIGl0IGFzIHVuaW50ZXJydXB0ZWQsIHdoaWNoIHdpbGwgc2tpcCB0aGUgaGlzdG9yeVxuICAgIC8vIHVwZGF0ZSBpbiBjb21wbGV0ZU5hdmlnYXRpb25cbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIHN0YXJ0TmF2aWdhdGlvbihzdGF0ZS5oaXN0b3J5QWN0aW9uLCBzdGF0ZS5sb2NhdGlvbiwge1xuICAgICAgICBzdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb246IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIGlmIHdlJ3JlIGN1cnJlbnRseSBpbiBhIGxvYWRpbmcgc3RhdGUsIGp1c3Qgc3RhcnQgYSBuZXdcbiAgICAvLyBuYXZpZ2F0aW9uIHRvIHRoZSBuYXZpZ2F0aW9uLmxvY2F0aW9uIGJ1dCBkbyBub3QgdHJpZ2dlciBhbiB1bmludGVycnVwdGVkXG4gICAgLy8gcmV2YWxpZGF0aW9uIHNvIHRoYXQgaGlzdG9yeSBjb3JyZWN0bHkgdXBkYXRlcyBvbmNlIHRoZSBuYXZpZ2F0aW9uIGNvbXBsZXRlc1xuICAgIHN0YXJ0TmF2aWdhdGlvbihwZW5kaW5nQWN0aW9uIHx8IHN0YXRlLmhpc3RvcnlBY3Rpb24sIHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sIHtcbiAgICAgIG92ZXJyaWRlTmF2aWdhdGlvbjogc3RhdGUubmF2aWdhdGlvblxuICAgIH0pO1xuICB9XG4gIC8vIFN0YXJ0IGEgbmF2aWdhdGlvbiB0byB0aGUgZ2l2ZW4gYWN0aW9uL2xvY2F0aW9uLiAgQ2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhXG4gIC8vIG92ZXJyaWRlTmF2aWdhdGlvbiB3aGljaCB3aWxsIG92ZXJyaWRlIHRoZSBub3JtYWxMb2FkIGluIHRoZSBjYXNlIG9mIGEgcmVkaXJlY3RcbiAgLy8gbmF2aWdhdGlvblxuICBhc3luYyBmdW5jdGlvbiBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbG9jYXRpb24sIG9wdHMpIHtcbiAgICAvLyBBYm9ydCBhbnkgaW4tcHJvZ3Jlc3MgbmF2aWdhdGlvbnMgYW5kIHN0YXJ0IGEgbmV3IG9uZS4gVW5zZXQgYW55IG9uZ29pbmdcbiAgICAvLyB1bmludGVycnVwdGVkIHJldmFsaWRhdGlvbnMgdW5sZXNzIHRvbGQgb3RoZXJ3aXNlLCBzaW5jZSB3ZSB3YW50IHRoaXNcbiAgICAvLyBuZXcgbmF2aWdhdGlvbiB0byB1cGRhdGUgaGlzdG9yeSBub3JtYWxseVxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuICAgIHBlbmRpbmdBY3Rpb24gPSBoaXN0b3J5QWN0aW9uO1xuICAgIGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9IChvcHRzICYmIG9wdHMuc3RhcnRVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uKSA9PT0gdHJ1ZTtcbiAgICAvLyBTYXZlIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBldmVyeSB0aW1lIHdlIHN0YXJ0IGEgbmV3IG5hdmlnYXRpb24sXG4gICAgLy8gYW5kIHRyYWNrIHdoZXRoZXIgd2Ugc2hvdWxkIHJlc2V0IHNjcm9sbCBvbiBjb21wbGV0aW9uXG4gICAgc2F2ZVNjcm9sbFBvc2l0aW9uKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gKG9wdHMgJiYgb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQpID09PSB0cnVlO1xuICAgIHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgPSAob3B0cyAmJiBvcHRzLmVuYWJsZVZpZXdUcmFuc2l0aW9uKSA9PT0gdHJ1ZTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbG9hZGluZ05hdmlnYXRpb24gPSBvcHRzICYmIG9wdHMub3ZlcnJpZGVOYXZpZ2F0aW9uO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gICAgbGV0IGZsdXNoU3luYyA9IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZTtcbiAgICAvLyBTaG9ydCBjaXJjdWl0IHdpdGggYSA0MDQgb24gdGhlIHJvb3QgZXJyb3IgYm91bmRhcnkgaWYgd2UgbWF0Y2ggbm90aGluZ1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICB9KTtcbiAgICAgIGxldCB7XG4gICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgcm91dGVcbiAgICAgIH0gPSBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKHJvdXRlc1RvVXNlKTtcbiAgICAgIC8vIENhbmNlbCBhbGwgcGVuZGluZyBkZWZlcnJlZCBvbiA0MDRzIHNpbmNlIHdlIGRvbid0IGtlZXAgYW55IHJvdXRlc1xuICAgICAgY2FuY2VsQWN0aXZlRGVmZXJyZWRzKCk7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIHtcbiAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3JcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBmbHVzaFN5bmNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIGl0J3Mgb25seSBhIGhhc2ggY2hhbmdlIGFuZCBub3QgYSByZXZhbGlkYXRpb24gb3JcbiAgICAvLyBtdXRhdGlvbiBzdWJtaXNzaW9uLlxuICAgIC8vXG4gICAgLy8gSWdub3JlIG9uIGluaXRpYWwgcGFnZSBsb2FkcyBiZWNhdXNlIHNpbmNlIHRoZSBpbml0aWFsIGxvYWQgd2lsbCBhbHdheXNcbiAgICAvLyBiZSBcInNhbWUgaGFzaFwiLiAgRm9yIGV4YW1wbGUsIG9uIC9wYWdlI2hhc2ggYW5kIHN1Ym1pdCBhIDxGb3JtIG1ldGhvZD1cInBvc3RcIj5cbiAgICAvLyB3aGljaCB3aWxsIGRlZmF1bHQgdG8gYSBuYXZpZ2F0aW9uIHRvIC9wYWdlXG4gICAgaWYgKHN0YXRlLmluaXRpYWxpemVkICYmICFpc1JldmFsaWRhdGlvblJlcXVpcmVkICYmIGlzSGFzaENoYW5nZU9ubHkoc3RhdGUubG9jYXRpb24sIGxvY2F0aW9uKSAmJiAhKG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qob3B0cy5zdWJtaXNzaW9uLmZvcm1NZXRob2QpKSkge1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7XG4gICAgICAgIG1hdGNoZXNcbiAgICAgIH0sIHtcbiAgICAgICAgZmx1c2hTeW5jXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgY29udHJvbGxlci9SZXF1ZXN0IGZvciB0aGlzIG5hdmlnYXRpb25cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IHJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChpbml0Lmhpc3RvcnksIGxvY2F0aW9uLCBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuc2lnbmFsLCBvcHRzICYmIG9wdHMuc3VibWlzc2lvbik7XG4gICAgbGV0IHBlbmRpbmdBY3Rpb25EYXRhO1xuICAgIGxldCBwZW5kaW5nRXJyb3I7XG4gICAgaWYgKG9wdHMgJiYgb3B0cy5wZW5kaW5nRXJyb3IpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgYSBwZW5kaW5nRXJyb3IsIGl0IG1lYW5zIHRoZSB1c2VyIGF0dGVtcHRlZCBhIEdFVCBzdWJtaXNzaW9uXG4gICAgICAvLyB3aXRoIGJpbmFyeSBGb3JtRGF0YSBzbyBhc3NpZ24gaGVyZSBhbmQgc2tpcCB0byBoYW5kbGVMb2FkZXJzLiAgVGhhdFxuICAgICAgLy8gd2F5IHdlIGhhbmRsZSBjYWxsaW5nIGxvYWRlcnMgYWJvdmUgdGhlIGJvdW5kYXJ5IGV0Yy4gIEl0J3Mgbm90IHJlYWxseVxuICAgICAgLy8gZGlmZmVyZW50IGZyb20gYW4gYWN0aW9uRXJyb3IgaW4gdGhhdCBzZW5zZS5cbiAgICAgIHBlbmRpbmdFcnJvciA9IHtcbiAgICAgICAgW2ZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcykucm91dGUuaWRdOiBvcHRzLnBlbmRpbmdFcnJvclxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qob3B0cy5zdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICAvLyBDYWxsIGFjdGlvbiBpZiB3ZSByZWNlaXZlZCBhbiBhY3Rpb24gc3VibWlzc2lvblxuICAgICAgbGV0IGFjdGlvbk91dHB1dCA9IGF3YWl0IGhhbmRsZUFjdGlvbihyZXF1ZXN0LCBsb2NhdGlvbiwgb3B0cy5zdWJtaXNzaW9uLCBtYXRjaGVzLCB7XG4gICAgICAgIHJlcGxhY2U6IG9wdHMucmVwbGFjZSxcbiAgICAgICAgZmx1c2hTeW5jXG4gICAgICB9KTtcbiAgICAgIGlmIChhY3Rpb25PdXRwdXQuc2hvcnRDaXJjdWl0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGVuZGluZ0FjdGlvbkRhdGEgPSBhY3Rpb25PdXRwdXQucGVuZGluZ0FjdGlvbkRhdGE7XG4gICAgICBwZW5kaW5nRXJyb3IgPSBhY3Rpb25PdXRwdXQucGVuZGluZ0FjdGlvbkVycm9yO1xuICAgICAgbG9hZGluZ05hdmlnYXRpb24gPSBnZXRMb2FkaW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgb3B0cy5zdWJtaXNzaW9uKTtcbiAgICAgIGZsdXNoU3luYyA9IGZhbHNlO1xuICAgICAgLy8gQ3JlYXRlIGEgR0VUIHJlcXVlc3QgZm9yIHRoZSBsb2FkZXJzXG4gICAgICByZXF1ZXN0ID0gbmV3IFJlcXVlc3QocmVxdWVzdC51cmwsIHtcbiAgICAgICAgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIENhbGwgbG9hZGVyc1xuICAgIGxldCB7XG4gICAgICBzaG9ydENpcmN1aXRlZCxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnNcbiAgICB9ID0gYXdhaXQgaGFuZGxlTG9hZGVycyhyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgbG9hZGluZ05hdmlnYXRpb24sIG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uLCBvcHRzICYmIG9wdHMuZmV0Y2hlclN1Ym1pc3Npb24sIG9wdHMgJiYgb3B0cy5yZXBsYWNlLCBvcHRzICYmIG9wdHMuaW5pdGlhbEh5ZHJhdGlvbiA9PT0gdHJ1ZSwgZmx1c2hTeW5jLCBwZW5kaW5nQWN0aW9uRGF0YSwgcGVuZGluZ0Vycm9yKTtcbiAgICBpZiAoc2hvcnRDaXJjdWl0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ2xlYW4gdXAgbm93IHRoYXQgdGhlIGFjdGlvbi9sb2FkZXJzIGhhdmUgY29tcGxldGVkLiAgRG9uJ3QgY2xlYW4gdXAgaWZcbiAgICAvLyB3ZSBzaG9ydCBjaXJjdWl0ZWQgYmVjYXVzZSBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgd2lsbCBoYXZlIGFscmVhZHlcbiAgICAvLyBiZWVuIGFzc2lnbmVkIHRvIGEgbmV3IGNvbnRyb2xsZXIgZm9yIHRoZSBuZXh0IG5hdmlnYXRpb25cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwgX2V4dGVuZHMoe1xuICAgICAgbWF0Y2hlc1xuICAgIH0sIHBlbmRpbmdBY3Rpb25EYXRhID8ge1xuICAgICAgYWN0aW9uRGF0YTogcGVuZGluZ0FjdGlvbkRhdGFcbiAgICB9IDoge30sIHtcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnNcbiAgICB9KSk7XG4gIH1cbiAgLy8gQ2FsbCB0aGUgYWN0aW9uIG1hdGNoZWQgYnkgdGhlIGxlYWYgcm91dGUgZm9yIHRoaXMgbmF2aWdhdGlvbiBhbmQgaGFuZGxlXG4gIC8vIHJlZGlyZWN0cy9lcnJvcnNcbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlQWN0aW9uKHJlcXVlc3QsIGxvY2F0aW9uLCBzdWJtaXNzaW9uLCBtYXRjaGVzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuICAgIC8vIFB1dCB1cyBpbiBhIHN1Ym1pdHRpbmcgc3RhdGVcbiAgICBsZXQgbmF2aWdhdGlvbiA9IGdldFN1Ym1pdHRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKTtcbiAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICBuYXZpZ2F0aW9uXG4gICAgfSwge1xuICAgICAgZmx1c2hTeW5jOiBvcHRzLmZsdXNoU3luYyA9PT0gdHJ1ZVxuICAgIH0pO1xuICAgIC8vIENhbGwgb3VyIGFjdGlvbiBhbmQgZ2V0IHRoZSByZXN1bHRcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBhY3Rpb25NYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKTtcbiAgICBpZiAoIWFjdGlvbk1hdGNoLnJvdXRlLmFjdGlvbiAmJiAhYWN0aW9uTWF0Y2gucm91dGUubGF6eSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgICByb3V0ZUlkOiBhY3Rpb25NYXRjaC5yb3V0ZS5pZFxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlck9yQWN0aW9uKFwiYWN0aW9uXCIsIHJlcXVlc3QsIGFjdGlvbk1hdGNoLCBtYXRjaGVzLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzLCBiYXNlbmFtZSwgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoKTtcbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2hvcnRDaXJjdWl0ZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IHJlcGxhY2U7XG4gICAgICBpZiAob3B0cyAmJiBvcHRzLnJlcGxhY2UgIT0gbnVsbCkge1xuICAgICAgICByZXBsYWNlID0gb3B0cy5yZXBsYWNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgZGlkbid0IGV4cGxpY2l0eSBpbmRpY2F0ZSByZXBsYWNlIGJlaGF2aW9yLCByZXBsYWNlIGlmXG4gICAgICAgIC8vIHdlIHJlZGlyZWN0ZWQgdG8gdGhlIGV4YWN0IHNhbWUgbG9jYXRpb24gd2UncmUgY3VycmVudGx5IGF0IHRvIGF2b2lkXG4gICAgICAgIC8vIGRvdWJsZSBiYWNrLWJ1dHRvbnNcbiAgICAgICAgcmVwbGFjZSA9IHJlc3VsdC5sb2NhdGlvbiA9PT0gc3RhdGUubG9jYXRpb24ucGF0aG5hbWUgKyBzdGF0ZS5sb2NhdGlvbi5zZWFyY2g7XG4gICAgICB9XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgcmVzdWx0LCB7XG4gICAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAgIHJlcGxhY2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2hvcnRDaXJjdWl0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFN0b3JlIG9mZiB0aGUgcGVuZGluZyBlcnJvciAtIHdlIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hpY2ggbG9hZGVyc1xuICAgICAgLy8gdG8gY2FsbCBhbmQgd2lsbCBjb21taXQgaXQgd2hlbiB3ZSBjb21wbGV0ZSB0aGUgbmF2aWdhdGlvblxuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGFjdGlvbk1hdGNoLnJvdXRlLmlkKTtcbiAgICAgIC8vIEJ5IGRlZmF1bHQsIGFsbCBzdWJtaXNzaW9ucyBhcmUgUkVQTEFDRSBuYXZpZ2F0aW9ucywgYnV0IGlmIHRoZVxuICAgICAgLy8gYWN0aW9uIHRocmV3IGFuIGVycm9yIHRoYXQnbGwgYmUgcmVuZGVyZWQgaW4gYW4gZXJyb3JFbGVtZW50LCB3ZSBmYWxsXG4gICAgICAvLyBiYWNrIHRvIFBVU0ggc28gdGhhdCB0aGUgdXNlciBjYW4gdXNlIHRoZSBiYWNrIGJ1dHRvbiB0byBnZXQgYmFjayB0b1xuICAgICAgLy8gdGhlIHByZS1zdWJtaXNzaW9uIGZvcm0gbG9jYXRpb24gdG8gdHJ5IGFnYWluXG4gICAgICBpZiAoKG9wdHMgJiYgb3B0cy5yZXBsYWNlKSAhPT0gdHJ1ZSkge1xuICAgICAgICBwZW5kaW5nQWN0aW9uID0gQWN0aW9uLlB1c2g7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBTZW5kIGJhY2sgYW4gZW1wdHkgb2JqZWN0IHdlIGNhbiB1c2UgdG8gY2xlYXIgb3V0IGFueSBwcmlvciBhY3Rpb25EYXRhXG4gICAgICAgIHBlbmRpbmdBY3Rpb25EYXRhOiB7fSxcbiAgICAgICAgcGVuZGluZ0FjdGlvbkVycm9yOiB7XG4gICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3JcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHtcbiAgICAgICAgdHlwZTogXCJkZWZlci1hY3Rpb25cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwZW5kaW5nQWN0aW9uRGF0YToge1xuICAgICAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLy8gQ2FsbCBhbGwgYXBwbGljYWJsZSBsb2FkZXJzIGZvciB0aGUgZ2l2ZW4gbWF0Y2hlcywgaGFuZGxpbmcgcmVkaXJlY3RzLFxuICAvLyBlcnJvcnMsIGV0Yy5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVycyhyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgb3ZlcnJpZGVOYXZpZ2F0aW9uLCBzdWJtaXNzaW9uLCBmZXRjaGVyU3VibWlzc2lvbiwgcmVwbGFjZSwgaW5pdGlhbEh5ZHJhdGlvbiwgZmx1c2hTeW5jLCBwZW5kaW5nQWN0aW9uRGF0YSwgcGVuZGluZ0Vycm9yKSB7XG4gICAgLy8gRmlndXJlIG91dCB0aGUgcmlnaHQgbmF2aWdhdGlvbiB3ZSB3YW50IHRvIHVzZSBmb3IgZGF0YSBsb2FkaW5nXG4gICAgbGV0IGxvYWRpbmdOYXZpZ2F0aW9uID0gb3ZlcnJpZGVOYXZpZ2F0aW9uIHx8IGdldExvYWRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKTtcbiAgICAvLyBJZiB0aGlzIHdhcyBhIHJlZGlyZWN0IGZyb20gYW4gYWN0aW9uIHdlIGRvbid0IGhhdmUgYSBcInN1Ym1pc3Npb25cIiBidXRcbiAgICAvLyB3ZSBoYXZlIGl0IG9uIHRoZSBsb2FkaW5nIG5hdmlnYXRpb24gc28gdXNlIHRoYXQgaWYgYXZhaWxhYmxlXG4gICAgbGV0IGFjdGl2ZVN1Ym1pc3Npb24gPSBzdWJtaXNzaW9uIHx8IGZldGNoZXJTdWJtaXNzaW9uIHx8IGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihsb2FkaW5nTmF2aWdhdGlvbik7XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IFttYXRjaGVzVG9Mb2FkLCByZXZhbGlkYXRpbmdGZXRjaGVyc10gPSBnZXRNYXRjaGVzVG9Mb2FkKGluaXQuaGlzdG9yeSwgc3RhdGUsIG1hdGNoZXMsIGFjdGl2ZVN1Ym1pc3Npb24sIGxvY2F0aW9uLCBmdXR1cmUudjdfcGFydGlhbEh5ZHJhdGlvbiAmJiBpbml0aWFsSHlkcmF0aW9uID09PSB0cnVlLCBpc1JldmFsaWRhdGlvblJlcXVpcmVkLCBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcywgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLCBkZWxldGVkRmV0Y2hlcnMsIGZldGNoTG9hZE1hdGNoZXMsIGZldGNoUmVkaXJlY3RJZHMsIHJvdXRlc1RvVXNlLCBiYXNlbmFtZSwgcGVuZGluZ0FjdGlvbkRhdGEsIHBlbmRpbmdFcnJvcik7XG4gICAgLy8gQ2FuY2VsIHBlbmRpbmcgZGVmZXJyZWRzIGZvciBuby1sb25nZXItbWF0Y2hlZCByb3V0ZXMgb3Igcm91dGVzIHdlJ3JlXG4gICAgLy8gYWJvdXQgdG8gcmVsb2FkLiAgTm90ZSB0aGF0IGlmIHRoaXMgaXMgYW4gYWN0aW9uIHJlbG9hZCB3ZSB3b3VsZCBoYXZlXG4gICAgLy8gYWxyZWFkeSBjYW5jZWxsZWQgYWxsIHBlbmRpbmcgZGVmZXJyZWRzIHNvIHRoaXMgd291bGQgYmUgYSBuby1vcFxuICAgIGNhbmNlbEFjdGl2ZURlZmVycmVkcyhyb3V0ZUlkID0+ICEobWF0Y2hlcyAmJiBtYXRjaGVzLnNvbWUobSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSkgfHwgbWF0Y2hlc1RvTG9hZCAmJiBtYXRjaGVzVG9Mb2FkLnNvbWUobSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPSArK2luY3JlbWVudGluZ0xvYWRJZDtcbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIHdlIGhhdmUgbm8gbG9hZGVycyB0byBydW5cbiAgICBpZiAobWF0Y2hlc1RvTG9hZC5sZW5ndGggPT09IDAgJiYgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsZXQgdXBkYXRlZEZldGNoZXJzID0gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpO1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCBfZXh0ZW5kcyh7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAvLyBDb21taXQgcGVuZGluZyBlcnJvciBpZiB3ZSdyZSBzaG9ydCBjaXJjdWl0aW5nXG4gICAgICAgIGVycm9yczogcGVuZGluZ0Vycm9yIHx8IG51bGxcbiAgICAgIH0sIHBlbmRpbmdBY3Rpb25EYXRhID8ge1xuICAgICAgICBhY3Rpb25EYXRhOiBwZW5kaW5nQWN0aW9uRGF0YVxuICAgICAgfSA6IHt9LCB1cGRhdGVkRmV0Y2hlcnMgPyB7XG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSA6IHt9KSwge1xuICAgICAgICBmbHVzaFN5bmNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2hvcnRDaXJjdWl0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIElmIHRoaXMgaXMgYW4gdW5pbnRlcnJ1cHRlZCByZXZhbGlkYXRpb24sIHdlIHJlbWFpbiBpbiBvdXIgY3VycmVudCBpZGxlXG4gICAgLy8gc3RhdGUuICBJZiBub3QsIHdlIG5lZWQgdG8gc3dpdGNoIHRvIG91ciBsb2FkaW5nIHN0YXRlIGFuZCBsb2FkIGRhdGEsXG4gICAgLy8gcHJlc2VydmluZyBhbnkgbmV3IGFjdGlvbiBkYXRhIG9yIGV4aXN0aW5nIGFjdGlvbiBkYXRhIChpbiB0aGUgY2FzZSBvZlxuICAgIC8vIGEgcmV2YWxpZGF0aW9uIGludGVycnVwdGluZyBhbiBhY3Rpb25SZWxvYWQpXG4gICAgLy8gSWYgd2UgaGF2ZSBwYXJ0aWFsSHlkcmF0aW9uIGVuYWJsZWQsIHRoZW4gZG9uJ3QgdXBkYXRlIHRoZSBzdGF0ZSBmb3IgdGhlXG4gICAgLy8gaW5pdGlhbCBkYXRhIGxvYWQgc2luY2UgaXQncyBub3QgYSBcIm5hdmlnYXRpb25cIlxuICAgIGlmICghaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uICYmICghZnV0dXJlLnY3X3BhcnRpYWxIeWRyYXRpb24gfHwgIWluaXRpYWxIeWRyYXRpb24pKSB7XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKHJmID0+IHtcbiAgICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQocmYua2V5KTtcbiAgICAgICAgbGV0IHJldmFsaWRhdGluZ0ZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcih1bmRlZmluZWQsIGZldGNoZXIgPyBmZXRjaGVyLmRhdGEgOiB1bmRlZmluZWQpO1xuICAgICAgICBzdGF0ZS5mZXRjaGVycy5zZXQocmYua2V5LCByZXZhbGlkYXRpbmdGZXRjaGVyKTtcbiAgICAgIH0pO1xuICAgICAgbGV0IGFjdGlvbkRhdGEgPSBwZW5kaW5nQWN0aW9uRGF0YSB8fCBzdGF0ZS5hY3Rpb25EYXRhO1xuICAgICAgdXBkYXRlU3RhdGUoX2V4dGVuZHMoe1xuICAgICAgICBuYXZpZ2F0aW9uOiBsb2FkaW5nTmF2aWdhdGlvblxuICAgICAgfSwgYWN0aW9uRGF0YSA/IE9iamVjdC5rZXlzKGFjdGlvbkRhdGEpLmxlbmd0aCA9PT0gMCA/IHtcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbFxuICAgICAgfSA6IHtcbiAgICAgICAgYWN0aW9uRGF0YVxuICAgICAgfSA6IHt9LCByZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGggPiAwID8ge1xuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICAgIH0gOiB7fSksIHtcbiAgICAgICAgZmx1c2hTeW5jXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaChyZiA9PiB7XG4gICAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMocmYua2V5KSkge1xuICAgICAgICBhYm9ydEZldGNoZXIocmYua2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZi5jb250cm9sbGVyKSB7XG4gICAgICAgIC8vIEZldGNoZXJzIHVzZSBhbiBpbmRlcGVuZGVudCBBYm9ydENvbnRyb2xsZXIgc28gdGhhdCBhYm9ydGluZyBhIGZldGNoZXJcbiAgICAgICAgLy8gKHZpYSBkZWxldGVGZXRjaGVyKSBkb2VzIG5vdCBhYm9ydCB0aGUgdHJpZ2dlcmluZyBuYXZpZ2F0aW9uIHRoYXRcbiAgICAgICAgLy8gdHJpZ2dlcmVkIHRoZSByZXZhbGlkYXRpb25cbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5zZXQocmYua2V5LCByZi5jb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBQcm94eSBuYXZpZ2F0aW9uIGFib3J0IHRocm91Z2ggdG8gcmV2YWxpZGF0aW9uIGZldGNoZXJzXG4gICAgbGV0IGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyA9ICgpID0+IHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goZiA9PiBhYm9ydEZldGNoZXIoZi5rZXkpKTtcbiAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyKSB7XG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMpO1xuICAgIH1cbiAgICBsZXQge1xuICAgICAgcmVzdWx0cyxcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICBmZXRjaGVyUmVzdWx0c1xuICAgIH0gPSBhd2FpdCBjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEoc3RhdGUubWF0Y2hlcywgbWF0Y2hlcywgbWF0Y2hlc1RvTG9hZCwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsIHJlcXVlc3QpO1xuICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaG9ydENpcmN1aXRlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ2xlYW4gdXAgX2FmdGVyXyBsb2FkZXJzIGhhdmUgY29tcGxldGVkLiAgRG9uJ3QgY2xlYW4gdXAgaWYgd2Ugc2hvcnRcbiAgICAvLyBjaXJjdWl0ZWQgYmVjYXVzZSBmZXRjaENvbnRyb2xsZXJzIHdvdWxkIGhhdmUgYmVlbiBhYm9ydGVkIGFuZFxuICAgIC8vIHJlYXNzaWduZWQgdG8gbmV3IGNvbnRyb2xsZXJzIGZvciB0aGUgbmV4dCBuYXZpZ2F0aW9uXG4gICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcikge1xuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zKTtcbiAgICB9XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaChyZiA9PiBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShyZi5rZXkpKTtcbiAgICAvLyBJZiBhbnkgbG9hZGVycyByZXR1cm5lZCBhIHJlZGlyZWN0IFJlc3BvbnNlLCBzdGFydCBhIG5ldyBSRVBMQUNFIG5hdmlnYXRpb25cbiAgICBsZXQgcmVkaXJlY3QgPSBmaW5kUmVkaXJlY3QocmVzdWx0cyk7XG4gICAgaWYgKHJlZGlyZWN0KSB7XG4gICAgICBpZiAocmVkaXJlY3QuaWR4ID49IG1hdGNoZXNUb0xvYWQubGVuZ3RoKSB7XG4gICAgICAgIC8vIElmIHRoaXMgcmVkaXJlY3QgY2FtZSBmcm9tIGEgZmV0Y2hlciBtYWtlIHN1cmUgd2UgbWFyayBpdCBpblxuICAgICAgICAvLyBmZXRjaFJlZGlyZWN0SWRzIHNvIGl0IGRvZXNuJ3QgZ2V0IHJldmFsaWRhdGVkIG9uIHRoZSBuZXh0IHNldCBvZlxuICAgICAgICAvLyBsb2FkZXIgZXhlY3V0aW9uc1xuICAgICAgICBsZXQgZmV0Y2hlcktleSA9IHJldmFsaWRhdGluZ0ZldGNoZXJzW3JlZGlyZWN0LmlkeCAtIG1hdGNoZXNUb0xvYWQubGVuZ3RoXS5rZXk7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKGZldGNoZXJLZXkpO1xuICAgICAgfVxuICAgICAgYXdhaXQgc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oc3RhdGUsIHJlZGlyZWN0LnJlc3VsdCwge1xuICAgICAgICByZXBsYWNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNob3J0Q2lyY3VpdGVkOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBQcm9jZXNzIGFuZCBjb21taXQgb3V0cHV0IGZyb20gbG9hZGVyc1xuICAgIGxldCB7XG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzXG4gICAgfSA9IHByb2Nlc3NMb2FkZXJEYXRhKHN0YXRlLCBtYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCBsb2FkZXJSZXN1bHRzLCBwZW5kaW5nRXJyb3IsIHJldmFsaWRhdGluZ0ZldGNoZXJzLCBmZXRjaGVyUmVzdWx0cywgYWN0aXZlRGVmZXJyZWRzKTtcbiAgICAvLyBXaXJlIHVwIHN1YnNjcmliZXJzIHRvIHVwZGF0ZSBsb2FkZXJEYXRhIGFzIHByb21pc2VzIHNldHRsZVxuICAgIGFjdGl2ZURlZmVycmVkcy5mb3JFYWNoKChkZWZlcnJlZERhdGEsIHJvdXRlSWQpID0+IHtcbiAgICAgIGRlZmVycmVkRGF0YS5zdWJzY3JpYmUoYWJvcnRlZCA9PiB7XG4gICAgICAgIC8vIE5vdGU6IE5vIG5lZWQgdG8gdXBkYXRlU3RhdGUgaGVyZSBzaW5jZSB0aGUgVHJhY2tlZFByb21pc2Ugb25cbiAgICAgICAgLy8gbG9hZGVyRGF0YSBpcyBzdGFibGUgYWNyb3NzIHJlc29sdmUvcmVqZWN0XG4gICAgICAgIC8vIFJlbW92ZSB0aGlzIGluc3RhbmNlIGlmIHdlIHdlcmUgYWJvcnRlZCBvciBpZiBwcm9taXNlcyBoYXZlIHNldHRsZWRcbiAgICAgICAgaWYgKGFib3J0ZWQgfHwgZGVmZXJyZWREYXRhLmRvbmUpIHtcbiAgICAgICAgICBhY3RpdmVEZWZlcnJlZHMuZGVsZXRlKHJvdXRlSWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBEdXJpbmcgcGFydGlhbCBoeWRyYXRpb24sIHByZXNlcnZlIFNTUiBlcnJvcnMgZm9yIHJvdXRlcyB0aGF0IGRvbid0IHJlLXJ1blxuICAgIGlmIChmdXR1cmUudjdfcGFydGlhbEh5ZHJhdGlvbiAmJiBpbml0aWFsSHlkcmF0aW9uICYmIHN0YXRlLmVycm9ycykge1xuICAgICAgT2JqZWN0LmVudHJpZXMoc3RhdGUuZXJyb3JzKS5maWx0ZXIoX3JlZjIgPT4ge1xuICAgICAgICBsZXQgW2lkXSA9IF9yZWYyO1xuICAgICAgICByZXR1cm4gIW1hdGNoZXNUb0xvYWQuc29tZShtID0+IG0ucm91dGUuaWQgPT09IGlkKTtcbiAgICAgIH0pLmZvckVhY2goX3JlZjMgPT4ge1xuICAgICAgICBsZXQgW3JvdXRlSWQsIGVycm9yXSA9IF9yZWYzO1xuICAgICAgICBlcnJvcnMgPSBPYmplY3QuYXNzaWduKGVycm9ycyB8fCB7fSwge1xuICAgICAgICAgIFtyb3V0ZUlkXTogZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IHVwZGF0ZWRGZXRjaGVycyA9IG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKTtcbiAgICBsZXQgZGlkQWJvcnRGZXRjaExvYWRzID0gYWJvcnRTdGFsZUZldGNoTG9hZHMocGVuZGluZ05hdmlnYXRpb25Mb2FkSWQpO1xuICAgIGxldCBzaG91bGRVcGRhdGVGZXRjaGVycyA9IHVwZGF0ZWRGZXRjaGVycyB8fCBkaWRBYm9ydEZldGNoTG9hZHMgfHwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID4gMDtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9yc1xuICAgIH0sIHNob3VsZFVwZGF0ZUZldGNoZXJzID8ge1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSA6IHt9KTtcbiAgfVxuICAvLyBUcmlnZ2VyIGEgZmV0Y2hlciBsb2FkL3N1Ym1pdCBmb3IgdGhlIGdpdmVuIGZldGNoZXIga2V5XG4gIGZ1bmN0aW9uIGZldGNoKGtleSwgcm91dGVJZCwgaHJlZiwgb3B0cykge1xuICAgIGlmIChpc1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicm91dGVyLmZldGNoKCkgd2FzIGNhbGxlZCBkdXJpbmcgdGhlIHNlcnZlciByZW5kZXIsIGJ1dCBpdCBzaG91bGRuJ3QgYmUuIFwiICsgXCJZb3UgYXJlIGxpa2VseSBjYWxsaW5nIGEgdXNlRmV0Y2hlcigpIG1ldGhvZCBpbiB0aGUgYm9keSBvZiB5b3VyIGNvbXBvbmVudC4gXCIgKyBcIlRyeSBtb3ZpbmcgaXQgdG8gYSB1c2VFZmZlY3Qgb3IgYSBjYWxsYmFjay5cIik7XG4gICAgfVxuICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICBsZXQgZmx1c2hTeW5jID0gKG9wdHMgJiYgb3B0cy51bnN0YWJsZV9mbHVzaFN5bmMpID09PSB0cnVlO1xuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVRvKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzLCBiYXNlbmFtZSwgZnV0dXJlLnY3X3ByZXBlbmRCYXNlbmFtZSwgaHJlZiwgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoLCByb3V0ZUlkLCBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnJlbGF0aXZlKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBub3JtYWxpemVkUGF0aCwgYmFzZW5hbWUpO1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgcGF0aG5hbWU6IG5vcm1hbGl6ZWRQYXRoXG4gICAgICB9KSwge1xuICAgICAgICBmbHVzaFN5bmNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQge1xuICAgICAgcGF0aCxcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBlcnJvclxuICAgIH0gPSBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMoZnV0dXJlLnY3X25vcm1hbGl6ZUZvcm1NZXRob2QsIHRydWUsIG5vcm1hbGl6ZWRQYXRoLCBvcHRzKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGVycm9yLCB7XG4gICAgICAgIGZsdXNoU3luY1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBtYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIHBhdGgpO1xuICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSAob3B0cyAmJiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCkgPT09IHRydWU7XG4gICAgaWYgKHN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICBoYW5kbGVGZXRjaGVyQWN0aW9uKGtleSwgcm91dGVJZCwgcGF0aCwgbWF0Y2gsIG1hdGNoZXMsIGZsdXNoU3luYywgc3VibWlzc2lvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFN0b3JlIG9mZiB0aGUgbWF0Y2ggc28gd2UgY2FuIGNhbGwgaXQncyBzaG91bGRSZXZhbGlkYXRlIG9uIHN1YnNlcXVlbnRcbiAgICAvLyByZXZhbGlkYXRpb25zXG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5zZXQoa2V5LCB7XG4gICAgICByb3V0ZUlkLFxuICAgICAgcGF0aFxuICAgIH0pO1xuICAgIGhhbmRsZUZldGNoZXJMb2FkZXIoa2V5LCByb3V0ZUlkLCBwYXRoLCBtYXRjaCwgbWF0Y2hlcywgZmx1c2hTeW5jLCBzdWJtaXNzaW9uKTtcbiAgfVxuICAvLyBDYWxsIHRoZSBhY3Rpb24gZm9yIHRoZSBtYXRjaGVkIGZldGNoZXIuc3VibWl0KCksIGFuZCB0aGVuIGhhbmRsZSByZWRpcmVjdHMsXG4gIC8vIGVycm9ycywgYW5kIHJldmFsaWRhdGlvblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVGZXRjaGVyQWN0aW9uKGtleSwgcm91dGVJZCwgcGF0aCwgbWF0Y2gsIHJlcXVlc3RNYXRjaGVzLCBmbHVzaFN5bmMsIHN1Ym1pc3Npb24pIHtcbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuICAgIGZldGNoTG9hZE1hdGNoZXMuZGVsZXRlKGtleSk7XG4gICAgaWYgKCFtYXRjaC5yb3V0ZS5hY3Rpb24gJiYgIW1hdGNoLnJvdXRlLmxhenkpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgIG1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogcGF0aCxcbiAgICAgICAgcm91dGVJZDogcm91dGVJZFxuICAgICAgfSk7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvciwge1xuICAgICAgICBmbHVzaFN5bmNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBQdXQgdGhpcyBmZXRjaGVyIGludG8gaXQncyBzdWJtaXR0aW5nIHN0YXRlXG4gICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldFN1Ym1pdHRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGV4aXN0aW5nRmV0Y2hlciksIHtcbiAgICAgIGZsdXNoU3luY1xuICAgIH0pO1xuICAgIC8vIENhbGwgdGhlIGFjdGlvbiBmb3IgdGhlIGZldGNoZXJcbiAgICBsZXQgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChpbml0Lmhpc3RvcnksIHBhdGgsIGFib3J0Q29udHJvbGxlci5zaWduYWwsIHN1Ym1pc3Npb24pO1xuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgYWJvcnRDb250cm9sbGVyKTtcbiAgICBsZXQgb3JpZ2luYXRpbmdMb2FkSWQgPSBpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgbGV0IGFjdGlvblJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXJPckFjdGlvbihcImFjdGlvblwiLCBmZXRjaFJlcXVlc3QsIG1hdGNoLCByZXF1ZXN0TWF0Y2hlcywgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllcywgYmFzZW5hbWUsIGZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aCk7XG4gICAgaWYgKGZldGNoUmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgLy8gV2UgY2FuIGRlbGV0ZSB0aGlzIHNvIGxvbmcgYXMgd2Ugd2VyZW4ndCBhYm9ydGVkIGJ5IG91ciBvd24gZmV0Y2hlclxuICAgICAgLy8gcmUtc3VibWl0IHdoaWNoIHdvdWxkIGhhdmUgcHV0IF9uZXdfIGNvbnRyb2xsZXIgaXMgaW4gZmV0Y2hDb250cm9sbGVyc1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSkgPT09IGFib3J0Q29udHJvbGxlcikge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBXaGVuIHVzaW5nIHY3X2ZldGNoZXJQZXJzaXN0LCB3ZSBkb24ndCB3YW50IGVycm9ycyBidWJibGluZyB1cCB0byB0aGUgVUlcbiAgICAvLyBvciByZWRpcmVjdHMgcHJvY2Vzc2VkIGZvciB1bm1vdW50ZWQgZmV0Y2hlcnMgc28gd2UganVzdCByZXZlcnQgdGhlbSB0b1xuICAgIC8vIGlkbGVcbiAgICBpZiAoZnV0dXJlLnY3X2ZldGNoZXJQZXJzaXN0ICYmIGRlbGV0ZWRGZXRjaGVycy5oYXMoa2V5KSkge1xuICAgICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQoYWN0aW9uUmVzdWx0KSB8fCBpc0Vycm9yUmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIodW5kZWZpbmVkKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIExldCBTdWNjZXNzUmVzdWx0J3MgZmFsbCB0aHJvdWdoIGZvciByZXZhbGlkYXRpb25cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPiBvcmlnaW5hdGluZ0xvYWRJZCkge1xuICAgICAgICAgIC8vIEEgbmV3IG5hdmlnYXRpb24gd2FzIGtpY2tlZCBvZmYgYWZ0ZXIgb3VyIGFjdGlvbiBzdGFydGVkLCBzbyB0aGF0XG4gICAgICAgICAgLy8gc2hvdWxkIHRha2UgcHJlY2VkZW5jZSBvdmVyIHRoaXMgcmVkaXJlY3QgbmF2aWdhdGlvbi4gIFdlIGFscmVhZHlcbiAgICAgICAgICAvLyBzZXQgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCBzbyBhbGwgbG9hZGVycyBmb3IgdGhlIG5ldyByb3V0ZSBzaG91bGRcbiAgICAgICAgICAvLyBmaXJlIHVubGVzcyBvcHRlZCBvdXQgdmlhIHNob3VsZFJldmFsaWRhdGVcbiAgICAgICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcih1bmRlZmluZWQpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5hZGQoa2V5KTtcbiAgICAgICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uKSk7XG4gICAgICAgICAgcmV0dXJuIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCBhY3Rpb25SZXN1bHQsIHtcbiAgICAgICAgICAgIGZldGNoZXJTdWJtaXNzaW9uOiBzdWJtaXNzaW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFByb2Nlc3MgYW55IG5vbi1yZWRpcmVjdCBlcnJvcnMgdGhyb3duXG4gICAgICBpZiAoaXNFcnJvclJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGFjdGlvblJlc3VsdC5lcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHtcbiAgICAgICAgdHlwZTogXCJkZWZlci1hY3Rpb25cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFN0YXJ0IHRoZSBkYXRhIGxvYWQgZm9yIGN1cnJlbnQgbWF0Y2hlcywgb3IgdGhlIG5leHQgbG9jYXRpb24gaWYgd2UncmVcbiAgICAvLyBpbiB0aGUgbWlkZGxlIG9mIGEgbmF2aWdhdGlvblxuICAgIGxldCBuZXh0TG9jYXRpb24gPSBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uIHx8IHN0YXRlLmxvY2F0aW9uO1xuICAgIGxldCByZXZhbGlkYXRpb25SZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoaW5pdC5oaXN0b3J5LCBuZXh0TG9jYXRpb24sIGFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBtYXRjaGVzID0gc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSAhPT0gXCJpZGxlXCIgPyBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiwgYmFzZW5hbWUpIDogc3RhdGUubWF0Y2hlcztcbiAgICBpbnZhcmlhbnQobWF0Y2hlcywgXCJEaWRuJ3QgZmluZCBhbnkgbWF0Y2hlcyBhZnRlciBmZXRjaGVyIGFjdGlvblwiKTtcbiAgICBsZXQgbG9hZElkID0gKytpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgZmV0Y2hSZWxvYWRJZHMuc2V0KGtleSwgbG9hZElkKTtcbiAgICBsZXQgbG9hZEZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBhY3Rpb25SZXN1bHQuZGF0YSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgbG9hZEZldGNoZXIpO1xuICAgIGxldCBbbWF0Y2hlc1RvTG9hZCwgcmV2YWxpZGF0aW5nRmV0Y2hlcnNdID0gZ2V0TWF0Y2hlc1RvTG9hZChpbml0Lmhpc3RvcnksIHN0YXRlLCBtYXRjaGVzLCBzdWJtaXNzaW9uLCBuZXh0TG9jYXRpb24sIGZhbHNlLCBpc1JldmFsaWRhdGlvblJlcXVpcmVkLCBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcywgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLCBkZWxldGVkRmV0Y2hlcnMsIGZldGNoTG9hZE1hdGNoZXMsIGZldGNoUmVkaXJlY3RJZHMsIHJvdXRlc1RvVXNlLCBiYXNlbmFtZSwge1xuICAgICAgW21hdGNoLnJvdXRlLmlkXTogYWN0aW9uUmVzdWx0LmRhdGFcbiAgICB9LCB1bmRlZmluZWQgLy8gTm8gbmVlZCB0byBzZW5kIHRocm91Z2ggZXJyb3JzIHNpbmNlIHdlIHNob3J0IGNpcmN1aXQgYWJvdmVcbiAgICApO1xuICAgIC8vIFB1dCBhbGwgcmV2YWxpZGF0aW5nIGZldGNoZXJzIGludG8gdGhlIGxvYWRpbmcgc3RhdGUsIGV4Y2VwdCBmb3IgdGhlXG4gICAgLy8gY3VycmVudCBmZXRjaGVyIHdoaWNoIHdlIHdhbnQgdG8ga2VlcCBpbiBpdCdzIGN1cnJlbnQgbG9hZGluZyBzdGF0ZSB3aGljaFxuICAgIC8vIGNvbnRhaW5zIGl0J3MgYWN0aW9uIHN1Ym1pc3Npb24gaW5mbyArIGFjdGlvbiBkYXRhXG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZmlsdGVyKHJmID0+IHJmLmtleSAhPT0ga2V5KS5mb3JFYWNoKHJmID0+IHtcbiAgICAgIGxldCBzdGFsZUtleSA9IHJmLmtleTtcbiAgICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoc3RhbGVLZXkpO1xuICAgICAgbGV0IHJldmFsaWRhdGluZ0ZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcih1bmRlZmluZWQsIGV4aXN0aW5nRmV0Y2hlciA/IGV4aXN0aW5nRmV0Y2hlci5kYXRhIDogdW5kZWZpbmVkKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChzdGFsZUtleSwgcmV2YWxpZGF0aW5nRmV0Y2hlcik7XG4gICAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoc3RhbGVLZXkpKSB7XG4gICAgICAgIGFib3J0RmV0Y2hlcihzdGFsZUtleSk7XG4gICAgICB9XG4gICAgICBpZiAocmYuY29udHJvbGxlcikge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLnNldChzdGFsZUtleSwgcmYuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdXBkYXRlU3RhdGUoe1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSk7XG4gICAgbGV0IGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyA9ICgpID0+IHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2gocmYgPT4gYWJvcnRGZXRjaGVyKHJmLmtleSkpO1xuICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyk7XG4gICAgbGV0IHtcbiAgICAgIHJlc3VsdHMsXG4gICAgICBsb2FkZXJSZXN1bHRzLFxuICAgICAgZmV0Y2hlclJlc3VsdHNcbiAgICB9ID0gYXdhaXQgY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKHN0YXRlLm1hdGNoZXMsIG1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzLCByZXZhbGlkYXRpb25SZXF1ZXN0KTtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyk7XG4gICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKHIgPT4gZmV0Y2hDb250cm9sbGVycy5kZWxldGUoci5rZXkpKTtcbiAgICBsZXQgcmVkaXJlY3QgPSBmaW5kUmVkaXJlY3QocmVzdWx0cyk7XG4gICAgaWYgKHJlZGlyZWN0KSB7XG4gICAgICBpZiAocmVkaXJlY3QuaWR4ID49IG1hdGNoZXNUb0xvYWQubGVuZ3RoKSB7XG4gICAgICAgIC8vIElmIHRoaXMgcmVkaXJlY3QgY2FtZSBmcm9tIGEgZmV0Y2hlciBtYWtlIHN1cmUgd2UgbWFyayBpdCBpblxuICAgICAgICAvLyBmZXRjaFJlZGlyZWN0SWRzIHNvIGl0IGRvZXNuJ3QgZ2V0IHJldmFsaWRhdGVkIG9uIHRoZSBuZXh0IHNldCBvZlxuICAgICAgICAvLyBsb2FkZXIgZXhlY3V0aW9uc1xuICAgICAgICBsZXQgZmV0Y2hlcktleSA9IHJldmFsaWRhdGluZ0ZldGNoZXJzW3JlZGlyZWN0LmlkeCAtIG1hdGNoZXNUb0xvYWQubGVuZ3RoXS5rZXk7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKGZldGNoZXJLZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCByZWRpcmVjdC5yZXN1bHQpO1xuICAgIH1cbiAgICAvLyBQcm9jZXNzIGFuZCBjb21taXQgb3V0cHV0IGZyb20gbG9hZGVyc1xuICAgIGxldCB7XG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzXG4gICAgfSA9IHByb2Nlc3NMb2FkZXJEYXRhKHN0YXRlLCBzdGF0ZS5tYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCBsb2FkZXJSZXN1bHRzLCB1bmRlZmluZWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzLCBmZXRjaGVyUmVzdWx0cywgYWN0aXZlRGVmZXJyZWRzKTtcbiAgICAvLyBTaW5jZSB3ZSBsZXQgcmV2YWxpZGF0aW9ucyBjb21wbGV0ZSBldmVuIGlmIHRoZSBzdWJtaXR0aW5nIGZldGNoZXIgd2FzXG4gICAgLy8gZGVsZXRlZCwgb25seSBwdXQgaXQgYmFjayB0byBpZGxlIGlmIGl0IGhhc24ndCBiZWVuIGRlbGV0ZWRcbiAgICBpZiAoc3RhdGUuZmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKGFjdGlvblJlc3VsdC5kYXRhKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICB9XG4gICAgYWJvcnRTdGFsZUZldGNoTG9hZHMobG9hZElkKTtcbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluIGEgbmF2aWdhdGlvbiBsb2FkaW5nIHN0YXRlIGFuZCB0aGlzIGZldGNoZXIgaXNcbiAgICAvLyBtb3JlIHJlY2VudCB0aGFuIHRoZSBuYXZpZ2F0aW9uLCB3ZSB3YW50IHRoZSBuZXdlciBkYXRhIHNvIGFib3J0IHRoZVxuICAgIC8vIG5hdmlnYXRpb24gYW5kIGNvbXBsZXRlIGl0IHdpdGggdGhlIGZldGNoZXIgZGF0YVxuICAgIGlmIChzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcImxvYWRpbmdcIiAmJiBsb2FkSWQgPiBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCkge1xuICAgICAgaW52YXJpYW50KHBlbmRpbmdBY3Rpb24sIFwiRXhwZWN0ZWQgcGVuZGluZyBhY3Rpb25cIik7XG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgJiYgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLmFib3J0KCk7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24oc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiwge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhLFxuICAgICAgICBlcnJvcnMsXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSBqdXN0IHVwZGF0ZSB3aXRoIHRoZSBmZXRjaGVyIGRhdGEsIHByZXNlcnZpbmcgYW55IGV4aXN0aW5nXG4gICAgICAvLyBsb2FkZXJEYXRhIGZvciBsb2FkZXJzIHRoYXQgZGlkIG5vdCBuZWVkIHRvIHJlbG9hZC4gIFdlIGhhdmUgdG9cbiAgICAgIC8vIG1hbnVhbGx5IG1lcmdlIGhlcmUgc2luY2Ugd2UgYXJlbid0IGdvaW5nIHRocm91Z2ggY29tcGxldGVOYXZpZ2F0aW9uXG4gICAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICAgIGVycm9ycyxcbiAgICAgICAgbG9hZGVyRGF0YTogbWVyZ2VMb2FkZXJEYXRhKHN0YXRlLmxvYWRlckRhdGEsIGxvYWRlckRhdGEsIG1hdGNoZXMsIGVycm9ycyksXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSk7XG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIENhbGwgdGhlIG1hdGNoZWQgbG9hZGVyIGZvciBmZXRjaGVyLmxvYWQoKSwgaGFuZGxpbmcgcmVkaXJlY3RzLCBlcnJvcnMsIGV0Yy5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlRmV0Y2hlckxvYWRlcihrZXksIHJvdXRlSWQsIHBhdGgsIG1hdGNoLCBtYXRjaGVzLCBmbHVzaFN5bmMsIHN1Ym1pc3Npb24pIHtcbiAgICBsZXQgZXhpc3RpbmdGZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0TG9hZGluZ0ZldGNoZXIoc3VibWlzc2lvbiwgZXhpc3RpbmdGZXRjaGVyID8gZXhpc3RpbmdGZXRjaGVyLmRhdGEgOiB1bmRlZmluZWQpLCB7XG4gICAgICBmbHVzaFN5bmNcbiAgICB9KTtcbiAgICAvLyBDYWxsIHRoZSBsb2FkZXIgZm9yIHRoaXMgZmV0Y2hlciByb3V0ZSBtYXRjaFxuICAgIGxldCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IGZldGNoUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGluaXQuaGlzdG9yeSwgcGF0aCwgYWJvcnRDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5zZXQoa2V5LCBhYm9ydENvbnRyb2xsZXIpO1xuICAgIGxldCBvcmlnaW5hdGluZ0xvYWRJZCA9IGluY3JlbWVudGluZ0xvYWRJZDtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlck9yQWN0aW9uKFwibG9hZGVyXCIsIGZldGNoUmVxdWVzdCwgbWF0Y2gsIG1hdGNoZXMsIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMsIGJhc2VuYW1lLCBmdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgpO1xuICAgIC8vIERlZmVycmVkIGlzbid0IHN1cHBvcnRlZCBmb3IgZmV0Y2hlciBsb2FkcywgYXdhaXQgZXZlcnl0aGluZyBhbmQgdHJlYXQgaXRcbiAgICAvLyBhcyBhIG5vcm1hbCBsb2FkLiAgcmVzb2x2ZURlZmVycmVkRGF0YSB3aWxsIHJldHVybiB1bmRlZmluZWQgaWYgdGhpc1xuICAgIC8vIGZldGNoZXIgZ2V0cyBhYm9ydGVkLCBzbyB3ZSBqdXN0IGxlYXZlIHJlc3VsdCB1bnRvdWNoZWQgYW5kIHNob3J0IGNpcmN1aXRcbiAgICAvLyBiZWxvdyBpZiB0aGF0IGhhcHBlbnNcbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICByZXN1bHQgPSAoYXdhaXQgcmVzb2x2ZURlZmVycmVkRGF0YShyZXN1bHQsIGZldGNoUmVxdWVzdC5zaWduYWwsIHRydWUpKSB8fCByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFdlIGNhbiBkZWxldGUgdGhpcyBzbyBsb25nIGFzIHdlIHdlcmVuJ3QgYWJvcnRlZCBieSBvdXIgb3VyIG93biBmZXRjaGVyXG4gICAgLy8gcmUtbG9hZCB3aGljaCB3b3VsZCBoYXZlIHB1dCBfbmV3XyBjb250cm9sbGVyIGlzIGluIGZldGNoQ29udHJvbGxlcnNcbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5nZXQoa2V5KSA9PT0gYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hSZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXJyb3JzIGJ1YmJsaW5nIHVwIG9yIHJlZGlyZWN0cyBmb2xsb3dlZCBmb3IgdW5tb3VudGVkXG4gICAgLy8gZmV0Y2hlcnMsIHNvIHNob3J0IGNpcmN1aXQgaGVyZSBpZiBpdCB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBVSVxuICAgIGlmIChkZWxldGVkRmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHVuZGVmaW5lZCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgbG9hZGVyIHRocmV3IGEgcmVkaXJlY3QgUmVzcG9uc2UsIHN0YXJ0IGEgbmV3IFJFUExBQ0UgbmF2aWdhdGlvblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA+IG9yaWdpbmF0aW5nTG9hZElkKSB7XG4gICAgICAgIC8vIEEgbmV3IG5hdmlnYXRpb24gd2FzIGtpY2tlZCBvZmYgYWZ0ZXIgb3VyIGxvYWRlciBzdGFydGVkLCBzbyB0aGF0XG4gICAgICAgIC8vIHNob3VsZCB0YWtlIHByZWNlZGVuY2Ugb3ZlciB0aGlzIHJlZGlyZWN0IG5hdmlnYXRpb25cbiAgICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIodW5kZWZpbmVkKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKGtleSk7XG4gICAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCByZXN1bHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFByb2Nlc3MgYW55IG5vbi1yZWRpcmVjdCBlcnJvcnMgdGhyb3duXG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgcmVzdWx0LmVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52YXJpYW50KCFpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCksIFwiVW5oYW5kbGVkIGZldGNoZXIgZGVmZXJyZWQgZGF0YVwiKTtcbiAgICAvLyBQdXQgdGhlIGZldGNoZXIgYmFjayBpbnRvIGFuIGlkbGUgc3RhdGVcbiAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcihyZXN1bHQuZGF0YSkpO1xuICB9XG4gIC8qKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGhhbmRsZSByZWRpcmVjdHMgcmV0dXJuZWQgZnJvbSBhbiBhY3Rpb24gb3IgbG9hZGVyLlxuICAgKiBOb3JtYWxseSwgYSByZWRpcmVjdCBcInJlcGxhY2VzXCIgdGhlIG5hdmlnYXRpb24gdGhhdCB0cmlnZ2VyZWQgaXQuICBTbywgZm9yXG4gICAqIGV4YW1wbGU6XG4gICAqXG4gICAqICAtIHVzZXIgaXMgb24gL2FcbiAgICogIC0gdXNlciBjbGlja3MgYSBsaW5rIHRvIC9iXG4gICAqICAtIGxvYWRlciBmb3IgL2IgcmVkaXJlY3RzIHRvIC9jXG4gICAqXG4gICAqIEluIGEgbm9uLUpTIGFwcCB0aGUgYnJvd3NlciB3b3VsZCB0cmFjayB0aGUgaW4tZmxpZ2h0IG5hdmlnYXRpb24gdG8gL2IgYW5kXG4gICAqIHRoZW4gcmVwbGFjZSBpdCB3aXRoIC9jIHdoZW4gaXQgZW5jb3VudGVyZWQgdGhlIHJlZGlyZWN0IHJlc3BvbnNlLiAgSW5cbiAgICogdGhlIGVuZCBpdCB3b3VsZCBvbmx5IGV2ZXIgdXBkYXRlIHRoZSBVUkwgYmFyIHdpdGggL2MuXG4gICAqXG4gICAqIEluIGNsaWVudC1zaWRlIHJvdXRpbmcgdXNpbmcgcHVzaFN0YXRlL3JlcGxhY2VTdGF0ZSwgd2UgYWltIHRvIGVtdWxhdGVcbiAgICogdGhpcyBiZWhhdmlvciBhbmQgd2UgYWxzbyBkbyBub3QgdXBkYXRlIGhpc3RvcnkgdW50aWwgdGhlIGVuZCBvZiB0aGVcbiAgICogbmF2aWdhdGlvbiAoaW5jbHVkaW5nIHByb2Nlc3NlZCByZWRpcmVjdHMpLiAgVGhpcyBtZWFucyB0aGF0IHdlIG5ldmVyXG4gICAqIGFjdHVhbGx5IHRvdWNoIGhpc3RvcnkgdW50aWwgd2UndmUgcHJvY2Vzc2VkIHJlZGlyZWN0cywgc28gd2UganVzdCB1c2VcbiAgICogdGhlIGhpc3RvcnkgYWN0aW9uIGZyb20gdGhlIG9yaWdpbmFsIG5hdmlnYXRpb24gKFBVU0ggb3IgUkVQTEFDRSkuXG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgcmVkaXJlY3QsIF90ZW1wMikge1xuICAgIGxldCB7XG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgICByZXBsYWNlXG4gICAgfSA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDI7XG4gICAgaWYgKHJlZGlyZWN0LnJldmFsaWRhdGUpIHtcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgcmVkaXJlY3RMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHN0YXRlLmxvY2F0aW9uLCByZWRpcmVjdC5sb2NhdGlvbiwge1xuICAgICAgX2lzUmVkaXJlY3Q6IHRydWVcbiAgICB9KTtcbiAgICBpbnZhcmlhbnQocmVkaXJlY3RMb2NhdGlvbiwgXCJFeHBlY3RlZCBhIGxvY2F0aW9uIG9uIHRoZSByZWRpcmVjdCBuYXZpZ2F0aW9uXCIpO1xuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgIGxldCBpc0RvY3VtZW50UmVsb2FkID0gZmFsc2U7XG4gICAgICBpZiAocmVkaXJlY3QucmVsb2FkRG9jdW1lbnQpIHtcbiAgICAgICAgLy8gSGFyZCByZWxvYWQgaWYgdGhlIHJlc3BvbnNlIGNvbnRhaW5lZCBYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFxuICAgICAgICBpc0RvY3VtZW50UmVsb2FkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QocmVkaXJlY3QubG9jYXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGluaXQuaGlzdG9yeS5jcmVhdGVVUkwocmVkaXJlY3QubG9jYXRpb24pO1xuICAgICAgICBpc0RvY3VtZW50UmVsb2FkID1cbiAgICAgICAgLy8gSGFyZCByZWxvYWQgaWYgaXQncyBhbiBhYnNvbHV0ZSBVUkwgdG8gYSBuZXcgb3JpZ2luXG4gICAgICAgIHVybC5vcmlnaW4gIT09IHJvdXRlcldpbmRvdy5sb2NhdGlvbi5vcmlnaW4gfHxcbiAgICAgICAgLy8gSGFyZCByZWxvYWQgaWYgaXQncyBhbiBhYnNvbHV0ZSBVUkwgdGhhdCBkb2VzIG5vdCBtYXRjaCBvdXIgYmFzZW5hbWVcbiAgICAgICAgc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGJhc2VuYW1lKSA9PSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGlzRG9jdW1lbnRSZWxvYWQpIHtcbiAgICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgICByb3V0ZXJXaW5kb3cubG9jYXRpb24ucmVwbGFjZShyZWRpcmVjdC5sb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm91dGVyV2luZG93LmxvY2F0aW9uLmFzc2lnbihyZWRpcmVjdC5sb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gYWJvcnQgb24gcmVkaXJlY3RzLCBzaW5jZSB3ZSBkb24ndCBkZXRlY3QgdGhlXG4gICAgLy8gcmVkaXJlY3QgdW50aWwgdGhlIGFjdGlvbi9sb2FkZXJzIGhhdmUgc2V0dGxlZFxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgbGV0IHJlZGlyZWN0SGlzdG9yeUFjdGlvbiA9IHJlcGxhY2UgPT09IHRydWUgPyBBY3Rpb24uUmVwbGFjZSA6IEFjdGlvbi5QdXNoO1xuICAgIC8vIFVzZSB0aGUgaW5jb21pbmcgc3VibWlzc2lvbiBpZiBwcm92aWRlZCwgZmFsbGJhY2sgb24gdGhlIGFjdGl2ZSBvbmUgaW5cbiAgICAvLyBzdGF0ZS5uYXZpZ2F0aW9uXG4gICAgbGV0IHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGVcbiAgICB9ID0gc3RhdGUubmF2aWdhdGlvbjtcbiAgICBpZiAoIXN1Ym1pc3Npb24gJiYgIWZldGNoZXJTdWJtaXNzaW9uICYmIGZvcm1NZXRob2QgJiYgZm9ybUFjdGlvbiAmJiBmb3JtRW5jVHlwZSkge1xuICAgICAgc3VibWlzc2lvbiA9IGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihzdGF0ZS5uYXZpZ2F0aW9uKTtcbiAgICB9XG4gICAgLy8gSWYgdGhpcyB3YXMgYSAzMDcvMzA4IHN1Ym1pc3Npb24gd2Ugd2FudCB0byBwcmVzZXJ2ZSB0aGUgSFRUUCBtZXRob2QgYW5kXG4gICAgLy8gcmUtc3VibWl0IHRoZSBHRVQvUE9TVC9QVVQvUEFUQ0gvREVMRVRFIGFzIGEgc3VibWlzc2lvbiBuYXZpZ2F0aW9uIHRvIHRoZVxuICAgIC8vIHJlZGlyZWN0ZWQgbG9jYXRpb25cbiAgICBsZXQgYWN0aXZlU3VibWlzc2lvbiA9IHN1Ym1pc3Npb24gfHwgZmV0Y2hlclN1Ym1pc3Npb247XG4gICAgaWYgKHJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2Rlcy5oYXMocmVkaXJlY3Quc3RhdHVzKSAmJiBhY3RpdmVTdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2QoYWN0aXZlU3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgICAgYXdhaXQgc3RhcnROYXZpZ2F0aW9uKHJlZGlyZWN0SGlzdG9yeUFjdGlvbiwgcmVkaXJlY3RMb2NhdGlvbiwge1xuICAgICAgICBzdWJtaXNzaW9uOiBfZXh0ZW5kcyh7fSwgYWN0aXZlU3VibWlzc2lvbiwge1xuICAgICAgICAgIGZvcm1BY3Rpb246IHJlZGlyZWN0LmxvY2F0aW9uXG4gICAgICAgIH0pLFxuICAgICAgICAvLyBQcmVzZXJ2ZSB0aGlzIGZsYWcgYWNyb3NzIHJlZGlyZWN0c1xuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgbmF2aWdhdGlvbiBzdWJtaXNzaW9uLCB3ZSB3aWxsIHByZXNlcnZlIGl0IHRocm91Z2ggdGhlXG4gICAgICAvLyByZWRpcmVjdCBuYXZpZ2F0aW9uXG4gICAgICBsZXQgb3ZlcnJpZGVOYXZpZ2F0aW9uID0gZ2V0TG9hZGluZ05hdmlnYXRpb24ocmVkaXJlY3RMb2NhdGlvbiwgc3VibWlzc2lvbik7XG4gICAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24ocmVkaXJlY3RIaXN0b3J5QWN0aW9uLCByZWRpcmVjdExvY2F0aW9uLCB7XG4gICAgICAgIG92ZXJyaWRlTmF2aWdhdGlvbixcbiAgICAgICAgLy8gU2VuZCBmZXRjaGVyIHN1Ym1pc3Npb25zIHRocm91Z2ggZm9yIHNob3VsZFJldmFsaWRhdGVcbiAgICAgICAgZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgICAgIC8vIFByZXNlcnZlIHRoaXMgZmxhZyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShjdXJyZW50TWF0Y2hlcywgbWF0Y2hlcywgbWF0Y2hlc1RvTG9hZCwgZmV0Y2hlcnNUb0xvYWQsIHJlcXVlc3QpIHtcbiAgICAvLyBDYWxsIGFsbCBuYXZpZ2F0aW9uIGxvYWRlcnMgYW5kIHJldmFsaWRhdGluZyBmZXRjaGVyIGxvYWRlcnMgaW4gcGFyYWxsZWwsXG4gICAgLy8gdGhlbiBzbGljZSBvZmYgdGhlIHJlc3VsdHMgaW50byBzZXBhcmF0ZSBhcnJheXMgc28gd2UgY2FuIGhhbmRsZSB0aGVtXG4gICAgLy8gYWNjb3JkaW5nbHlcbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFsuLi5tYXRjaGVzVG9Mb2FkLm1hcChtYXRjaCA9PiBjYWxsTG9hZGVyT3JBY3Rpb24oXCJsb2FkZXJcIiwgcmVxdWVzdCwgbWF0Y2gsIG1hdGNoZXMsIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMsIGJhc2VuYW1lLCBmdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgpKSwgLi4uZmV0Y2hlcnNUb0xvYWQubWFwKGYgPT4ge1xuICAgICAgaWYgKGYubWF0Y2hlcyAmJiBmLm1hdGNoICYmIGYuY29udHJvbGxlcikge1xuICAgICAgICByZXR1cm4gY2FsbExvYWRlck9yQWN0aW9uKFwibG9hZGVyXCIsIGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGluaXQuaGlzdG9yeSwgZi5wYXRoLCBmLmNvbnRyb2xsZXIuc2lnbmFsKSwgZi5tYXRjaCwgZi5tYXRjaGVzLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzLCBiYXNlbmFtZSwgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBlcnJvciA9IHtcbiAgICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgICAgICAgcGF0aG5hbWU6IGYucGF0aFxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cbiAgICB9KV0pO1xuICAgIGxldCBsb2FkZXJSZXN1bHRzID0gcmVzdWx0cy5zbGljZSgwLCBtYXRjaGVzVG9Mb2FkLmxlbmd0aCk7XG4gICAgbGV0IGZldGNoZXJSZXN1bHRzID0gcmVzdWx0cy5zbGljZShtYXRjaGVzVG9Mb2FkLmxlbmd0aCk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW3Jlc29sdmVEZWZlcnJlZFJlc3VsdHMoY3VycmVudE1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIGxvYWRlclJlc3VsdHMsIGxvYWRlclJlc3VsdHMubWFwKCgpID0+IHJlcXVlc3Quc2lnbmFsKSwgZmFsc2UsIHN0YXRlLmxvYWRlckRhdGEpLCByZXNvbHZlRGVmZXJyZWRSZXN1bHRzKGN1cnJlbnRNYXRjaGVzLCBmZXRjaGVyc1RvTG9hZC5tYXAoZiA9PiBmLm1hdGNoKSwgZmV0Y2hlclJlc3VsdHMsIGZldGNoZXJzVG9Mb2FkLm1hcChmID0+IGYuY29udHJvbGxlciA/IGYuY29udHJvbGxlci5zaWduYWwgOiBudWxsKSwgdHJ1ZSldKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0cyxcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICBmZXRjaGVyUmVzdWx0c1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gaW50ZXJydXB0QWN0aXZlTG9hZHMoKSB7XG4gICAgLy8gRXZlcnkgaW50ZXJydXB0aW9uIHRyaWdnZXJzIGEgcmV2YWxpZGF0aW9uXG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IHRydWU7XG4gICAgLy8gQ2FuY2VsIHBlbmRpbmcgcm91dGUtbGV2ZWwgZGVmZXJyZWRzIGFuZCBtYXJrIGNhbmNlbGxlZCByb3V0ZXMgZm9yXG4gICAgLy8gcmV2YWxpZGF0aW9uXG4gICAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMucHVzaCguLi5jYW5jZWxBY3RpdmVEZWZlcnJlZHMoKSk7XG4gICAgLy8gQWJvcnQgaW4tZmxpZ2h0IGZldGNoZXIgbG9hZHNcbiAgICBmZXRjaExvYWRNYXRjaGVzLmZvckVhY2goKF8sIGtleSkgPT4ge1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLnB1c2goa2V5KTtcbiAgICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZmV0Y2hlciwgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZmV0Y2hlcik7XG4gICAgdXBkYXRlU3RhdGUoe1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSwge1xuICAgICAgZmx1c2hTeW5jOiAob3B0cyAmJiBvcHRzLmZsdXNoU3luYykgPT09IHRydWVcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvciwgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIHJvdXRlSWQpO1xuICAgIGRlbGV0ZUZldGNoZXIoa2V5KTtcbiAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICBlcnJvcnM6IHtcbiAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiBlcnJvclxuICAgICAgfSxcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0sIHtcbiAgICAgIGZsdXNoU3luYzogKG9wdHMgJiYgb3B0cy5mbHVzaFN5bmMpID09PSB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RmV0Y2hlcihrZXkpIHtcbiAgICBpZiAoZnV0dXJlLnY3X2ZldGNoZXJQZXJzaXN0KSB7XG4gICAgICBhY3RpdmVGZXRjaGVycy5zZXQoa2V5LCAoYWN0aXZlRmV0Y2hlcnMuZ2V0KGtleSkgfHwgMCkgKyAxKTtcbiAgICAgIC8vIElmIHRoaXMgZmV0Y2hlciB3YXMgcHJldmlvdXNseSBtYXJrZWQgZm9yIGRlbGV0aW9uLCB1bm1hcmsgaXQgc2luY2Ugd2VcbiAgICAgIC8vIGhhdmUgYSBuZXcgaW5zdGFuY2VcbiAgICAgIGlmIChkZWxldGVkRmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgZGVsZXRlZEZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSkgfHwgSURMRV9GRVRDSEVSO1xuICB9XG4gIGZ1bmN0aW9uIGRlbGV0ZUZldGNoZXIoa2V5KSB7XG4gICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAvLyBEb24ndCBhYm9ydCB0aGUgY29udHJvbGxlciBpZiB0aGlzIGlzIGEgZGVsZXRpb24gb2YgYSBmZXRjaGVyLnN1Ym1pdCgpXG4gICAgLy8gaW4gaXQncyBsb2FkaW5nIHBoYXNlIHNpbmNlIC0gd2UgZG9uJ3Qgd2FudCB0byBhYm9ydCB0aGUgY29ycmVzcG9uZGluZ1xuICAgIC8vIHJldmFsaWRhdGlvbiBhbmQgd2FudCB0aGVtIHRvIGNvbXBsZXRlIGFuZCBsYW5kXG4gICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkgJiYgIShmZXRjaGVyICYmIGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiICYmIGZldGNoUmVsb2FkSWRzLmhhcyhrZXkpKSkge1xuICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgfVxuICAgIGZldGNoTG9hZE1hdGNoZXMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hSZWRpcmVjdElkcy5kZWxldGUoa2V5KTtcbiAgICBkZWxldGVkRmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVsZXRlRmV0Y2hlckFuZFVwZGF0ZVN0YXRlKGtleSkge1xuICAgIGlmIChmdXR1cmUudjdfZmV0Y2hlclBlcnNpc3QpIHtcbiAgICAgIGxldCBjb3VudCA9IChhY3RpdmVGZXRjaGVycy5nZXQoa2V5KSB8fCAwKSAtIDE7XG4gICAgICBpZiAoY291bnQgPD0gMCkge1xuICAgICAgICBhY3RpdmVGZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICAgICAgZGVsZXRlZEZldGNoZXJzLmFkZChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZlRmV0Y2hlcnMuc2V0KGtleSwgY291bnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGVGZXRjaGVyKGtleSk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGFib3J0RmV0Y2hlcihrZXkpIHtcbiAgICBsZXQgY29udHJvbGxlciA9IGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSk7XG4gICAgaW52YXJpYW50KGNvbnRyb2xsZXIsIFwiRXhwZWN0ZWQgZmV0Y2ggY29udHJvbGxlcjogXCIgKyBrZXkpO1xuICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIG1hcmtGZXRjaGVyc0RvbmUoa2V5cykge1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICBsZXQgZmV0Y2hlciA9IGdldEZldGNoZXIoa2V5KTtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKGZldGNoZXIuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKSB7XG4gICAgbGV0IGRvbmVLZXlzID0gW107XG4gICAgbGV0IHVwZGF0ZWRGZXRjaGVycyA9IGZhbHNlO1xuICAgIGZvciAobGV0IGtleSBvZiBmZXRjaFJlZGlyZWN0SWRzKSB7XG4gICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgICAgaW52YXJpYW50KGZldGNoZXIsIFwiRXhwZWN0ZWQgZmV0Y2hlcjogXCIgKyBrZXkpO1xuICAgICAgaWYgKGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuZGVsZXRlKGtleSk7XG4gICAgICAgIGRvbmVLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgdXBkYXRlZEZldGNoZXJzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWFya0ZldGNoZXJzRG9uZShkb25lS2V5cyk7XG4gICAgcmV0dXJuIHVwZGF0ZWRGZXRjaGVycztcbiAgfVxuICBmdW5jdGlvbiBhYm9ydFN0YWxlRmV0Y2hMb2FkcyhsYW5kZWRJZCkge1xuICAgIGxldCB5ZWV0ZWRLZXlzID0gW107XG4gICAgZm9yIChsZXQgW2tleSwgaWRdIG9mIGZldGNoUmVsb2FkSWRzKSB7XG4gICAgICBpZiAoaWQgPCBsYW5kZWRJZCkge1xuICAgICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgICAgICBpbnZhcmlhbnQoZmV0Y2hlciwgXCJFeHBlY3RlZCBmZXRjaGVyOiBcIiArIGtleSk7XG4gICAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgICAgICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIHllZXRlZEtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1hcmtGZXRjaGVyc0RvbmUoeWVldGVkS2V5cyk7XG4gICAgcmV0dXJuIHllZXRlZEtleXMubGVuZ3RoID4gMDtcbiAgfVxuICBmdW5jdGlvbiBnZXRCbG9ja2VyKGtleSwgZm4pIHtcbiAgICBsZXQgYmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChrZXkpIHx8IElETEVfQkxPQ0tFUjtcbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5nZXQoa2V5KSAhPT0gZm4pIHtcbiAgICAgIGJsb2NrZXJGdW5jdGlvbnMuc2V0KGtleSwgZm4pO1xuICAgIH1cbiAgICByZXR1cm4gYmxvY2tlcjtcbiAgfVxuICBmdW5jdGlvbiBkZWxldGVCbG9ja2VyKGtleSkge1xuICAgIHN0YXRlLmJsb2NrZXJzLmRlbGV0ZShrZXkpO1xuICAgIGJsb2NrZXJGdW5jdGlvbnMuZGVsZXRlKGtleSk7XG4gIH1cbiAgLy8gVXRpbGl0eSBmdW5jdGlvbiB0byB1cGRhdGUgYmxvY2tlcnMsIGVuc3VyaW5nIHZhbGlkIHN0YXRlIHRyYW5zaXRpb25zXG4gIGZ1bmN0aW9uIHVwZGF0ZUJsb2NrZXIoa2V5LCBuZXdCbG9ja2VyKSB7XG4gICAgbGV0IGJsb2NrZXIgPSBzdGF0ZS5ibG9ja2Vycy5nZXQoa2V5KSB8fCBJRExFX0JMT0NLRVI7XG4gICAgLy8gUG9vciBtYW5zIHN0YXRlIG1hY2hpbmUgOilcbiAgICAvLyBodHRwczovL21lcm1haWQubGl2ZS9lZGl0I3Bha286ZU5xVmtjOU93ekFNeGw4bDhubmpBWXJFdERJT0hFQklnd3ZLSlRSZUd5M19sRHBJcU8yN2s2YXdNRzBYY3JMbG56ODdud2RvbkVTb2dLWFhCdUU3OXJxNzVYWk8zLXlIZHMwUkpWdXY3MFlyUGxVckNFZTJIZnJPUlMzcnVicVpmdWh0cGc1Qzl3azV0WjRWS2NSVXE4OHE5WjhSUzAtNDhjRTFpSEprTDB1Z2JIdUZMdXM5TDZzcFp5OG5YOU1QMkNOZG9tVmFwb3NxdTNmR2F5VDhUOC1qSlF3aGVwb19VdHBnQlFhREVVb20wNGRaaEFOMWFKQkRsVUtKQnhFMWNlQjJTbWowTWxuLUlCVzVBRlUyZHdVaWt0dF8yUWFxMmRCZmFLZEV1cDg1VVY3WWQtZEtqbG5rYWJsMlB2cjBEVGtUcmVNXG4gICAgaW52YXJpYW50KGJsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJ1bmJsb2NrZWRcIiB8fCBibG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiLCBcIkludmFsaWQgYmxvY2tlciBzdGF0ZSB0cmFuc2l0aW9uOiBcIiArIGJsb2NrZXIuc3RhdGUgKyBcIiAtPiBcIiArIG5ld0Jsb2NrZXIuc3RhdGUpO1xuICAgIGxldCBibG9ja2VycyA9IG5ldyBNYXAoc3RhdGUuYmxvY2tlcnMpO1xuICAgIGJsb2NrZXJzLnNldChrZXksIG5ld0Jsb2NrZXIpO1xuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIGJsb2NrZXJzXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKF9yZWY0KSB7XG4gICAgbGV0IHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICB9ID0gX3JlZjQ7XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBXZSBvbnkgc3VwcG9ydCBhIHNpbmdsZSBhY3RpdmUgYmxvY2tlciBhdCB0aGUgbW9tZW50IHNpbmNlIHdlIGRvbid0IGhhdmVcbiAgICAvLyBhbnkgY29tcGVsbGluZyB1c2UgY2FzZXMgZm9yIG11bHRpLWJsb2NrZXIgeWV0XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA+IDEpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsIFwiQSByb3V0ZXIgb25seSBzdXBwb3J0cyBvbmUgYmxvY2tlciBhdCBhIHRpbWVcIik7XG4gICAgfVxuICAgIGxldCBlbnRyaWVzID0gQXJyYXkuZnJvbShibG9ja2VyRnVuY3Rpb25zLmVudHJpZXMoKSk7XG4gICAgbGV0IFtibG9ja2VyS2V5LCBibG9ja2VyRnVuY3Rpb25dID0gZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdO1xuICAgIGxldCBibG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGJsb2NrZXJLZXkpO1xuICAgIGlmIChibG9ja2VyICYmIGJsb2NrZXIuc3RhdGUgPT09IFwicHJvY2VlZGluZ1wiKSB7XG4gICAgICAvLyBJZiB0aGUgYmxvY2tlciBpcyBjdXJyZW50bHkgcHJvY2VlZGluZywgd2UgZG9uJ3QgbmVlZCB0byByZS1jaGVja1xuICAgICAgLy8gaXQgYW5kIGNhbiBsZXQgdGhpcyBuYXZpZ2F0aW9uIGNvbnRpbnVlXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGtub3cgd2UncmUgdW5ibG9ja2VkL2Jsb2NrZWQgc28gd2UgbmVlZCB0byBjaGVjayB0aGVcbiAgICAvLyB1c2VyLXByb3ZpZGVkIGJsb2NrZXIgZnVuY3Rpb25cbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9uKHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICB9KSkge1xuICAgICAgcmV0dXJuIGJsb2NrZXJLZXk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNhbmNlbEFjdGl2ZURlZmVycmVkcyhwcmVkaWNhdGUpIHtcbiAgICBsZXQgY2FuY2VsbGVkUm91dGVJZHMgPSBbXTtcbiAgICBhY3RpdmVEZWZlcnJlZHMuZm9yRWFjaCgoZGZkLCByb3V0ZUlkKSA9PiB7XG4gICAgICBpZiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUocm91dGVJZCkpIHtcbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBkZWZlcnJlZCAtIGJ1dCBkbyBub3QgcmVtb3ZlIGZyb20gYWN0aXZlRGVmZXJyZWRzIGhlcmUgLVxuICAgICAgICAvLyB3ZSByZWx5IG9uIHRoZSBzdWJzY3JpYmVycyB0byBkbyB0aGF0IHNvIG91ciB0ZXN0cyBjYW4gYXNzZXJ0IHByb3BlclxuICAgICAgICAvLyBjbGVhbnVwIHZpYSBfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHNcbiAgICAgICAgZGZkLmNhbmNlbCgpO1xuICAgICAgICBjYW5jZWxsZWRSb3V0ZUlkcy5wdXNoKHJvdXRlSWQpO1xuICAgICAgICBhY3RpdmVEZWZlcnJlZHMuZGVsZXRlKHJvdXRlSWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjYW5jZWxsZWRSb3V0ZUlkcztcbiAgfVxuICAvLyBPcHQgaW4gdG8gY2FwdHVyaW5nIGFuZCByZXBvcnRpbmcgc2Nyb2xsIHBvc2l0aW9ucyBkdXJpbmcgbmF2aWdhdGlvbnMsXG4gIC8vIHVzZWQgYnkgdGhlIDxTY3JvbGxSZXN0b3JhdGlvbj4gY29tcG9uZW50XG4gIGZ1bmN0aW9uIGVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uKHBvc2l0aW9ucywgZ2V0UG9zaXRpb24sIGdldEtleSkge1xuICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgIGdldFNjcm9sbFBvc2l0aW9uID0gZ2V0UG9zaXRpb247XG4gICAgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkgPSBnZXRLZXkgfHwgbnVsbDtcbiAgICAvLyBQZXJmb3JtIGluaXRpYWwgaHlkcmF0aW9uIHNjcm9sbCByZXN0b3JhdGlvbiwgc2luY2Ugd2UgbWlzcyB0aGUgYm9hdCBvblxuICAgIC8vIHRoZSBpbml0aWFsIHVwZGF0ZVN0YXRlKCkgYmVjYXVzZSB3ZSd2ZSBub3QgeWV0IHJlbmRlcmVkIDxTY3JvbGxSZXN0b3JhdGlvbi8+XG4gICAgLy8gYW5kIHRoZXJlZm9yZSBoYXZlIG5vIHNhdmVkU2Nyb2xsUG9zaXRpb25zIGF2YWlsYWJsZVxuICAgIGlmICghaW5pdGlhbFNjcm9sbFJlc3RvcmVkICYmIHN0YXRlLm5hdmlnYXRpb24gPT09IElETEVfTkFWSUdBVElPTikge1xuICAgICAgaW5pdGlhbFNjcm9sbFJlc3RvcmVkID0gdHJ1ZTtcbiAgICAgIGxldCB5ID0gZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihzdGF0ZS5sb2NhdGlvbiwgc3RhdGUubWF0Y2hlcyk7XG4gICAgICBpZiAoeSAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IG51bGw7XG4gICAgICBnZXRTY3JvbGxQb3NpdGlvbiA9IG51bGw7XG4gICAgICBnZXRTY3JvbGxSZXN0b3JhdGlvbktleSA9IG51bGw7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBnZXRTY3JvbGxLZXkobG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBpZiAoZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkpIHtcbiAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxSZXN0b3JhdGlvbktleShsb2NhdGlvbiwgbWF0Y2hlcy5tYXAobSA9PiBjb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaChtLCBzdGF0ZS5sb2FkZXJEYXRhKSkpO1xuICAgICAgcmV0dXJuIGtleSB8fCBsb2NhdGlvbi5rZXk7XG4gICAgfVxuICAgIHJldHVybiBsb2NhdGlvbi5rZXk7XG4gIH1cbiAgZnVuY3Rpb24gc2F2ZVNjcm9sbFBvc2l0aW9uKGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgaWYgKHNhdmVkU2Nyb2xsUG9zaXRpb25zICYmIGdldFNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zW2tleV0gPSBnZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgaWYgKHNhdmVkU2Nyb2xsUG9zaXRpb25zKSB7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgIGxldCB5ID0gc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgeSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4geTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gX2ludGVybmFsU2V0Um91dGVzKG5ld1JvdXRlcykge1xuICAgIG1hbmlmZXN0ID0ge307XG4gICAgaW5GbGlnaHREYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhuZXdSb3V0ZXMsIG1hcFJvdXRlUHJvcGVydGllcywgdW5kZWZpbmVkLCBtYW5pZmVzdCk7XG4gIH1cbiAgcm91dGVyID0ge1xuICAgIGdldCBiYXNlbmFtZSgpIHtcbiAgICAgIHJldHVybiBiYXNlbmFtZTtcbiAgICB9LFxuICAgIGdldCBmdXR1cmUoKSB7XG4gICAgICByZXR1cm4gZnV0dXJlO1xuICAgIH0sXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgZ2V0IHJvdXRlcygpIHtcbiAgICAgIHJldHVybiBkYXRhUm91dGVzO1xuICAgIH0sXG4gICAgZ2V0IHdpbmRvdygpIHtcbiAgICAgIHJldHVybiByb3V0ZXJXaW5kb3c7XG4gICAgfSxcbiAgICBpbml0aWFsaXplLFxuICAgIHN1YnNjcmliZSxcbiAgICBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbixcbiAgICBuYXZpZ2F0ZSxcbiAgICBmZXRjaCxcbiAgICByZXZhbGlkYXRlLFxuICAgIC8vIFBhc3N0aHJvdWdoIHRvIGhpc3RvcnktYXdhcmUgY3JlYXRlSHJlZiB1c2VkIGJ5IHVzZUhyZWYgc28gd2UgZ2V0IHByb3BlclxuICAgIC8vIGhhc2gtYXdhcmUgVVJMcyBpbiBET00gcGF0aHNcbiAgICBjcmVhdGVIcmVmOiB0byA9PiBpbml0Lmhpc3RvcnkuY3JlYXRlSHJlZih0byksXG4gICAgZW5jb2RlTG9jYXRpb246IHRvID0+IGluaXQuaGlzdG9yeS5lbmNvZGVMb2NhdGlvbih0byksXG4gICAgZ2V0RmV0Y2hlcixcbiAgICBkZWxldGVGZXRjaGVyOiBkZWxldGVGZXRjaGVyQW5kVXBkYXRlU3RhdGUsXG4gICAgZGlzcG9zZSxcbiAgICBnZXRCbG9ja2VyLFxuICAgIGRlbGV0ZUJsb2NrZXIsXG4gICAgX2ludGVybmFsRmV0Y2hDb250cm9sbGVyczogZmV0Y2hDb250cm9sbGVycyxcbiAgICBfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHM6IGFjdGl2ZURlZmVycmVkcyxcbiAgICAvLyBUT0RPOiBSZW1vdmUgc2V0Um91dGVzLCBpdCdzIHRlbXBvcmFyeSB0byBhdm9pZCBkZWFsaW5nIHdpdGhcbiAgICAvLyB1cGRhdGluZyB0aGUgdHJlZSB3aGlsZSB2YWxpZGF0aW5nIHRoZSB1cGRhdGUgYWxnb3JpdGhtLlxuICAgIF9pbnRlcm5hbFNldFJvdXRlc1xuICB9O1xuICByZXR1cm4gcm91dGVyO1xufVxuLy8jZW5kcmVnaW9uXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5jb25zdCBVTlNBRkVfREVGRVJSRURfU1lNQk9MID0gU3ltYm9sKFwiZGVmZXJyZWRcIik7XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNIYW5kbGVyKHJvdXRlcywgb3B0cykge1xuICBpbnZhcmlhbnQocm91dGVzLmxlbmd0aCA+IDAsIFwiWW91IG11c3QgcHJvdmlkZSBhIG5vbi1lbXB0eSByb3V0ZXMgYXJyYXkgdG8gY3JlYXRlU3RhdGljSGFuZGxlclwiKTtcbiAgbGV0IG1hbmlmZXN0ID0ge307XG4gIGxldCBiYXNlbmFtZSA9IChvcHRzID8gb3B0cy5iYXNlbmFtZSA6IG51bGwpIHx8IFwiL1wiO1xuICBsZXQgbWFwUm91dGVQcm9wZXJ0aWVzO1xuICBpZiAob3B0cyAhPSBudWxsICYmIG9wdHMubWFwUm91dGVQcm9wZXJ0aWVzKSB7XG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzID0gb3B0cy5tYXBSb3V0ZVByb3BlcnRpZXM7XG4gIH0gZWxzZSBpZiAob3B0cyAhPSBudWxsICYmIG9wdHMuZGV0ZWN0RXJyb3JCb3VuZGFyeSkge1xuICAgIC8vIElmIHRoZXkgYXJlIHN0aWxsIHVzaW5nIHRoZSBkZXByZWNhdGVkIHZlcnNpb24sIHdyYXAgaXQgd2l0aCB0aGUgbmV3IEFQSVxuICAgIGxldCBkZXRlY3RFcnJvckJvdW5kYXJ5ID0gb3B0cy5kZXRlY3RFcnJvckJvdW5kYXJ5O1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IHJvdXRlID0+ICh7XG4gICAgICBoYXNFcnJvckJvdW5kYXJ5OiBkZXRlY3RFcnJvckJvdW5kYXJ5KHJvdXRlKVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IGRlZmF1bHRNYXBSb3V0ZVByb3BlcnRpZXM7XG4gIH1cbiAgLy8gQ29uZmlnIGRyaXZlbiBiZWhhdmlvciBmbGFnc1xuICBsZXQgZnV0dXJlID0gX2V4dGVuZHMoe1xuICAgIHY3X3JlbGF0aXZlU3BsYXRQYXRoOiBmYWxzZSxcbiAgICB2N190aHJvd0Fib3J0UmVhc29uOiBmYWxzZVxuICB9LCBvcHRzID8gb3B0cy5mdXR1cmUgOiBudWxsKTtcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKHJvdXRlcywgbWFwUm91dGVQcm9wZXJ0aWVzLCB1bmRlZmluZWQsIG1hbmlmZXN0KTtcbiAgLyoqXG4gICAqIFRoZSBxdWVyeSgpIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgZG9jdW1lbnQgcmVxdWVzdHMsIGluIHdoaWNoIHdlIHdhbnQgdG9cbiAgICogY2FsbCBhbiBvcHRpb25hbCBhY3Rpb24gYW5kIHBvdGVudGlhbGx5IG11bHRpcGxlIGxvYWRlcnMgZm9yIGFsbCBuZXN0ZWRcbiAgICogcm91dGVzLiAgSXQgcmV0dXJucyBhIFN0YXRpY0hhbmRsZXJDb250ZXh0IG9iamVjdCwgd2hpY2ggaXMgdmVyeSBzaW1pbGFyXG4gICAqIHRvIHRoZSByb3V0ZXIgc3RhdGUgKGxvY2F0aW9uLCBsb2FkZXJEYXRhLCBhY3Rpb25EYXRhLCBlcnJvcnMsIGV0Yy4pIGFuZFxuICAgKiBhbHNvIGFkZHMgU1NSLXNwZWNpZmljIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHN0YXR1c0NvZGUgYW5kIGhlYWRlcnNcbiAgICogZnJvbSBhY3Rpb24vbG9hZGVycyBSZXNwb25zZXMuXG4gICAqXG4gICAqIEl0IF9zaG91bGRfIG5ldmVyIHRocm93IGFuZCBzaG91bGQgcmVwb3J0IGFsbCBlcnJvcnMgdGhyb3VnaCB0aGVcbiAgICogcmV0dXJuZWQgY29udGV4dC5lcnJvcnMgb2JqZWN0LCBwcm9wZXJseSBhc3NvY2lhdGluZyBlcnJvcnMgdG8gdGhlaXIgZXJyb3JcbiAgICogYm91bmRhcnkuICBBZGRpdGlvbmFsbHksIGl0IHRyYWNrcyBfZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCB3aGljaCBjYW4gYmVcbiAgICogdXNlZCB0byBlbXVsYXRlIFJlYWN0IGVycm9yIGJvdW5kYXJpZXMgZHVyaW5nIFNTciBieSBwZXJmb3JtaW5nIGEgc2Vjb25kXG4gICAqIHBhc3Mgb25seSBkb3duIHRvIHRoZSBib3VuZGFyeUlkLlxuICAgKlxuICAgKiBUaGUgb25lIGV4Y2VwdGlvbiB3aGVyZSB3ZSBkbyBub3QgcmV0dXJuIGEgU3RhdGljSGFuZGxlckNvbnRleHQgaXMgd2hlbiBhXG4gICAqIHJlZGlyZWN0IHJlc3BvbnNlIGlzIHJldHVybmVkIG9yIHRocm93biBmcm9tIGFueSBhY3Rpb24vbG9hZGVyLiAgV2VcbiAgICogcHJvcGFnYXRlIHRoYXQgb3V0IGFuZCByZXR1cm4gdGhlIHJhdyBSZXNwb25zZSBzbyB0aGUgSFRUUCBzZXJ2ZXIgY2FuXG4gICAqIHJldHVybiBpdCBkaXJlY3RseS5cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5KHJlcXVlc3QsIF90ZW1wMykge1xuICAgIGxldCB7XG4gICAgICByZXF1ZXN0Q29udGV4dFxuICAgIH0gPSBfdGVtcDMgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAzO1xuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBsZXQgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXCJcIiwgY3JlYXRlUGF0aCh1cmwpLCBudWxsLCBcImRlZmF1bHRcIik7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xuICAgIC8vIFNTUiBzdXBwb3J0cyBIRUFEIHJlcXVlc3RzIHdoaWxlIFNQQSBkb2Vzbid0XG4gICAgaWYgKCFpc1ZhbGlkTWV0aG9kKG1ldGhvZCkgJiYgbWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgbWV0aG9kXG4gICAgICB9KTtcbiAgICAgIGxldCB7XG4gICAgICAgIG1hdGNoZXM6IG1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzLFxuICAgICAgICByb3V0ZVxuICAgICAgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXM6IG1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3JcbiAgICAgICAgfSxcbiAgICAgICAgc3RhdHVzQ29kZTogZXJyb3Iuc3RhdHVzLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge30sXG4gICAgICAgIGFjdGl2ZURlZmVycmVkczogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgIH0pO1xuICAgICAgbGV0IHtcbiAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICByb3V0ZVxuICAgICAgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXR1c0NvZGU6IGVycm9yLnN0YXR1cyxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9LFxuICAgICAgICBhY3RpdmVEZWZlcnJlZHM6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBxdWVyeUltcGwocmVxdWVzdCwgbG9jYXRpb24sIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0KTtcbiAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBXaGVuIHJldHVybmluZyBTdGF0aWNIYW5kbGVyQ29udGV4dCwgd2UgcGF0Y2ggYmFjayBpbiB0aGUgbG9jYXRpb24gaGVyZVxuICAgIC8vIHNpbmNlIHdlIG5lZWQgaXQgZm9yIFJlYWN0IENvbnRleHQuICBCdXQgdGhpcyBoZWxwcyBrZWVwIG91ciBzdWJtaXQgYW5kXG4gICAgLy8gbG9hZFJvdXRlRGF0YSBvcGVyYXRpbmcgb24gYSBSZXF1ZXN0IGluc3RlYWQgb2YgYSBMb2NhdGlvblxuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBsb2NhdGlvbixcbiAgICAgIGJhc2VuYW1lXG4gICAgfSwgcmVzdWx0KTtcbiAgfVxuICAvKipcbiAgICogVGhlIHF1ZXJ5Um91dGUoKSBtZXRob2QgaXMgaW50ZW5kZWQgZm9yIHRhcmdldGVkIHJvdXRlIHJlcXVlc3RzLCBlaXRoZXJcbiAgICogZm9yIGZldGNoID9fZGF0YSByZXF1ZXN0cyBvciByZXNvdXJjZSByb3V0ZSByZXF1ZXN0cy4gIEluIHRoaXMgY2FzZSwgd2VcbiAgICogYXJlIG9ubHkgZXZlciBjYWxsaW5nIGEgc2luZ2xlIGFjdGlvbiBvciBsb2FkZXIsIGFuZCB3ZSBhcmUgcmV0dXJuaW5nIHRoZVxuICAgKiByZXR1cm5lZCB2YWx1ZSBkaXJlY3RseS4gIEluIG1vc3QgY2FzZXMsIHRoaXMgd2lsbCBiZSBhIFJlc3BvbnNlIHJldHVybmVkXG4gICAqIGZyb20gdGhlIGFjdGlvbi9sb2FkZXIsIGJ1dCBpdCBtYXkgYmUgYSBwcmltaXRpdmUgb3Igb3RoZXIgdmFsdWUgYXMgd2VsbCAtXG4gICAqIGFuZCBpbiBzdWNoIGNhc2VzIHRoZSBjYWxsaW5nIGNvbnRleHQgc2hvdWxkIGhhbmRsZSB0aGF0IGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBXZSBkbyByZXNwZWN0IHRoZSB0aHJvdy9yZXR1cm4gZGlmZmVyZW50aWF0aW9uLCBzbyBpZiBhbiBhY3Rpb24vbG9hZGVyXG4gICAqIHRocm93cywgdGhlbiB0aGlzIG1ldGhvZCB3aWxsIHRocm93IHRoZSB2YWx1ZS4gIFRoaXMgaXMgaW1wb3J0YW50IHNvIHdlXG4gICAqIGNhbiBkbyBwcm9wZXIgYm91bmRhcnkgaWRlbnRpZmljYXRpb24gaW4gUmVtaXggd2hlcmUgYSB0aHJvd24gUmVzcG9uc2VcbiAgICogbXVzdCBnbyB0byB0aGUgQ2F0Y2ggQm91bmRhcnkgYnV0IGEgcmV0dXJuZWQgUmVzcG9uc2UgaXMgaGFwcHktcGF0aC5cbiAgICpcbiAgICogT25lIHRoaW5nIHRvIG5vdGUgaXMgdGhhdCBhbnkgUm91dGVyLWluaXRpYXRlZCBFcnJvcnMgdGhhdCBtYWtlIHNlbnNlXG4gICAqIHRvIGFzc29jaWF0ZSB3aXRoIGEgc3RhdHVzIGNvZGUgd2lsbCBiZSB0aHJvd24gYXMgYW4gRXJyb3JSZXNwb25zZVxuICAgKiBpbnN0YW5jZSB3aGljaCBpbmNsdWRlIHRoZSByYXcgRXJyb3IsIHN1Y2ggdGhhdCB0aGUgY2FsbGluZyBjb250ZXh0IGNhblxuICAgKiBzZXJpYWxpemUgdGhlIGVycm9yIGFzIHRoZXkgc2VlIGZpdCB3aGlsZSBpbmNsdWRpbmcgdGhlIHByb3BlciByZXNwb25zZVxuICAgKiBjb2RlLiAgRXhhbXBsZXMgaGVyZSBhcmUgNDA0IGFuZCA0MDUgZXJyb3JzIHRoYXQgb2NjdXIgcHJpb3IgdG8gcmVhY2hpbmdcbiAgICogYW55IHVzZXItZGVmaW5lZCBsb2FkZXJzLlxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnlSb3V0ZShyZXF1ZXN0LCBfdGVtcDQpIHtcbiAgICBsZXQge1xuICAgICAgcm91dGVJZCxcbiAgICAgIHJlcXVlc3RDb250ZXh0XG4gICAgfSA9IF90ZW1wNCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDQ7XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcIlwiLCBjcmVhdGVQYXRoKHVybCksIG51bGwsIFwiZGVmYXVsdFwiKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gICAgLy8gU1NSIHN1cHBvcnRzIEhFQUQgcmVxdWVzdHMgd2hpbGUgU1BBIGRvZXNuJ3RcbiAgICBpZiAoIWlzVmFsaWRNZXRob2QobWV0aG9kKSAmJiBtZXRob2QgIT09IFwiSEVBRFwiICYmIG1ldGhvZCAhPT0gXCJPUFRJT05TXCIpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgIG1ldGhvZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghbWF0Y2hlcykge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IG1hdGNoID0gcm91dGVJZCA/IG1hdGNoZXMuZmluZChtID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpIDogZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pO1xuICAgIGlmIChyb3V0ZUlkICYmICFtYXRjaCkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDMsIHtcbiAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICByb3V0ZUlkXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaCkge1xuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGl0IEkgZG9uJ3QgdGhpbms/XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgcXVlcnlJbXBsKHJlcXVlc3QsIGxvY2F0aW9uLCBtYXRjaGVzLCByZXF1ZXN0Q29udGV4dCwgbWF0Y2gpO1xuICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxldCBlcnJvciA9IHJlc3VsdC5lcnJvcnMgPyBPYmplY3QudmFsdWVzKHJlc3VsdC5lcnJvcnMpWzBdIDogdW5kZWZpbmVkO1xuICAgIGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiB3ZSBnb3QgYmFjayByZXN1bHQuZXJyb3JzLCB0aGF0IG1lYW5zIHRoZSBsb2FkZXIvYWN0aW9uIHRocmV3XG4gICAgICAvLyBfc29tZXRoaW5nXyB0aGF0IHdhc24ndCBhIFJlc3BvbnNlLCBidXQgaXQncyBub3QgZ3VhcmFudGVlZC9yZXF1aXJlZFxuICAgICAgLy8gdG8gYmUgYW4gYGluc3RhbmNlb2YgRXJyb3JgIGVpdGhlciwgc28gd2UgaGF2ZSB0byB1c2UgdGhyb3cgaGVyZSB0b1xuICAgICAgLy8gcHJlc2VydmUgdGhlIFwiZXJyb3JcIiBzdGF0ZSBvdXRzaWRlIG9mIHF1ZXJ5SW1wbC5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICAvLyBQaWNrIG9mZiB0aGUgcmlnaHQgc3RhdGUgdmFsdWUgdG8gcmV0dXJuXG4gICAgaWYgKHJlc3VsdC5hY3Rpb25EYXRhKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyZXN1bHQuYWN0aW9uRGF0YSlbMF07XG4gICAgfVxuICAgIGlmIChyZXN1bHQubG9hZGVyRGF0YSkge1xuICAgICAgdmFyIF9yZXN1bHQkYWN0aXZlRGVmZXJyZTtcbiAgICAgIGxldCBkYXRhID0gT2JqZWN0LnZhbHVlcyhyZXN1bHQubG9hZGVyRGF0YSlbMF07XG4gICAgICBpZiAoKF9yZXN1bHQkYWN0aXZlRGVmZXJyZSA9IHJlc3VsdC5hY3RpdmVEZWZlcnJlZHMpICE9IG51bGwgJiYgX3Jlc3VsdCRhY3RpdmVEZWZlcnJlW21hdGNoLnJvdXRlLmlkXSkge1xuICAgICAgICBkYXRhW1VOU0FGRV9ERUZFUlJFRF9TWU1CT0xdID0gcmVzdWx0LmFjdGl2ZURlZmVycmVkc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBxdWVyeUltcGwocmVxdWVzdCwgbG9jYXRpb24sIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCByb3V0ZU1hdGNoKSB7XG4gICAgaW52YXJpYW50KHJlcXVlc3Quc2lnbmFsLCBcInF1ZXJ5KCkvcXVlcnlSb3V0ZSgpIHJlcXVlc3RzIG11c3QgY29udGFpbiBhbiBBYm9ydENvbnRyb2xsZXIgc2lnbmFsXCIpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaXNNdXRhdGlvbk1ldGhvZChyZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgc3VibWl0KHJlcXVlc3QsIG1hdGNoZXMsIHJvdXRlTWF0Y2ggfHwgZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pLCByZXF1ZXN0Q29udGV4dCwgcm91dGVNYXRjaCAhPSBudWxsKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBsb2FkUm91dGVEYXRhKHJlcXVlc3QsIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCByb3V0ZU1hdGNoKTtcbiAgICAgIHJldHVybiBpc1Jlc3BvbnNlKHJlc3VsdCkgPyByZXN1bHQgOiBfZXh0ZW5kcyh7fSwgcmVzdWx0LCB7XG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB0aHJldy9yZXR1cm5lZCBhIFJlc3BvbnNlIGluIGNhbGxMb2FkZXJPckFjdGlvbiwgd2UgdGhyb3dcbiAgICAgIC8vIGl0IHRvIGJhaWwgb3V0IGFuZCB0aGVuIHJldHVybiBvciB0aHJvdyBoZXJlIGJhc2VkIG9uIHdoZXRoZXIgdGhlIHVzZXJcbiAgICAgIC8vIHJldHVybmVkIG9yIHRocmV3XG4gICAgICBpZiAoaXNRdWVyeVJvdXRlUmVzcG9uc2UoZSkpIHtcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcikge1xuICAgICAgICAgIHRocm93IGUucmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUucmVzcG9uc2U7XG4gICAgICB9XG4gICAgICAvLyBSZWRpcmVjdHMgYXJlIGFsd2F5cyByZXR1cm5lZCBzaW5jZSB0aGV5IGRvbid0IHByb3BhZ2F0ZSB0byBjYXRjaFxuICAgICAgLy8gYm91bmRhcmllc1xuICAgICAgaWYgKGlzUmVkaXJlY3RSZXNwb25zZShlKSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN1Ym1pdChyZXF1ZXN0LCBtYXRjaGVzLCBhY3Rpb25NYXRjaCwgcmVxdWVzdENvbnRleHQsIGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoIWFjdGlvbk1hdGNoLnJvdXRlLmFjdGlvbiAmJiAhYWN0aW9uTWF0Y2gucm91dGUubGF6eSkge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgcGF0aG5hbWU6IG5ldyBVUkwocmVxdWVzdC51cmwpLnBhdGhuYW1lLFxuICAgICAgICByb3V0ZUlkOiBhY3Rpb25NYXRjaC5yb3V0ZS5pZFxuICAgICAgfSk7XG4gICAgICBpZiAoaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBjYWxsTG9hZGVyT3JBY3Rpb24oXCJhY3Rpb25cIiwgcmVxdWVzdCwgYWN0aW9uTWF0Y2gsIG1hdGNoZXMsIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMsIGJhc2VuYW1lLCBmdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgsIHtcbiAgICAgICAgaXNTdGF0aWNSZXF1ZXN0OiB0cnVlLFxuICAgICAgICBpc1JvdXRlUmVxdWVzdCxcbiAgICAgICAgcmVxdWVzdENvbnRleHRcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgdGhyb3dTdGF0aWNIYW5kbGVyQWJvcnRlZEVycm9yKHJlcXVlc3QsIGlzUm91dGVSZXF1ZXN0LCBmdXR1cmUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBVaGhoaCAtIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgd2Ugc2hvdWxkIGFsd2F5cyB0aHJvdyB0aGVzZSBmcm9tXG4gICAgICAvLyBjYWxsTG9hZGVyT3JBY3Rpb24sIGJ1dCB0aGUgdHlwZSBuYXJyb3dpbmcgaGVyZSBrZWVwcyBUUyBoYXBweSBhbmQgd2VcbiAgICAgIC8vIGNhbiBnZXQgYmFjayBvbiB0aGUgXCJ0aHJvdyBhbGwgcmVkaXJlY3QgcmVzcG9uc2VzXCIgdHJhaW4gaGVyZSBzaG91bGRcbiAgICAgIC8vIHRoaXMgZXZlciBoYXBwZW4gOi9cbiAgICAgIHRocm93IG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiByZXN1bHQubG9jYXRpb25cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAwLCB7XG4gICAgICAgIHR5cGU6IFwiZGVmZXItYWN0aW9uXCJcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvclxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAvLyBOb3RlOiBUaGlzIHNob3VsZCBvbmx5IGJlIG5vbi1SZXNwb25zZSB2YWx1ZXMgaWYgd2UgZ2V0IGhlcmUsIHNpbmNlXG4gICAgICAvLyBpc1JvdXRlUmVxdWVzdCBzaG91bGQgdGhyb3cgYW55IFJlc3BvbnNlIHJlY2VpdmVkIGluIGNhbGxMb2FkZXJPckFjdGlvblxuICAgICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzOiBbYWN0aW9uTWF0Y2hdLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YToge1xuICAgICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5kYXRhXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yczogbnVsbCxcbiAgICAgICAgLy8gTm90ZTogc3RhdHVzQ29kZSArIGhlYWRlcnMgYXJlIHVudXNlZCBoZXJlIHNpbmNlIHF1ZXJ5Um91dGUgd2lsbFxuICAgICAgICAvLyByZXR1cm4gdGhlIHJhdyBSZXNwb25zZSBvciB2YWx1ZVxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBTdG9yZSBvZmYgdGhlIHBlbmRpbmcgZXJyb3IgLSB3ZSB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoaWNoIGxvYWRlcnNcbiAgICAgIC8vIHRvIGNhbGwgYW5kIHdpbGwgY29tbWl0IGl0IHdoZW4gd2UgY29tcGxldGUgdGhlIG5hdmlnYXRpb25cbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG4gICAgICBsZXQgY29udGV4dCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEocmVxdWVzdCwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQsIHVuZGVmaW5lZCwge1xuICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5lcnJvclxuICAgICAgfSk7XG4gICAgICAvLyBhY3Rpb24gc3RhdHVzIGNvZGVzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGxvYWRlciBzdGF0dXMgY29kZXNcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgY29udGV4dCwge1xuICAgICAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpID8gcmVzdWx0LmVycm9yLnN0YXR1cyA6IDUwMCxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgYWN0aW9uSGVhZGVyczogX2V4dGVuZHMoe30sIHJlc3VsdC5oZWFkZXJzID8ge1xuICAgICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzXG4gICAgICAgIH0gOiB7fSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBHRVQgcmVxdWVzdCBmb3IgdGhlIGxvYWRlcnNcbiAgICBsZXQgbG9hZGVyUmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QudXJsLCB7XG4gICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMsXG4gICAgICByZWRpcmVjdDogcmVxdWVzdC5yZWRpcmVjdCxcbiAgICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWxcbiAgICB9KTtcbiAgICBsZXQgY29udGV4dCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEobG9hZGVyUmVxdWVzdCwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQpO1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgY29udGV4dCwgcmVzdWx0LnN0YXR1c0NvZGUgPyB7XG4gICAgICBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzQ29kZVxuICAgIH0gOiB7fSwge1xuICAgICAgYWN0aW9uRGF0YToge1xuICAgICAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YVxuICAgICAgfSxcbiAgICAgIGFjdGlvbkhlYWRlcnM6IF9leHRlbmRzKHt9LCByZXN1bHQuaGVhZGVycyA/IHtcbiAgICAgICAgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnNcbiAgICAgIH0gOiB7fSlcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBsb2FkUm91dGVEYXRhKHJlcXVlc3QsIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCByb3V0ZU1hdGNoLCBwZW5kaW5nQWN0aW9uRXJyb3IpIHtcbiAgICBsZXQgaXNSb3V0ZVJlcXVlc3QgPSByb3V0ZU1hdGNoICE9IG51bGw7XG4gICAgLy8gU2hvcnQgY2lyY3VpdCBpZiB3ZSBoYXZlIG5vIGxvYWRlcnMgdG8gcnVuIChxdWVyeVJvdXRlKCkpXG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0ICYmICEocm91dGVNYXRjaCAhPSBudWxsICYmIHJvdXRlTWF0Y2gucm91dGUubG9hZGVyKSAmJiAhKHJvdXRlTWF0Y2ggIT0gbnVsbCAmJiByb3V0ZU1hdGNoLnJvdXRlLmxhenkpKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQ6IHJvdXRlTWF0Y2ggPT0gbnVsbCA/IHZvaWQgMCA6IHJvdXRlTWF0Y2gucm91dGUuaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgcmVxdWVzdE1hdGNoZXMgPSByb3V0ZU1hdGNoID8gW3JvdXRlTWF0Y2hdIDogZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkobWF0Y2hlcywgT2JqZWN0LmtleXMocGVuZGluZ0FjdGlvbkVycm9yIHx8IHt9KVswXSk7XG4gICAgbGV0IG1hdGNoZXNUb0xvYWQgPSByZXF1ZXN0TWF0Y2hlcy5maWx0ZXIobSA9PiBtLnJvdXRlLmxvYWRlciB8fCBtLnJvdXRlLmxhenkpO1xuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgd2UgaGF2ZSBubyBsb2FkZXJzIHRvIHJ1biAocXVlcnkoKSlcbiAgICBpZiAobWF0Y2hlc1RvTG9hZC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIC8vIEFkZCBhIG51bGwgZm9yIGFsbCBtYXRjaGVkIHJvdXRlcyBmb3IgcHJvcGVyIHJldmFsaWRhdGlvbiBvbiB0aGUgY2xpZW50XG4gICAgICAgIGxvYWRlckRhdGE6IG1hdGNoZXMucmVkdWNlKChhY2MsIG0pID0+IE9iamVjdC5hc3NpZ24oYWNjLCB7XG4gICAgICAgICAgW20ucm91dGUuaWRdOiBudWxsXG4gICAgICAgIH0pLCB7fSksXG4gICAgICAgIGVycm9yczogcGVuZGluZ0FjdGlvbkVycm9yIHx8IG51bGwsXG4gICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGl2ZURlZmVycmVkczogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChbLi4ubWF0Y2hlc1RvTG9hZC5tYXAobWF0Y2ggPT4gY2FsbExvYWRlck9yQWN0aW9uKFwibG9hZGVyXCIsIHJlcXVlc3QsIG1hdGNoLCBtYXRjaGVzLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzLCBiYXNlbmFtZSwgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoLCB7XG4gICAgICBpc1N0YXRpY1JlcXVlc3Q6IHRydWUsXG4gICAgICBpc1JvdXRlUmVxdWVzdCxcbiAgICAgIHJlcXVlc3RDb250ZXh0XG4gICAgfSkpXSk7XG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHRocm93U3RhdGljSGFuZGxlckFib3J0ZWRFcnJvcihyZXF1ZXN0LCBpc1JvdXRlUmVxdWVzdCwgZnV0dXJlKTtcbiAgICB9XG4gICAgLy8gUHJvY2VzcyBhbmQgY29tbWl0IG91dHB1dCBmcm9tIGxvYWRlcnNcbiAgICBsZXQgYWN0aXZlRGVmZXJyZWRzID0gbmV3IE1hcCgpO1xuICAgIGxldCBjb250ZXh0ID0gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShtYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCByZXN1bHRzLCBwZW5kaW5nQWN0aW9uRXJyb3IsIGFjdGl2ZURlZmVycmVkcyk7XG4gICAgLy8gQWRkIGEgbnVsbCBmb3IgYW55IG5vbi1sb2FkZXIgbWF0Y2hlcyBmb3IgcHJvcGVyIHJldmFsaWRhdGlvbiBvbiB0aGUgY2xpZW50XG4gICAgbGV0IGV4ZWN1dGVkTG9hZGVycyA9IG5ldyBTZXQobWF0Y2hlc1RvTG9hZC5tYXAobWF0Y2ggPT4gbWF0Y2gucm91dGUuaWQpKTtcbiAgICBtYXRjaGVzLmZvckVhY2gobWF0Y2ggPT4ge1xuICAgICAgaWYgKCFleGVjdXRlZExvYWRlcnMuaGFzKG1hdGNoLnJvdXRlLmlkKSkge1xuICAgICAgICBjb250ZXh0LmxvYWRlckRhdGFbbWF0Y2gucm91dGUuaWRdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGNvbnRleHQsIHtcbiAgICAgIG1hdGNoZXMsXG4gICAgICBhY3RpdmVEZWZlcnJlZHM6IGFjdGl2ZURlZmVycmVkcy5zaXplID4gMCA/IE9iamVjdC5mcm9tRW50cmllcyhhY3RpdmVEZWZlcnJlZHMuZW50cmllcygpKSA6IG51bGxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRhdGFSb3V0ZXMsXG4gICAgcXVlcnksXG4gICAgcXVlcnlSb3V0ZVxuICB9O1xufVxuLy8jZW5kcmVnaW9uXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIEhlbHBlcnNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKipcbiAqIEdpdmVuIGFuIGV4aXN0aW5nIFN0YXRpY0hhbmRsZXJDb250ZXh0IGFuZCBhbiBlcnJvciB0aHJvd24gYXQgcmVuZGVyIHRpbWUsXG4gKiBwcm92aWRlIGFuIHVwZGF0ZWQgU3RhdGljSGFuZGxlckNvbnRleHQgc3VpdGFibGUgZm9yIGEgc2Vjb25kIFNTUiByZW5kZXJcbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvcihyb3V0ZXMsIGNvbnRleHQsIGVycm9yKSB7XG4gIGxldCBuZXdDb250ZXh0ID0gX2V4dGVuZHMoe30sIGNvbnRleHQsIHtcbiAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikgPyBlcnJvci5zdGF0dXMgOiA1MDAsXG4gICAgZXJyb3JzOiB7XG4gICAgICBbY29udGV4dC5fZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCB8fCByb3V0ZXNbMF0uaWRdOiBlcnJvclxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXdDb250ZXh0O1xufVxuZnVuY3Rpb24gdGhyb3dTdGF0aWNIYW5kbGVyQWJvcnRlZEVycm9yKHJlcXVlc3QsIGlzUm91dGVSZXF1ZXN0LCBmdXR1cmUpIHtcbiAgaWYgKGZ1dHVyZS52N190aHJvd0Fib3J0UmVhc29uICYmIHJlcXVlc3Quc2lnbmFsLnJlYXNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgcmVxdWVzdC5zaWduYWwucmVhc29uO1xuICB9XG4gIGxldCBtZXRob2QgPSBpc1JvdXRlUmVxdWVzdCA/IFwicXVlcnlSb3V0ZVwiIDogXCJxdWVyeVwiO1xuICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgXCIoKSBjYWxsIGFib3J0ZWQ6IFwiICsgcmVxdWVzdC5tZXRob2QgKyBcIiBcIiArIHJlcXVlc3QudXJsKTtcbn1cbmZ1bmN0aW9uIGlzU3VibWlzc2lvbk5hdmlnYXRpb24ob3B0cykge1xuICByZXR1cm4gb3B0cyAhPSBudWxsICYmIChcImZvcm1EYXRhXCIgaW4gb3B0cyAmJiBvcHRzLmZvcm1EYXRhICE9IG51bGwgfHwgXCJib2R5XCIgaW4gb3B0cyAmJiBvcHRzLmJvZHkgIT09IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVUbyhsb2NhdGlvbiwgbWF0Y2hlcywgYmFzZW5hbWUsIHByZXBlbmRCYXNlbmFtZSwgdG8sIHY3X3JlbGF0aXZlU3BsYXRQYXRoLCBmcm9tUm91dGVJZCwgcmVsYXRpdmUpIHtcbiAgbGV0IGNvbnRleHR1YWxNYXRjaGVzO1xuICBsZXQgYWN0aXZlUm91dGVNYXRjaDtcbiAgaWYgKGZyb21Sb3V0ZUlkKSB7XG4gICAgLy8gR3JhYiBtYXRjaGVzIHVwIHRvIHRoZSBjYWxsaW5nIHJvdXRlIHNvIG91ciByb3V0ZS1yZWxhdGl2ZSBsb2dpYyBpc1xuICAgIC8vIHJlbGF0aXZlIHRvIHRoZSBjb3JyZWN0IHNvdXJjZSByb3V0ZVxuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgY29udGV4dHVhbE1hdGNoZXMucHVzaChtYXRjaCk7XG4gICAgICBpZiAobWF0Y2gucm91dGUuaWQgPT09IGZyb21Sb3V0ZUlkKSB7XG4gICAgICAgIGFjdGl2ZVJvdXRlTWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gbWF0Y2hlcztcbiAgICBhY3RpdmVSb3V0ZU1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICB9XG4gIC8vIFJlc29sdmUgdGhlIHJlbGF0aXZlIHBhdGhcbiAgbGV0IHBhdGggPSByZXNvbHZlVG8odG8gPyB0byA6IFwiLlwiLCBnZXRSZXNvbHZlVG9NYXRjaGVzKGNvbnRleHR1YWxNYXRjaGVzLCB2N19yZWxhdGl2ZVNwbGF0UGF0aCksIHN0cmlwQmFzZW5hbWUobG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBsb2NhdGlvbi5wYXRobmFtZSwgcmVsYXRpdmUgPT09IFwicGF0aFwiKTtcbiAgLy8gV2hlbiBgdG9gIGlzIG5vdCBzcGVjaWZpZWQgd2UgaW5oZXJpdCBzZWFyY2gvaGFzaCBmcm9tIHRoZSBjdXJyZW50XG4gIC8vIGxvY2F0aW9uLCB1bmxpa2Ugd2hlbiB0bz1cIi5cIiBhbmQgd2UganVzdCBpbmhlcml0IHRoZSBwYXRoLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZW1peC9pc3N1ZXMvOTI3XG4gIGlmICh0byA9PSBudWxsKSB7XG4gICAgcGF0aC5zZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgcGF0aC5oYXNoID0gbG9jYXRpb24uaGFzaDtcbiAgfVxuICAvLyBBZGQgYW4gP2luZGV4IHBhcmFtIGZvciBtYXRjaGVkIGluZGV4IHJvdXRlcyBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgb25lXG4gIGlmICgodG8gPT0gbnVsbCB8fCB0byA9PT0gXCJcIiB8fCB0byA9PT0gXCIuXCIpICYmIGFjdGl2ZVJvdXRlTWF0Y2ggJiYgYWN0aXZlUm91dGVNYXRjaC5yb3V0ZS5pbmRleCAmJiAhaGFzTmFrZWRJbmRleFF1ZXJ5KHBhdGguc2VhcmNoKSkge1xuICAgIHBhdGguc2VhcmNoID0gcGF0aC5zZWFyY2ggPyBwYXRoLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgXCI/aW5kZXgmXCIpIDogXCI/aW5kZXhcIjtcbiAgfVxuICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lLiAgSWZcbiAgLy8gdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiBqdXN0IHVzZSB0aGUgcmF3IGJhc2VuYW1lIHdoaWNoIGFsbG93c1xuICAvLyB0aGUgYmFzZW5hbWUgdG8gaGF2ZSBmdWxsIGNvbnRyb2wgb3ZlciB0aGUgcHJlc2VuY2Ugb2YgYSB0cmFpbGluZyBzbGFzaFxuICAvLyBvbiByb290IGFjdGlvbnNcbiAgaWYgKHByZXBlbmRCYXNlbmFtZSAmJiBiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBwYXRoLnBhdGhuYW1lID0gcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlUGF0aChwYXRoKTtcbn1cbi8vIE5vcm1hbGl6ZSBuYXZpZ2F0aW9uIG9wdGlvbnMgYnkgY29udmVydGluZyBmb3JtTWV0aG9kPUdFVCBmb3JtRGF0YSBvYmplY3RzIHRvXG4vLyBVUkxTZWFyY2hQYXJhbXMgc28gdGhleSBiZWhhdmUgaWRlbnRpY2FsbHkgdG8gbGlua3Mgd2l0aCBxdWVyeSBwYXJhbXNcbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyhub3JtYWxpemVGb3JtTWV0aG9kLCBpc0ZldGNoZXIsIHBhdGgsIG9wdHMpIHtcbiAgLy8gUmV0dXJuIGxvY2F0aW9uIHZlcmJhdGltIG9uIG5vbi1zdWJtaXNzaW9uIG5hdmlnYXRpb25zXG4gIGlmICghb3B0cyB8fCAhaXNTdWJtaXNzaW9uTmF2aWdhdGlvbihvcHRzKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoXG4gICAgfTtcbiAgfVxuICBpZiAob3B0cy5mb3JtTWV0aG9kICYmICFpc1ZhbGlkTWV0aG9kKG9wdHMuZm9ybU1ldGhvZCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aCxcbiAgICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICBtZXRob2Q6IG9wdHMuZm9ybU1ldGhvZFxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIGxldCBnZXRJbnZhbGlkQm9keUVycm9yID0gKCkgPT4gKHtcbiAgICBwYXRoLFxuICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xuICAgICAgdHlwZTogXCJpbnZhbGlkLWJvZHlcIlxuICAgIH0pXG4gIH0pO1xuICAvLyBDcmVhdGUgYSBTdWJtaXNzaW9uIG9uIG5vbi1HRVQgbmF2aWdhdGlvbnNcbiAgbGV0IHJhd0Zvcm1NZXRob2QgPSBvcHRzLmZvcm1NZXRob2QgfHwgXCJnZXRcIjtcbiAgbGV0IGZvcm1NZXRob2QgPSBub3JtYWxpemVGb3JtTWV0aG9kID8gcmF3Rm9ybU1ldGhvZC50b1VwcGVyQ2FzZSgpIDogcmF3Rm9ybU1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICBsZXQgZm9ybUFjdGlvbiA9IHN0cmlwSGFzaEZyb21QYXRoKHBhdGgpO1xuICBpZiAob3B0cy5ib2R5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0cy5mb3JtRW5jVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcbiAgICAgIC8vIHRleHQgb25seSBzdXBwb3J0IFBPU1QvUFVUL1BBVENIL0RFTEVURSBzdWJtaXNzaW9uc1xuICAgICAgaWYgKCFpc011dGF0aW9uTWV0aG9kKGZvcm1NZXRob2QpKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XG4gICAgICB9XG4gICAgICBsZXQgdGV4dCA9IHR5cGVvZiBvcHRzLmJvZHkgPT09IFwic3RyaW5nXCIgPyBvcHRzLmJvZHkgOiBvcHRzLmJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSB8fCBvcHRzLmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgP1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybS1jb250cm9sLWluZnJhc3RydWN0dXJlLmh0bWwjcGxhaW4tdGV4dC1mb3JtLWRhdGFcbiAgICAgIEFycmF5LmZyb20ob3B0cy5ib2R5LmVudHJpZXMoKSkucmVkdWNlKChhY2MsIF9yZWY1KSA9PiB7XG4gICAgICAgIGxldCBbbmFtZSwgdmFsdWVdID0gX3JlZjU7XG4gICAgICAgIHJldHVybiBcIlwiICsgYWNjICsgbmFtZSArIFwiPVwiICsgdmFsdWUgKyBcIlxcblwiO1xuICAgICAgfSwgXCJcIikgOiBTdHJpbmcob3B0cy5ib2R5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICBmb3JtTWV0aG9kLFxuICAgICAgICAgIGZvcm1BY3Rpb24sXG4gICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdHMuZm9ybUVuY1R5cGUsXG4gICAgICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICBqc29uOiB1bmRlZmluZWQsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAob3B0cy5mb3JtRW5jVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIHtcbiAgICAgIC8vIGpzb24gb25seSBzdXBwb3J0cyBQT1NUL1BVVC9QQVRDSC9ERUxFVEUgc3VibWlzc2lvbnNcbiAgICAgIGlmICghaXNNdXRhdGlvbk1ldGhvZChmb3JtTWV0aG9kKSkge1xuICAgICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGpzb24gPSB0eXBlb2Ygb3B0cy5ib2R5ID09PSBcInN0cmluZ1wiID8gSlNPTi5wYXJzZShvcHRzLmJvZHkpIDogb3B0cy5ib2R5O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgc3VibWlzc2lvbjoge1xuICAgICAgICAgICAgZm9ybU1ldGhvZCxcbiAgICAgICAgICAgIGZvcm1BY3Rpb24sXG4gICAgICAgICAgICBmb3JtRW5jVHlwZTogb3B0cy5mb3JtRW5jVHlwZSxcbiAgICAgICAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBqc29uLFxuICAgICAgICAgICAgdGV4dDogdW5kZWZpbmVkXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpbnZhcmlhbnQodHlwZW9mIEZvcm1EYXRhID09PSBcImZ1bmN0aW9uXCIsIFwiRm9ybURhdGEgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50XCIpO1xuICBsZXQgc2VhcmNoUGFyYW1zO1xuICBsZXQgZm9ybURhdGE7XG4gIGlmIChvcHRzLmZvcm1EYXRhKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMob3B0cy5mb3JtRGF0YSk7XG4gICAgZm9ybURhdGEgPSBvcHRzLmZvcm1EYXRhO1xuICB9IGVsc2UgaWYgKG9wdHMuYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMob3B0cy5ib2R5KTtcbiAgICBmb3JtRGF0YSA9IG9wdHMuYm9keTtcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICBzZWFyY2hQYXJhbXMgPSBvcHRzLmJvZHk7XG4gICAgZm9ybURhdGEgPSBjb252ZXJ0U2VhcmNoUGFyYW1zVG9Gb3JtRGF0YShzZWFyY2hQYXJhbXMpO1xuICB9IGVsc2UgaWYgKG9wdHMuYm9keSA9PSBudWxsKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0cy5ib2R5KTtcbiAgICAgIGZvcm1EYXRhID0gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoc2VhcmNoUGFyYW1zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgIH1cbiAgfVxuICBsZXQgc3VibWlzc2lvbiA9IHtcbiAgICBmb3JtTWV0aG9kLFxuICAgIGZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGU6IG9wdHMgJiYgb3B0cy5mb3JtRW5jVHlwZSB8fCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICAgIGZvcm1EYXRhLFxuICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICB0ZXh0OiB1bmRlZmluZWRcbiAgfTtcbiAgaWYgKGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgc3VibWlzc2lvblxuICAgIH07XG4gIH1cbiAgLy8gRmxhdHRlbiBzdWJtaXNzaW9uIG9udG8gVVJMU2VhcmNoUGFyYW1zIGZvciBHRVQgc3VibWlzc2lvbnNcbiAgbGV0IHBhcnNlZFBhdGggPSBwYXJzZVBhdGgocGF0aCk7XG4gIC8vIE9uIEdFVCBuYXZpZ2F0aW9uIHN1Ym1pc3Npb25zIHdlIGNhbiBkcm9wIHRoZSA/aW5kZXggcGFyYW0gZnJvbSB0aGVcbiAgLy8gcmVzdWx0aW5nIGxvY2F0aW9uIHNpbmNlIGFsbCBsb2FkZXJzIHdpbGwgcnVuLiAgQnV0IGZldGNoZXIgR0VUIHN1Ym1pc3Npb25zXG4gIC8vIG9ubHkgcnVuIGEgc2luZ2xlIGxvYWRlciBzbyB3ZSBuZWVkIHRvIHByZXNlcnZlIGFueSBpbmNvbWluZyA/aW5kZXggcGFyYW1zXG4gIGlmIChpc0ZldGNoZXIgJiYgcGFyc2VkUGF0aC5zZWFyY2ggJiYgaGFzTmFrZWRJbmRleFF1ZXJ5KHBhcnNlZFBhdGguc2VhcmNoKSkge1xuICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCBcIlwiKTtcbiAgfVxuICBwYXJzZWRQYXRoLnNlYXJjaCA9IFwiP1wiICsgc2VhcmNoUGFyYW1zO1xuICByZXR1cm4ge1xuICAgIHBhdGg6IGNyZWF0ZVBhdGgocGFyc2VkUGF0aCksXG4gICAgc3VibWlzc2lvblxuICB9O1xufVxuLy8gRmlsdGVyIG91dCBhbGwgcm91dGVzIGJlbG93IGFueSBjYXVnaHQgZXJyb3IgYXMgdGhleSBhcmVuJ3QgZ29pbmcgdG9cbi8vIHJlbmRlciBzbyB3ZSBkb24ndCBuZWVkIHRvIGxvYWQgdGhlbVxuZnVuY3Rpb24gZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkobWF0Y2hlcywgYm91bmRhcnlJZCkge1xuICBsZXQgYm91bmRhcnlNYXRjaGVzID0gbWF0Y2hlcztcbiAgaWYgKGJvdW5kYXJ5SWQpIHtcbiAgICBsZXQgaW5kZXggPSBtYXRjaGVzLmZpbmRJbmRleChtID0+IG0ucm91dGUuaWQgPT09IGJvdW5kYXJ5SWQpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBib3VuZGFyeU1hdGNoZXMgPSBtYXRjaGVzLnNsaWNlKDAsIGluZGV4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kYXJ5TWF0Y2hlcztcbn1cbmZ1bmN0aW9uIGdldE1hdGNoZXNUb0xvYWQoaGlzdG9yeSwgc3RhdGUsIG1hdGNoZXMsIHN1Ym1pc3Npb24sIGxvY2F0aW9uLCBpc0luaXRpYWxMb2FkLCBpc1JldmFsaWRhdGlvblJlcXVpcmVkLCBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcywgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLCBkZWxldGVkRmV0Y2hlcnMsIGZldGNoTG9hZE1hdGNoZXMsIGZldGNoUmVkaXJlY3RJZHMsIHJvdXRlc1RvVXNlLCBiYXNlbmFtZSwgcGVuZGluZ0FjdGlvbkRhdGEsIHBlbmRpbmdFcnJvcikge1xuICBsZXQgYWN0aW9uUmVzdWx0ID0gcGVuZGluZ0Vycm9yID8gT2JqZWN0LnZhbHVlcyhwZW5kaW5nRXJyb3IpWzBdIDogcGVuZGluZ0FjdGlvbkRhdGEgPyBPYmplY3QudmFsdWVzKHBlbmRpbmdBY3Rpb25EYXRhKVswXSA6IHVuZGVmaW5lZDtcbiAgbGV0IGN1cnJlbnRVcmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChzdGF0ZS5sb2NhdGlvbik7XG4gIGxldCBuZXh0VXJsID0gaGlzdG9yeS5jcmVhdGVVUkwobG9jYXRpb24pO1xuICAvLyBQaWNrIG5hdmlnYXRpb24gbWF0Y2hlcyB0aGF0IGFyZSBuZXQtbmV3IG9yIHF1YWxpZnkgZm9yIHJldmFsaWRhdGlvblxuICBsZXQgYm91bmRhcnlJZCA9IHBlbmRpbmdFcnJvciA/IE9iamVjdC5rZXlzKHBlbmRpbmdFcnJvcilbMF0gOiB1bmRlZmluZWQ7XG4gIGxldCBib3VuZGFyeU1hdGNoZXMgPSBnZXRMb2FkZXJNYXRjaGVzVW50aWxCb3VuZGFyeShtYXRjaGVzLCBib3VuZGFyeUlkKTtcbiAgbGV0IG5hdmlnYXRpb25NYXRjaGVzID0gYm91bmRhcnlNYXRjaGVzLmZpbHRlcigobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHJvdXRlXG4gICAgfSA9IG1hdGNoO1xuICAgIGlmIChyb3V0ZS5sYXp5KSB7XG4gICAgICAvLyBXZSBoYXZlbid0IGxvYWRlZCB0aGlzIHJvdXRlIHlldCBzbyB3ZSBkb24ndCBrbm93IGlmIGl0J3MgZ290IGEgbG9hZGVyIVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChyb3V0ZS5sb2FkZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXNJbml0aWFsTG9hZCkge1xuICAgICAgaWYgKHJvdXRlLmxvYWRlci5oeWRyYXRlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXRlLmxvYWRlckRhdGFbcm91dGUuaWRdID09PSB1bmRlZmluZWQgJiYgKFxuICAgICAgLy8gRG9uJ3QgcmUtcnVuIGlmIHRoZSBsb2FkZXIgcmFuIGFuZCB0aHJldyBhbiBlcnJvclxuICAgICAgIXN0YXRlLmVycm9ycyB8fCBzdGF0ZS5lcnJvcnNbcm91dGUuaWRdID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvLyBBbHdheXMgY2FsbCB0aGUgbG9hZGVyIG9uIG5ldyByb3V0ZSBpbnN0YW5jZXMgYW5kIHBlbmRpbmcgZGVmZXIgY2FuY2VsbGF0aW9uc1xuICAgIGlmIChpc05ld0xvYWRlcihzdGF0ZS5sb2FkZXJEYXRhLCBzdGF0ZS5tYXRjaGVzW2luZGV4XSwgbWF0Y2gpIHx8IGNhbmNlbGxlZERlZmVycmVkUm91dGVzLnNvbWUoaWQgPT4gaWQgPT09IG1hdGNoLnJvdXRlLmlkKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIHdoZW4gd2UgcmV2YWxpZGF0ZS4gIElmIHRoZSByb3V0ZVxuICAgIC8vIHByb3ZpZGVzIGl0J3Mgb3duIGltcGxlbWVudGF0aW9uLCB0aGVuIHdlIGdpdmUgdGhlbSBmdWxsIGNvbnRyb2wgYnV0XG4gICAgLy8gcHJvdmlkZSB0aGlzIHZhbHVlIHNvIHRoZXkgY2FuIGxldmVyYWdlIGl0IGlmIG5lZWRlZCBhZnRlciB0aGV5IGNoZWNrXG4gICAgLy8gdGhlaXIgb3duIHNwZWNpZmljIHVzZSBjYXNlc1xuICAgIGxldCBjdXJyZW50Um91dGVNYXRjaCA9IHN0YXRlLm1hdGNoZXNbaW5kZXhdO1xuICAgIGxldCBuZXh0Um91dGVNYXRjaCA9IG1hdGNoO1xuICAgIHJldHVybiBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKG1hdGNoLCBfZXh0ZW5kcyh7XG4gICAgICBjdXJyZW50VXJsLFxuICAgICAgY3VycmVudFBhcmFtczogY3VycmVudFJvdXRlTWF0Y2gucGFyYW1zLFxuICAgICAgbmV4dFVybCxcbiAgICAgIG5leHRQYXJhbXM6IG5leHRSb3V0ZU1hdGNoLnBhcmFtc1xuICAgIH0sIHN1Ym1pc3Npb24sIHtcbiAgICAgIGFjdGlvblJlc3VsdCxcbiAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOlxuICAgICAgLy8gRm9yY2VkIHJldmFsaWRhdGlvbiBkdWUgdG8gc3VibWlzc2lvbiwgdXNlUmV2YWxpZGF0b3IsIG9yIFgtUmVtaXgtUmV2YWxpZGF0ZVxuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCB8fFxuICAgICAgLy8gQ2xpY2tlZCB0aGUgc2FtZSBsaW5rLCByZXN1Ym1pdHRlZCBhIEdFVCBmb3JtXG4gICAgICBjdXJyZW50VXJsLnBhdGhuYW1lICsgY3VycmVudFVybC5zZWFyY2ggPT09IG5leHRVcmwucGF0aG5hbWUgKyBuZXh0VXJsLnNlYXJjaCB8fFxuICAgICAgLy8gU2VhcmNoIHBhcmFtcyBhZmZlY3QgYWxsIGxvYWRlcnNcbiAgICAgIGN1cnJlbnRVcmwuc2VhcmNoICE9PSBuZXh0VXJsLnNlYXJjaCB8fCBpc05ld1JvdXRlSW5zdGFuY2UoY3VycmVudFJvdXRlTWF0Y2gsIG5leHRSb3V0ZU1hdGNoKVxuICAgIH0pKTtcbiAgfSk7XG4gIC8vIFBpY2sgZmV0Y2hlci5sb2FkcyB0aGF0IG5lZWQgdG8gYmUgcmV2YWxpZGF0ZWRcbiAgbGV0IHJldmFsaWRhdGluZ0ZldGNoZXJzID0gW107XG4gIGZldGNoTG9hZE1hdGNoZXMuZm9yRWFjaCgoZiwga2V5KSA9PiB7XG4gICAgLy8gRG9uJ3QgcmV2YWxpZGF0ZTpcbiAgICAvLyAgLSBvbiBpbml0aWFsIGxvYWQgKHNob3VsZG4ndCBiZSBhbnkgZmV0Y2hlcnMgdGhlbiBhbnl3YXkpXG4gICAgLy8gIC0gaWYgZmV0Y2hlciB3b24ndCBiZSBwcmVzZW50IGluIHRoZSBzdWJzZXF1ZW50IHJlbmRlclxuICAgIC8vICAgIC0gbm8gbG9uZ2VyIG1hdGNoZXMgdGhlIFVSTCAodjdfZmV0Y2hlclBlcnNpc3Q9ZmFsc2UpXG4gICAgLy8gICAgLSB3YXMgdW5tb3VudGVkIGJ1dCBwZXJzaXN0ZWQgZHVlIHRvIHY3X2ZldGNoZXJQZXJzaXN0PXRydWVcbiAgICBpZiAoaXNJbml0aWFsTG9hZCB8fCAhbWF0Y2hlcy5zb21lKG0gPT4gbS5yb3V0ZS5pZCA9PT0gZi5yb3V0ZUlkKSB8fCBkZWxldGVkRmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGZldGNoZXJNYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIGYucGF0aCwgYmFzZW5hbWUpO1xuICAgIC8vIElmIHRoZSBmZXRjaGVyIHBhdGggbm8gbG9uZ2VyIG1hdGNoZXMsIHB1c2ggaXQgaW4gd2l0aCBudWxsIG1hdGNoZXMgc29cbiAgICAvLyB3ZSBjYW4gdHJpZ2dlciBhIDQwNCBpbiBjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEuICBOb3RlIHRoaXMgaXNcbiAgICAvLyBjdXJyZW50bHkgb25seSBhIHVzZS1jYXNlIGZvciBSZW1peCBITVIgd2hlcmUgdGhlIHJvdXRlIHRyZWUgY2FuIGNoYW5nZVxuICAgIC8vIGF0IHJ1bnRpbWUgYW5kIHJlbW92ZSBhIHJvdXRlIHByZXZpb3VzbHkgbG9hZGVkIHZpYSBhIGZldGNoZXJcbiAgICBpZiAoIWZldGNoZXJNYXRjaGVzKSB7XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICByb3V0ZUlkOiBmLnJvdXRlSWQsXG4gICAgICAgIHBhdGg6IGYucGF0aCxcbiAgICAgICAgbWF0Y2hlczogbnVsbCxcbiAgICAgICAgbWF0Y2g6IG51bGwsXG4gICAgICAgIGNvbnRyb2xsZXI6IG51bGxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZXZhbGlkYXRpbmcgZmV0Y2hlcnMgYXJlIGRlY291cGxlZCBmcm9tIHRoZSByb3V0ZSBtYXRjaGVzIHNpbmNlIHRoZXlcbiAgICAvLyBsb2FkIGZyb20gYSBzdGF0aWMgaHJlZi4gIFRoZXkgcmV2YWxpZGF0ZSBiYXNlZCBvbiBleHBsaWNpdCByZXZhbGlkYXRpb25cbiAgICAvLyAoc3VibWlzc2lvbiwgdXNlUmV2YWxpZGF0b3IsIG9yIFgtUmVtaXgtUmV2YWxpZGF0ZSlcbiAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGxldCBmZXRjaGVyTWF0Y2ggPSBnZXRUYXJnZXRNYXRjaChmZXRjaGVyTWF0Y2hlcywgZi5wYXRoKTtcbiAgICBsZXQgc2hvdWxkUmV2YWxpZGF0ZSA9IGZhbHNlO1xuICAgIGlmIChmZXRjaFJlZGlyZWN0SWRzLmhhcyhrZXkpKSB7XG4gICAgICAvLyBOZXZlciB0cmlnZ2VyIGEgcmV2YWxpZGF0aW9uIG9mIGFuIGFjdGl2ZWx5IHJlZGlyZWN0aW5nIGZldGNoZXJcbiAgICAgIHNob3VsZFJldmFsaWRhdGUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAvLyBBbHdheXMgcmV2YWxpZGF0ZSBpZiB0aGUgZmV0Y2hlciB3YXMgY2FuY2VsbGVkXG4gICAgICBzaG91bGRSZXZhbGlkYXRlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGZldGNoZXIgJiYgZmV0Y2hlci5zdGF0ZSAhPT0gXCJpZGxlXCIgJiYgZmV0Y2hlci5kYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIElmIHRoZSBmZXRjaGVyIGhhc24ndCBldmVyIGNvbXBsZXRlZCBsb2FkaW5nIHlldCwgdGhlbiB0aGlzIGlzbid0IGFcbiAgICAgIC8vIHJldmFsaWRhdGlvbiwgaXQgd291bGQganVzdCBiZSBhIGJyYW5kIG5ldyBsb2FkIGlmIGFuIGV4cGxpY2l0XG4gICAgICAvLyByZXZhbGlkYXRpb24gaXMgcmVxdWlyZWRcbiAgICAgIHNob3VsZFJldmFsaWRhdGUgPSBpc1JldmFsaWRhdGlvblJlcXVpcmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UgZmFsbCBiYWNrIG9uIGFueSB1c2VyLWRlZmluZWQgc2hvdWxkUmV2YWxpZGF0ZSwgZGVmYXVsdGluZ1xuICAgICAgLy8gdG8gZXhwbGljaXQgcmV2YWxpZGF0aW9ucyBvbmx5XG4gICAgICBzaG91bGRSZXZhbGlkYXRlID0gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihmZXRjaGVyTWF0Y2gsIF9leHRlbmRzKHtcbiAgICAgICAgY3VycmVudFVybCxcbiAgICAgICAgY3VycmVudFBhcmFtczogc3RhdGUubWF0Y2hlc1tzdGF0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdLnBhcmFtcyxcbiAgICAgICAgbmV4dFVybCxcbiAgICAgICAgbmV4dFBhcmFtczogbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnBhcmFtc1xuICAgICAgfSwgc3VibWlzc2lvbiwge1xuICAgICAgICBhY3Rpb25SZXN1bHQsXG4gICAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOiBpc1JldmFsaWRhdGlvblJlcXVpcmVkXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChzaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICByb3V0ZUlkOiBmLnJvdXRlSWQsXG4gICAgICAgIHBhdGg6IGYucGF0aCxcbiAgICAgICAgbWF0Y2hlczogZmV0Y2hlck1hdGNoZXMsXG4gICAgICAgIG1hdGNoOiBmZXRjaGVyTWF0Y2gsXG4gICAgICAgIGNvbnRyb2xsZXI6IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFtuYXZpZ2F0aW9uTWF0Y2hlcywgcmV2YWxpZGF0aW5nRmV0Y2hlcnNdO1xufVxuZnVuY3Rpb24gaXNOZXdMb2FkZXIoY3VycmVudExvYWRlckRhdGEsIGN1cnJlbnRNYXRjaCwgbWF0Y2gpIHtcbiAgbGV0IGlzTmV3ID1cbiAgLy8gW2FdIC0+IFthLCBiXVxuICAhY3VycmVudE1hdGNoIHx8XG4gIC8vIFthLCBiXSAtPiBbYSwgY11cbiAgbWF0Y2gucm91dGUuaWQgIT09IGN1cnJlbnRNYXRjaC5yb3V0ZS5pZDtcbiAgLy8gSGFuZGxlIHRoZSBjYXNlIHRoYXQgd2UgZG9uJ3QgaGF2ZSBkYXRhIGZvciBhIHJlLXVzZWQgcm91dGUsIHBvdGVudGlhbGx5XG4gIC8vIGZyb20gYSBwcmlvciBlcnJvciBvciBmcm9tIGEgY2FuY2VsbGVkIHBlbmRpbmcgZGVmZXJyZWRcbiAgbGV0IGlzTWlzc2luZ0RhdGEgPSBjdXJyZW50TG9hZGVyRGF0YVttYXRjaC5yb3V0ZS5pZF0gPT09IHVuZGVmaW5lZDtcbiAgLy8gQWx3YXlzIGxvYWQgaWYgdGhpcyBpcyBhIG5ldC1uZXcgcm91dGUgb3Igd2UgZG9uJ3QgeWV0IGhhdmUgZGF0YVxuICByZXR1cm4gaXNOZXcgfHwgaXNNaXNzaW5nRGF0YTtcbn1cbmZ1bmN0aW9uIGlzTmV3Um91dGVJbnN0YW5jZShjdXJyZW50TWF0Y2gsIG1hdGNoKSB7XG4gIGxldCBjdXJyZW50UGF0aCA9IGN1cnJlbnRNYXRjaC5yb3V0ZS5wYXRoO1xuICByZXR1cm4gKFxuICAgIC8vIHBhcmFtIGNoYW5nZSBmb3IgdGhpcyBtYXRjaCwgL3VzZXJzLzEyMyAtPiAvdXNlcnMvNDU2XG4gICAgY3VycmVudE1hdGNoLnBhdGhuYW1lICE9PSBtYXRjaC5wYXRobmFtZSB8fFxuICAgIC8vIHNwbGF0IHBhcmFtIGNoYW5nZWQsIHdoaWNoIGlzIG5vdCBwcmVzZW50IGluIG1hdGNoLnBhdGhcbiAgICAvLyBlLmcuIC9maWxlcy9pbWFnZXMvYXZhdGFyLmpwZyAtPiBmaWxlcy9maW5hbmNlcy54bHNcbiAgICBjdXJyZW50UGF0aCAhPSBudWxsICYmIGN1cnJlbnRQYXRoLmVuZHNXaXRoKFwiKlwiKSAmJiBjdXJyZW50TWF0Y2gucGFyYW1zW1wiKlwiXSAhPT0gbWF0Y2gucGFyYW1zW1wiKlwiXVxuICApO1xufVxuZnVuY3Rpb24gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihsb2FkZXJNYXRjaCwgYXJnKSB7XG4gIGlmIChsb2FkZXJNYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgbGV0IHJvdXRlQ2hvaWNlID0gbG9hZGVyTWF0Y2gucm91dGUuc2hvdWxkUmV2YWxpZGF0ZShhcmcpO1xuICAgIGlmICh0eXBlb2Ygcm91dGVDaG9pY2UgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gcm91dGVDaG9pY2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcmcuZGVmYXVsdFNob3VsZFJldmFsaWRhdGU7XG59XG4vKipcbiAqIEV4ZWN1dGUgcm91dGUubGF6eSgpIG1ldGhvZHMgdG8gbGF6aWx5IGxvYWQgcm91dGUgbW9kdWxlcyAobG9hZGVyLCBhY3Rpb24sXG4gKiBzaG91bGRSZXZhbGlkYXRlKSBhbmQgdXBkYXRlIHRoZSByb3V0ZU1hbmlmZXN0IGluIHBsYWNlIHdoaWNoIHNoYXJlcyBvYmplY3RzXG4gKiB3aXRoIGRhdGFSb3V0ZXMgc28gdGhvc2UgZ2V0IHVwZGF0ZWQgYXMgd2VsbC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZExhenlSb3V0ZU1vZHVsZShyb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzLCBtYW5pZmVzdCkge1xuICBpZiAoIXJvdXRlLmxhenkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGxhenlSb3V0ZSA9IGF3YWl0IHJvdXRlLmxhenkoKTtcbiAgLy8gSWYgdGhlIGxhenkgcm91dGUgZnVuY3Rpb24gd2FzIGV4ZWN1dGVkIGFuZCByZW1vdmVkIGJ5IGFub3RoZXIgcGFyYWxsZWxcbiAgLy8gY2FsbCB0aGVuIHdlIGNhbiByZXR1cm4gLSBmaXJzdCBsYXp5KCkgdG8gZmluaXNoIHdpbnMgYmVjYXVzZSB0aGUgcmV0dXJuXG4gIC8vIHZhbHVlIG9mIGxhenkgaXMgZXhwZWN0ZWQgdG8gYmUgc3RhdGljXG4gIGlmICghcm91dGUubGF6eSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgcm91dGVUb1VwZGF0ZSA9IG1hbmlmZXN0W3JvdXRlLmlkXTtcbiAgaW52YXJpYW50KHJvdXRlVG9VcGRhdGUsIFwiTm8gcm91dGUgZm91bmQgaW4gbWFuaWZlc3RcIik7XG4gIC8vIFVwZGF0ZSB0aGUgcm91dGUgaW4gcGxhY2UuICBUaGlzIHNob3VsZCBiZSBzYWZlIGJlY2F1c2UgdGhlcmUncyBubyB3YXlcbiAgLy8gd2UgY291bGQgeWV0IGJlIHNpdHRpbmcgb24gdGhpcyByb3V0ZSBhcyB3ZSBjYW4ndCBnZXQgdGhlcmUgd2l0aG91dFxuICAvLyByZXNvbHZpbmcgbGF6eSgpIGZpcnN0LlxuICAvL1xuICAvLyBUaGlzIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBITVIgXCJ1cGRhdGVcIiB1c2UtY2FzZSB3aGVyZSB3ZSBtYXkgYWN0aXZlbHkgYmVcbiAgLy8gb24gdGhlIHJvdXRlIGJlaW5nIHVwZGF0ZWQuICBUaGUgbWFpbiBjb25jZXJuIGJvaWxzIGRvd24gdG8gXCJkb2VzIHRoaXNcbiAgLy8gbXV0YXRpb24gYWZmZWN0IGFueSBvbmdvaW5nIG5hdmlnYXRpb25zIG9yIGFueSBjdXJyZW50IHN0YXRlLm1hdGNoZXNcbiAgLy8gdmFsdWVzP1wiLiAgSWYgbm90LCBpdCBzaG91bGQgYmUgc2FmZSB0byB1cGRhdGUgaW4gcGxhY2UuXG4gIGxldCByb3V0ZVVwZGF0ZXMgPSB7fTtcbiAgZm9yIChsZXQgbGF6eVJvdXRlUHJvcGVydHkgaW4gbGF6eVJvdXRlKSB7XG4gICAgbGV0IHN0YXRpY1JvdXRlVmFsdWUgPSByb3V0ZVRvVXBkYXRlW2xhenlSb3V0ZVByb3BlcnR5XTtcbiAgICBsZXQgaXNQcm9wZXJ0eVN0YXRpY2FsbHlEZWZpbmVkID0gc3RhdGljUm91dGVWYWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgLy8gVGhpcyBwcm9wZXJ0eSBpc24ndCBzdGF0aWMgc2luY2UgaXQgc2hvdWxkIGFsd2F5cyBiZSB1cGRhdGVkIGJhc2VkXG4gICAgLy8gb24gdGhlIHJvdXRlIHVwZGF0ZXNcbiAgICBsYXp5Um91dGVQcm9wZXJ0eSAhPT0gXCJoYXNFcnJvckJvdW5kYXJ5XCI7XG4gICAgd2FybmluZyghaXNQcm9wZXJ0eVN0YXRpY2FsbHlEZWZpbmVkLCBcIlJvdXRlIFxcXCJcIiArIHJvdXRlVG9VcGRhdGUuaWQgKyBcIlxcXCIgaGFzIGEgc3RhdGljIHByb3BlcnR5IFxcXCJcIiArIGxhenlSb3V0ZVByb3BlcnR5ICsgXCJcXFwiIFwiICsgXCJkZWZpbmVkIGJ1dCBpdHMgbGF6eSBmdW5jdGlvbiBpcyBhbHNvIHJldHVybmluZyBhIHZhbHVlIGZvciB0aGlzIHByb3BlcnR5LiBcIiArIChcIlRoZSBsYXp5IHJvdXRlIHByb3BlcnR5IFxcXCJcIiArIGxhenlSb3V0ZVByb3BlcnR5ICsgXCJcXFwiIHdpbGwgYmUgaWdub3JlZC5cIikpO1xuICAgIGlmICghaXNQcm9wZXJ0eVN0YXRpY2FsbHlEZWZpbmVkICYmICFpbW11dGFibGVSb3V0ZUtleXMuaGFzKGxhenlSb3V0ZVByb3BlcnR5KSkge1xuICAgICAgcm91dGVVcGRhdGVzW2xhenlSb3V0ZVByb3BlcnR5XSA9IGxhenlSb3V0ZVtsYXp5Um91dGVQcm9wZXJ0eV07XG4gICAgfVxuICB9XG4gIC8vIE11dGF0ZSB0aGUgcm91dGUgd2l0aCB0aGUgcHJvdmlkZWQgdXBkYXRlcy4gIERvIHRoaXMgZmlyc3Qgc28gd2UgcGFzc1xuICAvLyB0aGUgdXBkYXRlZCB2ZXJzaW9uIHRvIG1hcFJvdXRlUHJvcGVydGllc1xuICBPYmplY3QuYXNzaWduKHJvdXRlVG9VcGRhdGUsIHJvdXRlVXBkYXRlcyk7XG4gIC8vIE11dGF0ZSB0aGUgYGhhc0Vycm9yQm91bmRhcnlgIHByb3BlcnR5IG9uIHRoZSByb3V0ZSBiYXNlZCBvbiB0aGUgcm91dGVcbiAgLy8gdXBkYXRlcyBhbmQgcmVtb3ZlIHRoZSBgbGF6eWAgZnVuY3Rpb24gc28gd2UgZG9uJ3QgcmVzb2x2ZSB0aGUgbGF6eVxuICAvLyByb3V0ZSBhZ2Fpbi5cbiAgT2JqZWN0LmFzc2lnbihyb3V0ZVRvVXBkYXRlLCBfZXh0ZW5kcyh7fSwgbWFwUm91dGVQcm9wZXJ0aWVzKHJvdXRlVG9VcGRhdGUpLCB7XG4gICAgbGF6eTogdW5kZWZpbmVkXG4gIH0pKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJPckFjdGlvbih0eXBlLCByZXF1ZXN0LCBtYXRjaCwgbWF0Y2hlcywgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllcywgYmFzZW5hbWUsIHY3X3JlbGF0aXZlU3BsYXRQYXRoLCBvcHRzKSB7XG4gIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICBvcHRzID0ge307XG4gIH1cbiAgbGV0IHJlc3VsdFR5cGU7XG4gIGxldCByZXN1bHQ7XG4gIGxldCBvblJlamVjdDtcbiAgbGV0IHJ1bkhhbmRsZXIgPSBoYW5kbGVyID0+IHtcbiAgICAvLyBTZXR1cCBhIHByb21pc2Ugd2UgY2FuIHJhY2UgYWdhaW5zdCBzbyB0aGF0IGFib3J0IHNpZ25hbHMgc2hvcnQgY2lyY3VpdFxuICAgIGxldCByZWplY3Q7XG4gICAgbGV0IGFib3J0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByKSA9PiByZWplY3QgPSByKTtcbiAgICBvblJlamVjdCA9ICgpID0+IHJlamVjdCgpO1xuICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvblJlamVjdCk7XG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbaGFuZGxlcih7XG4gICAgICByZXF1ZXN0LFxuICAgICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgICBjb250ZXh0OiBvcHRzLnJlcXVlc3RDb250ZXh0XG4gICAgfSksIGFib3J0UHJvbWlzZV0pO1xuICB9O1xuICB0cnkge1xuICAgIGxldCBoYW5kbGVyID0gbWF0Y2gucm91dGVbdHlwZV07XG4gICAgaWYgKG1hdGNoLnJvdXRlLmxhenkpIHtcbiAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIC8vIFJ1biBzdGF0aWNhbGx5IGRlZmluZWQgaGFuZGxlciBpbiBwYXJhbGxlbCB3aXRoIGxhenkoKVxuICAgICAgICBsZXQgaGFuZGxlckVycm9yO1xuICAgICAgICBsZXQgdmFsdWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAvLyBJZiB0aGUgaGFuZGxlciB0aHJvd3MsIGRvbid0IGxldCBpdCBpbW1lZGlhdGVseSBidWJibGUgb3V0LFxuICAgICAgICAvLyBzaW5jZSB3ZSBuZWVkIHRvIGxldCB0aGUgbGF6eSgpIGV4ZWN1dGlvbiBmaW5pc2ggc28gd2Uga25vdyBpZiB0aGlzXG4gICAgICAgIC8vIHJvdXRlIGhhcyBhIGJvdW5kYXJ5IHRoYXQgY2FuIGhhbmRsZSB0aGUgZXJyb3JcbiAgICAgICAgcnVuSGFuZGxlcihoYW5kbGVyKS5jYXRjaChlID0+IHtcbiAgICAgICAgICBoYW5kbGVyRXJyb3IgPSBlO1xuICAgICAgICB9KSwgbG9hZExhenlSb3V0ZU1vZHVsZShtYXRjaC5yb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzLCBtYW5pZmVzdCldKTtcbiAgICAgICAgaWYgKGhhbmRsZXJFcnJvcikge1xuICAgICAgICAgIHRocm93IGhhbmRsZXJFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB2YWx1ZXNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBMb2FkIGxhenkgcm91dGUgbW9kdWxlLCB0aGVuIHJ1biBhbnkgcmV0dXJuZWQgaGFuZGxlclxuICAgICAgICBhd2FpdCBsb2FkTGF6eVJvdXRlTW9kdWxlKG1hdGNoLnJvdXRlLCBtYXBSb3V0ZVByb3BlcnRpZXMsIG1hbmlmZXN0KTtcbiAgICAgICAgaGFuZGxlciA9IG1hdGNoLnJvdXRlW3R5cGVdO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIC8vIEhhbmRsZXIgc3RpbGwgcnVuIGV2ZW4gaWYgd2UgZ290IGludGVycnVwdGVkIHRvIG1haW50YWluIGNvbnNpc3RlbmN5XG4gICAgICAgICAgLy8gd2l0aCB1bi1hYm9ydGFibGUgYmVoYXZpb3Igb2YgaGFuZGxlciBleGVjdXRpb24gb24gbm9uLWxhenkgb3JcbiAgICAgICAgICAvLyBwcmV2aW91c2x5LWxhenktbG9hZGVkIHJvdXRlc1xuICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHJ1bkhhbmRsZXIoaGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJhY3Rpb25cIikge1xuICAgICAgICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICAgICAgICBsZXQgcGF0aG5hbWUgPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoO1xuICAgICAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICByb3V0ZUlkOiBtYXRjaC5yb3V0ZS5pZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxhenkoKSByb3V0ZSBoYXMgbm8gbG9hZGVyIHRvIHJ1bi4gIFNob3J0IGNpcmN1aXQgaGVyZSBzbyB3ZSBkb24ndFxuICAgICAgICAgIC8vIGhpdCB0aGUgaW52YXJpYW50IGJlbG93IHRoYXQgZXJyb3JzIG9uIHJldHVybmluZyB1bmRlZmluZWQuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFoYW5kbGVyKSB7XG4gICAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICBsZXQgcGF0aG5hbWUgPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoO1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgcGF0aG5hbWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBydW5IYW5kbGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgICBpbnZhcmlhbnQocmVzdWx0ICE9PSB1bmRlZmluZWQsIFwiWW91IGRlZmluZWQgXCIgKyAodHlwZSA9PT0gXCJhY3Rpb25cIiA/IFwiYW4gYWN0aW9uXCIgOiBcImEgbG9hZGVyXCIpICsgXCIgZm9yIHJvdXRlIFwiICsgKFwiXFxcIlwiICsgbWF0Y2gucm91dGUuaWQgKyBcIlxcXCIgYnV0IGRpZG4ndCByZXR1cm4gYW55dGhpbmcgZnJvbSB5b3VyIGBcIiArIHR5cGUgKyBcImAgXCIpICsgXCJmdW5jdGlvbi4gUGxlYXNlIHJldHVybiBhIHZhbHVlIG9yIGBudWxsYC5cIik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXN1bHRUeXBlID0gUmVzdWx0VHlwZS5lcnJvcjtcbiAgICByZXN1bHQgPSBlO1xuICB9IGZpbmFsbHkge1xuICAgIGlmIChvblJlamVjdCkge1xuICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uUmVqZWN0KTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgIGxldCBzdGF0dXMgPSByZXN1bHQuc3RhdHVzO1xuICAgIC8vIFByb2Nlc3MgcmVkaXJlY3RzXG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzQ29kZXMuaGFzKHN0YXR1cykpIHtcbiAgICAgIGxldCBsb2NhdGlvbiA9IHJlc3VsdC5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpO1xuICAgICAgaW52YXJpYW50KGxvY2F0aW9uLCBcIlJlZGlyZWN0cyByZXR1cm5lZC90aHJvd24gZnJvbSBsb2FkZXJzL2FjdGlvbnMgbXVzdCBoYXZlIGEgTG9jYXRpb24gaGVhZGVyXCIpO1xuICAgICAgLy8gU3VwcG9ydCByZWxhdGl2ZSByb3V0aW5nIGluIGludGVybmFsIHJlZGlyZWN0c1xuICAgICAgaWYgKCFBQlNPTFVURV9VUkxfUkVHRVgudGVzdChsb2NhdGlvbikpIHtcbiAgICAgICAgbG9jYXRpb24gPSBub3JtYWxpemVUbyhuZXcgVVJMKHJlcXVlc3QudXJsKSwgbWF0Y2hlcy5zbGljZSgwLCBtYXRjaGVzLmluZGV4T2YobWF0Y2gpICsgMSksIGJhc2VuYW1lLCB0cnVlLCBsb2NhdGlvbiwgdjdfcmVsYXRpdmVTcGxhdFBhdGgpO1xuICAgICAgfSBlbHNlIGlmICghb3B0cy5pc1N0YXRpY1JlcXVlc3QpIHtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIHRoZSBwcm90b2NvbCtvcmlnaW4gZm9yIHNhbWUtb3JpZ2luICsgc2FtZS1iYXNlbmFtZSBhYnNvbHV0ZVxuICAgICAgICAvLyByZWRpcmVjdHMuIElmIHRoaXMgaXMgYSBzdGF0aWMgcmVxdWVzdCwgd2UgY2FuIGxldCBpdCBnbyBiYWNrIHRvIHRoZVxuICAgICAgICAvLyBicm93c2VyIGFzLWlzXG4gICAgICAgIGxldCBjdXJyZW50VXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgIGxldCB1cmwgPSBsb2NhdGlvbi5zdGFydHNXaXRoKFwiLy9cIikgPyBuZXcgVVJMKGN1cnJlbnRVcmwucHJvdG9jb2wgKyBsb2NhdGlvbikgOiBuZXcgVVJMKGxvY2F0aW9uKTtcbiAgICAgICAgbGV0IGlzU2FtZUJhc2VuYW1lID0gc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGJhc2VuYW1lKSAhPSBudWxsO1xuICAgICAgICBpZiAodXJsLm9yaWdpbiA9PT0gY3VycmVudFVybC5vcmlnaW4gJiYgaXNTYW1lQmFzZW5hbWUpIHtcbiAgICAgICAgICBsb2NhdGlvbiA9IHVybC5wYXRobmFtZSArIHVybC5zZWFyY2ggKyB1cmwuaGFzaDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgcHJvY2VzcyByZWRpcmVjdHMgaW4gdGhlIHJvdXRlciBkdXJpbmcgc3RhdGljIHJlcXVlc3RzIHJlcXVlc3RzLlxuICAgICAgLy8gSW5zdGVhZCwgdGhyb3cgdGhlIFJlc3BvbnNlIGFuZCBsZXQgdGhlIHNlcnZlciBoYW5kbGUgaXQgd2l0aCBhbiBIVFRQXG4gICAgICAvLyByZWRpcmVjdC4gIFdlIGFsc28gdXBkYXRlIHRoZSBMb2NhdGlvbiBoZWFkZXIgaW4gcGxhY2UgaW4gdGhpcyBmbG93IHNvXG4gICAgICAvLyBiYXNlbmFtZSBhbmQgcmVsYXRpdmUgcm91dGluZyBpcyB0YWtlbiBpbnRvIGFjY291bnRcbiAgICAgIGlmIChvcHRzLmlzU3RhdGljUmVxdWVzdCkge1xuICAgICAgICByZXN1bHQuaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCBsb2NhdGlvbik7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUucmVkaXJlY3QsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIHJldmFsaWRhdGU6IHJlc3VsdC5oZWFkZXJzLmdldChcIlgtUmVtaXgtUmV2YWxpZGF0ZVwiKSAhPT0gbnVsbCxcbiAgICAgICAgcmVsb2FkRG9jdW1lbnQ6IHJlc3VsdC5oZWFkZXJzLmdldChcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCIpICE9PSBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBGb3IgU1NSIHNpbmdsZS1yb3V0ZSByZXF1ZXN0cywgd2Ugd2FudCB0byBoYW5kIFJlc3BvbnNlcyBiYWNrIGRpcmVjdGx5XG4gICAgLy8gd2l0aG91dCB1bndyYXBwaW5nLiAgV2UgZG8gdGhpcyB3aXRoIHRoZSBRdWVyeVJvdXRlUmVzcG9uc2Ugd3JhcHBlclxuICAgIC8vIGludGVyZmFjZSBzbyB3ZSBjYW4ga25vdyB3aGV0aGVyIGl0IHdhcyByZXR1cm5lZCBvciB0aHJvd25cbiAgICBpZiAob3B0cy5pc1JvdXRlUmVxdWVzdCkge1xuICAgICAgbGV0IHF1ZXJ5Um91dGVSZXNwb25zZSA9IHtcbiAgICAgICAgdHlwZTogcmVzdWx0VHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvciA/IFJlc3VsdFR5cGUuZXJyb3IgOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgICAgIHJlc3BvbnNlOiByZXN1bHRcbiAgICAgIH07XG4gICAgICB0aHJvdyBxdWVyeVJvdXRlUmVzcG9uc2U7XG4gICAgfVxuICAgIGxldCBkYXRhO1xuICAgIHRyeSB7XG4gICAgICBsZXQgY29udGVudFR5cGUgPSByZXN1bHQuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gICAgICAvLyBDaGVjayBiZXR3ZWVuIHdvcmQgYm91bmRhcmllcyBpbnN0ZWFkIG9mIHN0YXJ0c1dpdGgoKSBkdWUgdG8gdGhlIGxhc3RcbiAgICAgIC8vIHBhcmFncmFwaCBvZiBodHRwczovL2h0dHB3Zy5vcmcvc3BlY3MvcmZjOTExMC5odG1sI2ZpZWxkLmNvbnRlbnQtdHlwZVxuICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIC9cXGJhcHBsaWNhdGlvblxcL2pzb25cXGIvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICAgIGlmIChyZXN1bHQuYm9keSA9PSBudWxsKSB7XG4gICAgICAgICAgZGF0YSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YSA9IGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBhd2FpdCByZXN1bHQudGV4dCgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yOiBlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAocmVzdWx0VHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogcmVzdWx0VHlwZSxcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvclJlc3BvbnNlSW1wbChzdGF0dXMsIHJlc3VsdC5zdGF0dXNUZXh0LCBkYXRhKSxcbiAgICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgICBkYXRhLFxuICAgICAgc3RhdHVzQ29kZTogcmVzdWx0LnN0YXR1cyxcbiAgICAgIGhlYWRlcnM6IHJlc3VsdC5oZWFkZXJzXG4gICAgfTtcbiAgfVxuICBpZiAocmVzdWx0VHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiByZXN1bHRUeXBlLFxuICAgICAgZXJyb3I6IHJlc3VsdFxuICAgIH07XG4gIH1cbiAgaWYgKGlzRGVmZXJyZWREYXRhKHJlc3VsdCkpIHtcbiAgICB2YXIgX3Jlc3VsdCRpbml0LCBfcmVzdWx0JGluaXQyO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBSZXN1bHRUeXBlLmRlZmVycmVkLFxuICAgICAgZGVmZXJyZWREYXRhOiByZXN1bHQsXG4gICAgICBzdGF0dXNDb2RlOiAoX3Jlc3VsdCRpbml0ID0gcmVzdWx0LmluaXQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVzdWx0JGluaXQuc3RhdHVzLFxuICAgICAgaGVhZGVyczogKChfcmVzdWx0JGluaXQyID0gcmVzdWx0LmluaXQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVzdWx0JGluaXQyLmhlYWRlcnMpICYmIG5ldyBIZWFkZXJzKHJlc3VsdC5pbml0LmhlYWRlcnMpXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICBkYXRhOiByZXN1bHRcbiAgfTtcbn1cbi8vIFV0aWxpdHkgbWV0aG9kIGZvciBjcmVhdGluZyB0aGUgUmVxdWVzdCBpbnN0YW5jZXMgZm9yIGxvYWRlcnMvYWN0aW9ucyBkdXJpbmdcbi8vIGNsaWVudC1zaWRlIG5hdmlnYXRpb25zIGFuZCBmZXRjaGVzLiAgRHVyaW5nIFNTUiB3ZSB3aWxsIGFsd2F5cyBoYXZlIGFcbi8vIFJlcXVlc3QgaW5zdGFuY2UgZnJvbSB0aGUgc3RhdGljIGhhbmRsZXIgKHF1ZXJ5L3F1ZXJ5Um91dGUpXG5mdW5jdGlvbiBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChoaXN0b3J5LCBsb2NhdGlvbiwgc2lnbmFsLCBzdWJtaXNzaW9uKSB7XG4gIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChzdHJpcEhhc2hGcm9tUGF0aChsb2NhdGlvbikpLnRvU3RyaW5nKCk7XG4gIGxldCBpbml0ID0ge1xuICAgIHNpZ25hbFxuICB9O1xuICBpZiAoc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICBsZXQge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1FbmNUeXBlXG4gICAgfSA9IHN1Ym1pc3Npb247XG4gICAgLy8gRGlkbid0IHRoaW5rIHdlIG5lZWRlZCB0aGlzIGJ1dCBpdCB0dXJucyBvdXQgdW5saWtlIG90aGVyIG1ldGhvZHMsIHBhdGNoXG4gICAgLy8gd29uJ3QgYmUgcHJvcGVybHkgbm9ybWFsaXplZCB0byB1cHBlcmNhc2UgYW5kIHJlc3VsdHMgaW4gYSA0MDUgZXJyb3IuXG4gICAgLy8gU2VlOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1tZXRob2RcbiAgICBpbml0Lm1ldGhvZCA9IGZvcm1NZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24vanNvblwiKSB7XG4gICAgICBpbml0LmhlYWRlcnMgPSBuZXcgSGVhZGVycyh7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IGZvcm1FbmNUeXBlXG4gICAgICB9KTtcbiAgICAgIGluaXQuYm9keSA9IEpTT04uc3RyaW5naWZ5KHN1Ym1pc3Npb24uanNvbik7XG4gICAgfSBlbHNlIGlmIChmb3JtRW5jVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcbiAgICAgIC8vIENvbnRlbnQtVHlwZSBpcyBpbmZlcnJlZCAoaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0KVxuICAgICAgaW5pdC5ib2R5ID0gc3VibWlzc2lvbi50ZXh0O1xuICAgIH0gZWxzZSBpZiAoZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgJiYgc3VibWlzc2lvbi5mb3JtRGF0YSkge1xuICAgICAgLy8gQ29udGVudC1UeXBlIGlzIGluZmVycmVkIChodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlcXVlc3QpXG4gICAgICBpbml0LmJvZHkgPSBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhzdWJtaXNzaW9uLmZvcm1EYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGVudC1UeXBlIGlzIGluZmVycmVkIChodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlcXVlc3QpXG4gICAgICBpbml0LmJvZHkgPSBzdWJtaXNzaW9uLmZvcm1EYXRhO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFJlcXVlc3QodXJsLCBpbml0KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKGZvcm1EYXRhKSB7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBmb3JtRGF0YS5lbnRyaWVzKCkpIHtcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3JtLWNvbnRyb2wtaW5mcmFzdHJ1Y3R1cmUuaHRtbCNjb252ZXJ0aW5nLWFuLWVudHJ5LWxpc3QtdG8tYS1saXN0LW9mLW5hbWUtdmFsdWUtcGFpcnNcbiAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUgOiB2YWx1ZS5uYW1lKTtcbiAgfVxuICByZXR1cm4gc2VhcmNoUGFyYW1zO1xufVxuZnVuY3Rpb24gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoc2VhcmNoUGFyYW1zKSB7XG4gIGxldCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2Ygc2VhcmNoUGFyYW1zLmVudHJpZXMoKSkge1xuICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZm9ybURhdGE7XG59XG5mdW5jdGlvbiBwcm9jZXNzUm91dGVMb2FkZXJEYXRhKG1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIHJlc3VsdHMsIHBlbmRpbmdFcnJvciwgYWN0aXZlRGVmZXJyZWRzKSB7XG4gIC8vIEZpbGwgaW4gbG9hZGVyRGF0YS9lcnJvcnMgZnJvbSBvdXIgbG9hZGVyc1xuICBsZXQgbG9hZGVyRGF0YSA9IHt9O1xuICBsZXQgZXJyb3JzID0gbnVsbDtcbiAgbGV0IHN0YXR1c0NvZGU7XG4gIGxldCBmb3VuZEVycm9yID0gZmFsc2U7XG4gIGxldCBsb2FkZXJIZWFkZXJzID0ge307XG4gIC8vIFByb2Nlc3MgbG9hZGVyIHJlc3VsdHMgaW50byBzdGF0ZS5sb2FkZXJEYXRhL3N0YXRlLmVycm9yc1xuICByZXN1bHRzLmZvckVhY2goKHJlc3VsdCwgaW5kZXgpID0+IHtcbiAgICBsZXQgaWQgPSBtYXRjaGVzVG9Mb2FkW2luZGV4XS5yb3V0ZS5pZDtcbiAgICBpbnZhcmlhbnQoIWlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSwgXCJDYW5ub3QgaGFuZGxlIHJlZGlyZWN0IHJlc3VsdHMgaW4gcHJvY2Vzc0xvYWRlckRhdGFcIik7XG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgLy8gTG9vayB1cHdhcmRzIGZyb20gdGhlIG1hdGNoZWQgcm91dGUgZm9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yXG4gICAgICAvLyBlcnJvciBib3VuZGFyeSwgZGVmYXVsdGluZyB0byB0aGUgcm9vdCBtYXRjaFxuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGlkKTtcbiAgICAgIGxldCBlcnJvciA9IHJlc3VsdC5lcnJvcjtcbiAgICAgIC8vIElmIHdlIGhhdmUgYSBwZW5kaW5nIGFjdGlvbiBlcnJvciwgd2UgcmVwb3J0IGl0IGF0IHRoZSBoaWdoZXN0LXJvdXRlXG4gICAgICAvLyB0aGF0IHRocm93cyBhIGxvYWRlciBlcnJvciwgYW5kIHRoZW4gY2xlYXIgaXQgb3V0IHRvIGluZGljYXRlIHRoYXRcbiAgICAgIC8vIGl0IHdhcyBjb25zdW1lZFxuICAgICAgaWYgKHBlbmRpbmdFcnJvcikge1xuICAgICAgICBlcnJvciA9IE9iamVjdC52YWx1ZXMocGVuZGluZ0Vycm9yKVswXTtcbiAgICAgICAgcGVuZGluZ0Vycm9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IHt9O1xuICAgICAgLy8gUHJlZmVyIGhpZ2hlciBlcnJvciB2YWx1ZXMgaWYgbG93ZXIgZXJyb3JzIGJ1YmJsZSB0byB0aGUgc2FtZSBib3VuZGFyeVxuICAgICAgaWYgKGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSA9IGVycm9yO1xuICAgICAgfVxuICAgICAgLy8gQ2xlYXIgb3VyIGFueSBwcmlvciBsb2FkZXJEYXRhIGZvciB0aGUgdGhyb3dpbmcgcm91dGVcbiAgICAgIGxvYWRlckRhdGFbaWRdID0gdW5kZWZpbmVkO1xuICAgICAgLy8gT25jZSB3ZSBmaW5kIG91ciBmaXJzdCAoaGlnaGVzdCkgZXJyb3IsIHdlIHNldCB0aGUgc3RhdHVzIGNvZGUgYW5kXG4gICAgICAvLyBwcmV2ZW50IGRlZXBlciBzdGF0dXMgY29kZXMgZnJvbSBvdmVycmlkaW5nXG4gICAgICBpZiAoIWZvdW5kRXJyb3IpIHtcbiAgICAgICAgZm91bmRFcnJvciA9IHRydWU7XG4gICAgICAgIHN0YXR1c0NvZGUgPSBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpID8gcmVzdWx0LmVycm9yLnN0YXR1cyA6IDUwMDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xuICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgIGFjdGl2ZURlZmVycmVkcy5zZXQoaWQsIHJlc3VsdC5kZWZlcnJlZERhdGEpO1xuICAgICAgICBsb2FkZXJEYXRhW2lkXSA9IHJlc3VsdC5kZWZlcnJlZERhdGEuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWRlckRhdGFbaWRdID0gcmVzdWx0LmRhdGE7XG4gICAgICB9XG4gICAgICAvLyBFcnJvciBzdGF0dXMgY29kZXMgYWx3YXlzIG92ZXJyaWRlIHN1Y2Nlc3Mgc3RhdHVzIGNvZGVzLCBidXQgaWYgYWxsXG4gICAgICAvLyBsb2FkZXJzIGFyZSBzdWNjZXNzZnVsIHdlIHRha2UgdGhlIGRlZXBlc3Qgc3RhdHVzIGNvZGUuXG4gICAgICBpZiAocmVzdWx0LnN0YXR1c0NvZGUgIT0gbnVsbCAmJiByZXN1bHQuc3RhdHVzQ29kZSAhPT0gMjAwICYmICFmb3VuZEVycm9yKSB7XG4gICAgICAgIHN0YXR1c0NvZGUgPSByZXN1bHQuc3RhdHVzQ29kZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xuICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIC8vIElmIHdlIGRpZG4ndCBjb25zdW1lIHRoZSBwZW5kaW5nIGFjdGlvbiBlcnJvciAoaS5lLiwgYWxsIGxvYWRlcnNcbiAgLy8gcmVzb2x2ZWQpLCB0aGVuIGNvbnN1bWUgaXQgaGVyZS4gIEFsc28gY2xlYXIgb3V0IGFueSBsb2FkZXJEYXRhIGZvciB0aGVcbiAgLy8gdGhyb3dpbmcgcm91dGVcbiAgaWYgKHBlbmRpbmdFcnJvcikge1xuICAgIGVycm9ycyA9IHBlbmRpbmdFcnJvcjtcbiAgICBsb2FkZXJEYXRhW09iamVjdC5rZXlzKHBlbmRpbmdFcnJvcilbMF1dID0gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB7XG4gICAgbG9hZGVyRGF0YSxcbiAgICBlcnJvcnMsXG4gICAgc3RhdHVzQ29kZTogc3RhdHVzQ29kZSB8fCAyMDAsXG4gICAgbG9hZGVySGVhZGVyc1xuICB9O1xufVxuZnVuY3Rpb24gcHJvY2Vzc0xvYWRlckRhdGEoc3RhdGUsIG1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIHJlc3VsdHMsIHBlbmRpbmdFcnJvciwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsIGZldGNoZXJSZXN1bHRzLCBhY3RpdmVEZWZlcnJlZHMpIHtcbiAgbGV0IHtcbiAgICBsb2FkZXJEYXRhLFxuICAgIGVycm9yc1xuICB9ID0gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShtYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCByZXN1bHRzLCBwZW5kaW5nRXJyb3IsIGFjdGl2ZURlZmVycmVkcyk7XG4gIC8vIFByb2Nlc3MgcmVzdWx0cyBmcm9tIG91ciByZXZhbGlkYXRpbmcgZmV0Y2hlcnNcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCB7XG4gICAgICBrZXksXG4gICAgICBtYXRjaCxcbiAgICAgIGNvbnRyb2xsZXJcbiAgICB9ID0gcmV2YWxpZGF0aW5nRmV0Y2hlcnNbaW5kZXhdO1xuICAgIGludmFyaWFudChmZXRjaGVyUmVzdWx0cyAhPT0gdW5kZWZpbmVkICYmIGZldGNoZXJSZXN1bHRzW2luZGV4XSAhPT0gdW5kZWZpbmVkLCBcIkRpZCBub3QgZmluZCBjb3JyZXNwb25kaW5nIGZldGNoZXIgcmVzdWx0XCIpO1xuICAgIGxldCByZXN1bHQgPSBmZXRjaGVyUmVzdWx0c1tpbmRleF07XG4gICAgLy8gUHJvY2VzcyBmZXRjaGVyIG5vbi1yZWRpcmVjdCBlcnJvcnNcbiAgICBpZiAoY29udHJvbGxlciAmJiBjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGRvIGZvciBhYm9ydGVkIGZldGNoZXJzXG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIG1hdGNoID09IG51bGwgPyB2b2lkIDAgOiBtYXRjaC5yb3V0ZS5pZCk7XG4gICAgICBpZiAoIShlcnJvcnMgJiYgZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdKSkge1xuICAgICAgICBlcnJvcnMgPSBfZXh0ZW5kcyh7fSwgZXJyb3JzLCB7XG4gICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICB9IGVsc2UgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgLy8gU2hvdWxkIG5ldmVyIGdldCBoZXJlLCByZWRpcmVjdHMgc2hvdWxkIGdldCBwcm9jZXNzZWQgYWJvdmUsIGJ1dCB3ZVxuICAgICAgLy8ga2VlcCB0aGlzIHRvIHR5cGUgbmFycm93IHRvIGEgc3VjY2VzcyByZXN1bHQgaW4gdGhlIGVsc2VcbiAgICAgIGludmFyaWFudChmYWxzZSwgXCJVbmhhbmRsZWQgZmV0Y2hlciByZXZhbGlkYXRpb24gcmVkaXJlY3RcIik7XG4gICAgfSBlbHNlIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFNob3VsZCBuZXZlciBnZXQgaGVyZSwgZGVmZXJyZWQgZGF0YSBzaG91bGQgYmUgYXdhaXRlZCBmb3IgZmV0Y2hlcnNcbiAgICAgIC8vIGluIHJlc29sdmVEZWZlcnJlZFJlc3VsdHNcbiAgICAgIGludmFyaWFudChmYWxzZSwgXCJVbmhhbmRsZWQgZmV0Y2hlciBkZWZlcnJlZCBkYXRhXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihyZXN1bHQuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbG9hZGVyRGF0YSxcbiAgICBlcnJvcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlTG9hZGVyRGF0YShsb2FkZXJEYXRhLCBuZXdMb2FkZXJEYXRhLCBtYXRjaGVzLCBlcnJvcnMpIHtcbiAgbGV0IG1lcmdlZExvYWRlckRhdGEgPSBfZXh0ZW5kcyh7fSwgbmV3TG9hZGVyRGF0YSk7XG4gIGZvciAobGV0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICBsZXQgaWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICBpZiAobmV3TG9hZGVyRGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIGlmIChuZXdMb2FkZXJEYXRhW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1lcmdlZExvYWRlckRhdGFbaWRdID0gbmV3TG9hZGVyRGF0YVtpZF07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb2FkZXJEYXRhW2lkXSAhPT0gdW5kZWZpbmVkICYmIG1hdGNoLnJvdXRlLmxvYWRlcikge1xuICAgICAgLy8gUHJlc2VydmUgZXhpc3Rpbmcga2V5cyBub3QgaW5jbHVkZWQgaW4gbmV3TG9hZGVyRGF0YSBhbmQgd2hlcmUgYSBsb2FkZXJcbiAgICAgIC8vIHdhc24ndCByZW1vdmVkIGJ5IEhNUlxuICAgICAgbWVyZ2VkTG9hZGVyRGF0YVtpZF0gPSBsb2FkZXJEYXRhW2lkXTtcbiAgICB9XG4gICAgaWYgKGVycm9ycyAmJiBlcnJvcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAvLyBEb24ndCBrZWVwIGFueSBsb2FkZXIgZGF0YSBiZWxvdyB0aGUgYm91bmRhcnlcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVyZ2VkTG9hZGVyRGF0YTtcbn1cbi8vIEZpbmQgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnksIGxvb2tpbmcgdXB3YXJkcyBmcm9tIHRoZSBsZWFmIHJvdXRlIChvciB0aGVcbi8vIHJvdXRlIHNwZWNpZmllZCBieSByb3V0ZUlkKSBmb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgZXJyb3IgYm91bmRhcnksXG4vLyBkZWZhdWx0aW5nIHRvIHRoZSByb290IG1hdGNoXG5mdW5jdGlvbiBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIHJvdXRlSWQpIHtcbiAgbGV0IGVsaWdpYmxlTWF0Y2hlcyA9IHJvdXRlSWQgPyBtYXRjaGVzLnNsaWNlKDAsIG1hdGNoZXMuZmluZEluZGV4KG0gPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkgKyAxKSA6IFsuLi5tYXRjaGVzXTtcbiAgcmV0dXJuIGVsaWdpYmxlTWF0Y2hlcy5yZXZlcnNlKCkuZmluZChtID0+IG0ucm91dGUuaGFzRXJyb3JCb3VuZGFyeSA9PT0gdHJ1ZSkgfHwgbWF0Y2hlc1swXTtcbn1cbmZ1bmN0aW9uIGdldFNob3J0Q2lyY3VpdE1hdGNoZXMocm91dGVzKSB7XG4gIC8vIFByZWZlciBhIHJvb3QgbGF5b3V0IHJvdXRlIGlmIHByZXNlbnQsIG90aGVyd2lzZSBzaGltIGluIGEgcm91dGUgb2JqZWN0XG4gIGxldCByb3V0ZSA9IHJvdXRlcy5sZW5ndGggPT09IDEgPyByb3V0ZXNbMF0gOiByb3V0ZXMuZmluZChyID0+IHIuaW5kZXggfHwgIXIucGF0aCB8fCByLnBhdGggPT09IFwiL1wiKSB8fCB7XG4gICAgaWQ6IFwiX19zaGltLWVycm9yLXJvdXRlX19cIlxuICB9O1xuICByZXR1cm4ge1xuICAgIG1hdGNoZXM6IFt7XG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgcGF0aG5hbWU6IFwiXCIsXG4gICAgICBwYXRobmFtZUJhc2U6IFwiXCIsXG4gICAgICByb3V0ZVxuICAgIH1dLFxuICAgIHJvdXRlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKHN0YXR1cywgX3RlbXA1KSB7XG4gIGxldCB7XG4gICAgcGF0aG5hbWUsXG4gICAgcm91dGVJZCxcbiAgICBtZXRob2QsXG4gICAgdHlwZVxuICB9ID0gX3RlbXA1ID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wNTtcbiAgbGV0IHN0YXR1c1RleHQgPSBcIlVua25vd24gU2VydmVyIEVycm9yXCI7XG4gIGxldCBlcnJvck1lc3NhZ2UgPSBcIlVua25vd24gQHJlbWl4LXJ1bi9yb3V0ZXIgZXJyb3JcIjtcbiAgaWYgKHN0YXR1cyA9PT0gNDAwKSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiQmFkIFJlcXVlc3RcIjtcbiAgICBpZiAobWV0aG9kICYmIHBhdGhuYW1lICYmIHJvdXRlSWQpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiWW91IG1hZGUgYSBcIiArIG1ldGhvZCArIFwiIHJlcXVlc3QgdG8gXFxcIlwiICsgcGF0aG5hbWUgKyBcIlxcXCIgYnV0IFwiICsgKFwiZGlkIG5vdCBwcm92aWRlIGEgYGxvYWRlcmAgZm9yIHJvdXRlIFxcXCJcIiArIHJvdXRlSWQgKyBcIlxcXCIsIFwiKSArIFwic28gdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSB0aGUgcmVxdWVzdC5cIjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZGVmZXItYWN0aW9uXCIpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiZGVmZXIoKSBpcyBub3Qgc3VwcG9ydGVkIGluIGFjdGlvbnNcIjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiaW52YWxpZC1ib2R5XCIpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiVW5hYmxlIHRvIGVuY29kZSBzdWJtaXNzaW9uIGJvZHlcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDMpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJGb3JiaWRkZW5cIjtcbiAgICBlcnJvck1lc3NhZ2UgPSBcIlJvdXRlIFxcXCJcIiArIHJvdXRlSWQgKyBcIlxcXCIgZG9lcyBub3QgbWF0Y2ggVVJMIFxcXCJcIiArIHBhdGhuYW1lICsgXCJcXFwiXCI7XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDQpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJOb3QgRm91bmRcIjtcbiAgICBlcnJvck1lc3NhZ2UgPSBcIk5vIHJvdXRlIG1hdGNoZXMgVVJMIFxcXCJcIiArIHBhdGhuYW1lICsgXCJcXFwiXCI7XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDUpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJNZXRob2QgTm90IEFsbG93ZWRcIjtcbiAgICBpZiAobWV0aG9kICYmIHBhdGhuYW1lICYmIHJvdXRlSWQpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiWW91IG1hZGUgYSBcIiArIG1ldGhvZC50b1VwcGVyQ2FzZSgpICsgXCIgcmVxdWVzdCB0byBcXFwiXCIgKyBwYXRobmFtZSArIFwiXFxcIiBidXQgXCIgKyAoXCJkaWQgbm90IHByb3ZpZGUgYW4gYGFjdGlvbmAgZm9yIHJvdXRlIFxcXCJcIiArIHJvdXRlSWQgKyBcIlxcXCIsIFwiKSArIFwic28gdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSB0aGUgcmVxdWVzdC5cIjtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZCkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gXCJJbnZhbGlkIHJlcXVlc3QgbWV0aG9kIFxcXCJcIiArIG1ldGhvZC50b1VwcGVyQ2FzZSgpICsgXCJcXFwiXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgRXJyb3JSZXNwb25zZUltcGwoc3RhdHVzIHx8IDUwMCwgc3RhdHVzVGV4dCwgbmV3IEVycm9yKGVycm9yTWVzc2FnZSksIHRydWUpO1xufVxuLy8gRmluZCBhbnkgcmV0dXJuZWQgcmVkaXJlY3QgZXJyb3JzLCBzdGFydGluZyBmcm9tIHRoZSBsb3dlc3QgbWF0Y2hcbmZ1bmN0aW9uIGZpbmRSZWRpcmVjdChyZXN1bHRzKSB7XG4gIGZvciAobGV0IGkgPSByZXN1bHRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbaV07XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBpZHg6IGlcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzdHJpcEhhc2hGcm9tUGF0aChwYXRoKSB7XG4gIGxldCBwYXJzZWRQYXRoID0gdHlwZW9mIHBhdGggPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgocGF0aCkgOiBwYXRoO1xuICByZXR1cm4gY3JlYXRlUGF0aChfZXh0ZW5kcyh7fSwgcGFyc2VkUGF0aCwge1xuICAgIGhhc2g6IFwiXCJcbiAgfSkpO1xufVxuZnVuY3Rpb24gaXNIYXNoQ2hhbmdlT25seShhLCBiKSB7XG4gIGlmIChhLnBhdGhuYW1lICE9PSBiLnBhdGhuYW1lIHx8IGEuc2VhcmNoICE9PSBiLnNlYXJjaCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYS5oYXNoID09PSBcIlwiKSB7XG4gICAgLy8gL3BhZ2UgLT4gL3BhZ2UjaGFzaFxuICAgIHJldHVybiBiLmhhc2ggIT09IFwiXCI7XG4gIH0gZWxzZSBpZiAoYS5oYXNoID09PSBiLmhhc2gpIHtcbiAgICAvLyAvcGFnZSNoYXNoIC0+IC9wYWdlI2hhc2hcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChiLmhhc2ggIT09IFwiXCIpIHtcbiAgICAvLyAvcGFnZSNoYXNoIC0+IC9wYWdlI290aGVyXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSWYgdGhlIGhhc2ggaXMgcmVtb3ZlZCB0aGUgYnJvd3NlciB3aWxsIHJlLXBlcmZvcm0gYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXJcbiAgLy8gL3BhZ2UjaGFzaCAtPiAvcGFnZVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFJlc3VsdFR5cGUuZGVmZXJyZWQ7XG59XG5mdW5jdGlvbiBpc0Vycm9yUmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3I7XG59XG5mdW5jdGlvbiBpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gKHJlc3VsdCAmJiByZXN1bHQudHlwZSkgPT09IFJlc3VsdFR5cGUucmVkaXJlY3Q7XG59XG5mdW5jdGlvbiBpc0RlZmVycmVkRGF0YSh2YWx1ZSkge1xuICBsZXQgZGVmZXJyZWQgPSB2YWx1ZTtcbiAgcmV0dXJuIGRlZmVycmVkICYmIHR5cGVvZiBkZWZlcnJlZCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZGVmZXJyZWQuZGF0YSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZGVmZXJyZWQuc3Vic2NyaWJlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGRlZmVycmVkLmNhbmNlbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZlcnJlZC5yZXNvbHZlRGF0YSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaXNSZXNwb25zZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUuc3RhdHVzID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB2YWx1ZS5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2YWx1ZS5oZWFkZXJzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZS5ib2R5ICE9PSBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3VsdCkge1xuICBpZiAoIWlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgc3RhdHVzID0gcmVzdWx0LnN0YXR1cztcbiAgbGV0IGxvY2F0aW9uID0gcmVzdWx0LmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XG4gIHJldHVybiBzdGF0dXMgPj0gMzAwICYmIHN0YXR1cyA8PSAzOTkgJiYgbG9jYXRpb24gIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzUXVlcnlSb3V0ZVJlc3BvbnNlKG9iaikge1xuICByZXR1cm4gb2JqICYmIGlzUmVzcG9uc2Uob2JqLnJlc3BvbnNlKSAmJiAob2JqLnR5cGUgPT09IFJlc3VsdFR5cGUuZGF0YSB8fCBvYmoudHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcik7XG59XG5mdW5jdGlvbiBpc1ZhbGlkTWV0aG9kKG1ldGhvZCkge1xuICByZXR1cm4gdmFsaWRSZXF1ZXN0TWV0aG9kcy5oYXMobWV0aG9kLnRvTG93ZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gaXNNdXRhdGlvbk1ldGhvZChtZXRob2QpIHtcbiAgcmV0dXJuIHZhbGlkTXV0YXRpb25NZXRob2RzLmhhcyhtZXRob2QudG9Mb3dlckNhc2UoKSk7XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlRGVmZXJyZWRSZXN1bHRzKGN1cnJlbnRNYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCByZXN1bHRzLCBzaWduYWxzLCBpc0ZldGNoZXIsIGN1cnJlbnRMb2FkZXJEYXRhKSB7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCByZXN1bHRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCByZXN1bHQgPSByZXN1bHRzW2luZGV4XTtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaGVzVG9Mb2FkW2luZGV4XTtcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgbWF0Y2gsIHRoZW4gd2UgY2FuIGhhdmUgYSBkZWZlcnJlZCByZXN1bHQgdG8gZG9cbiAgICAvLyBhbnl0aGluZyB3aXRoLiAgVGhpcyBpcyBmb3IgcmV2YWxpZGF0aW5nIGZldGNoZXJzIHdoZXJlIHRoZSByb3V0ZSB3YXNcbiAgICAvLyByZW1vdmVkIGR1cmluZyBITVJcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRNYXRjaCA9IGN1cnJlbnRNYXRjaGVzLmZpbmQobSA9PiBtLnJvdXRlLmlkID09PSBtYXRjaC5yb3V0ZS5pZCk7XG4gICAgbGV0IGlzUmV2YWxpZGF0aW5nTG9hZGVyID0gY3VycmVudE1hdGNoICE9IG51bGwgJiYgIWlzTmV3Um91dGVJbnN0YW5jZShjdXJyZW50TWF0Y2gsIG1hdGNoKSAmJiAoY3VycmVudExvYWRlckRhdGEgJiYgY3VycmVudExvYWRlckRhdGFbbWF0Y2gucm91dGUuaWRdKSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkgJiYgKGlzRmV0Y2hlciB8fCBpc1JldmFsaWRhdGluZ0xvYWRlcikpIHtcbiAgICAgIC8vIE5vdGU6IHdlIGRvIG5vdCBoYXZlIHRvIHRvdWNoIGFjdGl2ZURlZmVycmVkcyBoZXJlIHNpbmNlIHdlIHJhY2UgdGhlbVxuICAgICAgLy8gYWdhaW5zdCB0aGUgc2lnbmFsIGluIHJlc29sdmVEZWZlcnJlZERhdGEgYW5kIHRoZXknbGwgZ2V0IGFib3J0ZWRcbiAgICAgIC8vIHRoZXJlIGlmIG5lZWRlZFxuICAgICAgbGV0IHNpZ25hbCA9IHNpZ25hbHNbaW5kZXhdO1xuICAgICAgaW52YXJpYW50KHNpZ25hbCwgXCJFeHBlY3RlZCBhbiBBYm9ydFNpZ25hbCBmb3IgcmV2YWxpZGF0aW5nIGZldGNoZXIgZGVmZXJyZWQgcmVzdWx0XCIpO1xuICAgICAgYXdhaXQgcmVzb2x2ZURlZmVycmVkRGF0YShyZXN1bHQsIHNpZ25hbCwgaXNGZXRjaGVyKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHJlc3VsdCB8fCByZXN1bHRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlRGVmZXJyZWREYXRhKHJlc3VsdCwgc2lnbmFsLCB1bndyYXApIHtcbiAgaWYgKHVud3JhcCA9PT0gdm9pZCAwKSB7XG4gICAgdW53cmFwID0gZmFsc2U7XG4gIH1cbiAgbGV0IGFib3J0ZWQgPSBhd2FpdCByZXN1bHQuZGVmZXJyZWREYXRhLnJlc29sdmVEYXRhKHNpZ25hbCk7XG4gIGlmIChhYm9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh1bndyYXApIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5kYXRhLFxuICAgICAgICBkYXRhOiByZXN1bHQuZGVmZXJyZWREYXRhLnVud3JhcHBlZERhdGFcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSGFuZGxlIGFueSBUcmFja2VkUHJvbWlzZS5fZXJyb3IgdmFsdWVzIGVuY291bnRlcmVkIHdoaWxlIHVud3JhcHBpbmdcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yOiBlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICBkYXRhOiByZXN1bHQuZGVmZXJyZWREYXRhLmRhdGFcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhc05ha2VkSW5kZXhRdWVyeShzZWFyY2gpIHtcbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoKS5nZXRBbGwoXCJpbmRleFwiKS5zb21lKHYgPT4gdiA9PT0gXCJcIik7XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbikge1xuICBsZXQgc2VhcmNoID0gdHlwZW9mIGxvY2F0aW9uID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uKS5zZWFyY2ggOiBsb2NhdGlvbi5zZWFyY2g7XG4gIGlmIChtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuaW5kZXggJiYgaGFzTmFrZWRJbmRleFF1ZXJ5KHNlYXJjaCB8fCBcIlwiKSkge1xuICAgIC8vIFJldHVybiB0aGUgbGVhZiBpbmRleCByb3V0ZSB3aGVuIGluZGV4IGlzIHByZXNlbnRcbiAgICByZXR1cm4gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICB9XG4gIC8vIE90aGVyd2lzZSBncmFiIHRoZSBkZWVwZXN0IFwicGF0aCBjb250cmlidXRpbmdcIiBtYXRjaCAoaWdub3JpbmcgaW5kZXggYW5kXG4gIC8vIHBhdGhsZXNzIGxheW91dCByb3V0ZXMpXG4gIGxldCBwYXRoTWF0Y2hlcyA9IGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpO1xuICByZXR1cm4gcGF0aE1hdGNoZXNbcGF0aE1hdGNoZXMubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBnZXRTdWJtaXNzaW9uRnJvbU5hdmlnYXRpb24obmF2aWdhdGlvbikge1xuICBsZXQge1xuICAgIGZvcm1NZXRob2QsXG4gICAgZm9ybUFjdGlvbixcbiAgICBmb3JtRW5jVHlwZSxcbiAgICB0ZXh0LFxuICAgIGZvcm1EYXRhLFxuICAgIGpzb25cbiAgfSA9IG5hdmlnYXRpb247XG4gIGlmICghZm9ybU1ldGhvZCB8fCAhZm9ybUFjdGlvbiB8fCAhZm9ybUVuY1R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHRleHQgIT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICAgIHRleHRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGZvcm1EYXRhICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhLFxuICAgICAganNvbjogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfSBlbHNlIGlmIChqc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICBqc29uLFxuICAgICAgdGV4dDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TG9hZGluZ05hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24pIHtcbiAgaWYgKHN1Ym1pc3Npb24pIHtcbiAgICBsZXQgbmF2aWdhdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dFxuICAgIH07XG4gICAgcmV0dXJuIG5hdmlnYXRpb247XG4gIH0gZWxzZSB7XG4gICAgbGV0IG5hdmlnYXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAganNvbjogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICByZXR1cm4gbmF2aWdhdGlvbjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U3VibWl0dGluZ05hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24pIHtcbiAgbGV0IG5hdmlnYXRpb24gPSB7XG4gICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgIGxvY2F0aW9uLFxuICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAganNvbjogc3VibWlzc2lvbi5qc29uLFxuICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dFxuICB9O1xuICByZXR1cm4gbmF2aWdhdGlvbjtcbn1cbmZ1bmN0aW9uIGdldExvYWRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGRhdGEpIHtcbiAgaWYgKHN1Ym1pc3Npb24pIHtcbiAgICBsZXQgZmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gZmV0Y2hlcjtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAganNvbjogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdW5kZWZpbmVkLFxuICAgICAgZGF0YVxuICAgIH07XG4gICAgcmV0dXJuIGZldGNoZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN1Ym1pdHRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGV4aXN0aW5nRmV0Y2hlcikge1xuICBsZXQgZmV0Y2hlciA9IHtcbiAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICBmb3JtRW5jVHlwZTogc3VibWlzc2lvbi5mb3JtRW5jVHlwZSxcbiAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgdGV4dDogc3VibWlzc2lvbi50ZXh0LFxuICAgIGRhdGE6IGV4aXN0aW5nRmV0Y2hlciA/IGV4aXN0aW5nRmV0Y2hlci5kYXRhIDogdW5kZWZpbmVkXG4gIH07XG4gIHJldHVybiBmZXRjaGVyO1xufVxuZnVuY3Rpb24gZ2V0RG9uZUZldGNoZXIoZGF0YSkge1xuICBsZXQgZmV0Y2hlciA9IHtcbiAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAganNvbjogdW5kZWZpbmVkLFxuICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICBkYXRhXG4gIH07XG4gIHJldHVybiBmZXRjaGVyO1xufVxuZnVuY3Rpb24gcmVzdG9yZUFwcGxpZWRUcmFuc2l0aW9ucyhfd2luZG93LCB0cmFuc2l0aW9ucykge1xuICB0cnkge1xuICAgIGxldCBzZXNzaW9uUG9zaXRpb25zID0gX3dpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFRSQU5TSVRJT05TX1NUT1JBR0VfS0VZKTtcbiAgICBpZiAoc2Vzc2lvblBvc2l0aW9ucykge1xuICAgICAgbGV0IGpzb24gPSBKU09OLnBhcnNlKHNlc3Npb25Qb3NpdGlvbnMpO1xuICAgICAgZm9yIChsZXQgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKGpzb24gfHwge30pKSB7XG4gICAgICAgIGlmICh2ICYmIEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICB0cmFuc2l0aW9ucy5zZXQoaywgbmV3IFNldCh2IHx8IFtdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBuby1vcCwgdXNlIGRlZmF1bHQgZW1wdHkgb2JqZWN0XG4gIH1cbn1cbmZ1bmN0aW9uIHBlcnNpc3RBcHBsaWVkVHJhbnNpdGlvbnMoX3dpbmRvdywgdHJhbnNpdGlvbnMpIHtcbiAgaWYgKHRyYW5zaXRpb25zLnNpemUgPiAwKSB7XG4gICAgbGV0IGpzb24gPSB7fTtcbiAgICBmb3IgKGxldCBbaywgdl0gb2YgdHJhbnNpdGlvbnMpIHtcbiAgICAgIGpzb25ba10gPSBbLi4udl07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBfd2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oVFJBTlNJVElPTlNfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KGpzb24pKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgd2FybmluZyhmYWxzZSwgXCJGYWlsZWQgdG8gc2F2ZSBhcHBsaWVkIHZpZXcgdHJhbnNpdGlvbnMgaW4gc2Vzc2lvblN0b3JhZ2UgKFwiICsgZXJyb3IgKyBcIikuXCIpO1xuICAgIH1cbiAgfVxufVxuLy8jZW5kcmVnaW9uXG5cbmV4cG9ydCB7IEFib3J0ZWREZWZlcnJlZEVycm9yLCBBY3Rpb24sIElETEVfQkxPQ0tFUiwgSURMRV9GRVRDSEVSLCBJRExFX05BVklHQVRJT04sIFVOU0FGRV9ERUZFUlJFRF9TWU1CT0wsIERlZmVycmVkRGF0YSBhcyBVTlNBRkVfRGVmZXJyZWREYXRhLCBFcnJvclJlc3BvbnNlSW1wbCBhcyBVTlNBRkVfRXJyb3JSZXNwb25zZUltcGwsIGNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoIGFzIFVOU0FGRV9jb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaCwgY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyBhcyBVTlNBRkVfY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcywgZ2V0UmVzb2x2ZVRvTWF0Y2hlcyBhcyBVTlNBRkVfZ2V0UmVzb2x2ZVRvTWF0Y2hlcywgaW52YXJpYW50IGFzIFVOU0FGRV9pbnZhcmlhbnQsIHdhcm5pbmcgYXMgVU5TQUZFX3dhcm5pbmcsIGNyZWF0ZUJyb3dzZXJIaXN0b3J5LCBjcmVhdGVIYXNoSGlzdG9yeSwgY3JlYXRlTWVtb3J5SGlzdG9yeSwgY3JlYXRlUGF0aCwgY3JlYXRlUm91dGVyLCBjcmVhdGVTdGF0aWNIYW5kbGVyLCBkZWZlciwgZ2VuZXJhdGVQYXRoLCBnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yLCBnZXRUb1BhdGhuYW1lLCBpc0RlZmVycmVkRGF0YSwgaXNSb3V0ZUVycm9yUmVzcG9uc2UsIGpvaW5QYXRocywganNvbiwgbWF0Y2hQYXRoLCBtYXRjaFJvdXRlcywgbm9ybWFsaXplUGF0aG5hbWUsIHBhcnNlUGF0aCwgcmVkaXJlY3QsIHJlZGlyZWN0RG9jdW1lbnQsIHJlc29sdmVQYXRoLCByZXNvbHZlVG8sIHN0cmlwQmFzZW5hbWUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsIk9iamVjdCIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJBY3Rpb24iLCJQb3BTdGF0ZUV2ZW50VHlwZSIsImNyZWF0ZU1lbW9yeUhpc3RvcnkiLCJvcHRpb25zIiwiaW5pdGlhbEVudHJpZXMiLCJpbml0aWFsSW5kZXgiLCJ2NUNvbXBhdCIsImVudHJpZXMiLCJtYXAiLCJlbnRyeSIsImluZGV4IiwiY3JlYXRlTWVtb3J5TG9jYXRpb24iLCJzdGF0ZSIsInVuZGVmaW5lZCIsImNsYW1wSW5kZXgiLCJhY3Rpb24iLCJQb3AiLCJsaXN0ZW5lciIsIm4iLCJNYXRoIiwibWluIiwibWF4IiwiZ2V0Q3VycmVudExvY2F0aW9uIiwidG8iLCJsb2NhdGlvbiIsImNyZWF0ZUxvY2F0aW9uIiwicGF0aG5hbWUiLCJ3YXJuaW5nIiwiY2hhckF0IiwiSlNPTiIsInN0cmluZ2lmeSIsImNyZWF0ZUhyZWYiLCJjcmVhdGVQYXRoIiwiaGlzdG9yeSIsImNyZWF0ZVVSTCIsIlVSTCIsImVuY29kZUxvY2F0aW9uIiwicGF0aCIsInBhcnNlUGF0aCIsInNlYXJjaCIsImhhc2giLCJwdXNoIiwiUHVzaCIsIm5leHRMb2NhdGlvbiIsInNwbGljZSIsImRlbHRhIiwicmVwbGFjZSIsIlJlcGxhY2UiLCJnbyIsIm5leHRJbmRleCIsImxpc3RlbiIsImZuIiwiY3JlYXRlQnJvd3Nlckhpc3RvcnkiLCJjcmVhdGVCcm93c2VyTG9jYXRpb24iLCJ3aW5kb3ciLCJnbG9iYWxIaXN0b3J5IiwidXNyIiwiY3JlYXRlQnJvd3NlckhyZWYiLCJnZXRVcmxCYXNlZEhpc3RvcnkiLCJjcmVhdGVIYXNoSGlzdG9yeSIsImNyZWF0ZUhhc2hMb2NhdGlvbiIsInN1YnN0ciIsInN0YXJ0c1dpdGgiLCJjcmVhdGVIYXNoSHJlZiIsImJhc2UiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJocmVmIiwiZ2V0QXR0cmlidXRlIiwidXJsIiwiaGFzaEluZGV4IiwiaW5kZXhPZiIsInNsaWNlIiwidmFsaWRhdGVIYXNoTG9jYXRpb24iLCJpbnZhcmlhbnQiLCJ2YWx1ZSIsIm1lc3NhZ2UiLCJFcnJvciIsImNvbmQiLCJjb25zb2xlIiwid2FybiIsImUiLCJjcmVhdGVLZXkiLCJyYW5kb20iLCJ0b1N0cmluZyIsImdldEhpc3RvcnlTdGF0ZSIsImlkeCIsImN1cnJlbnQiLCJfcmVmIiwicGFyc2VkUGF0aCIsInNlYXJjaEluZGV4IiwiZ2V0TG9jYXRpb24iLCJ2YWxpZGF0ZUxvY2F0aW9uIiwiZGVmYXVsdFZpZXciLCJnZXRJbmRleCIsInJlcGxhY2VTdGF0ZSIsImhhbmRsZVBvcCIsImhpc3RvcnlTdGF0ZSIsInB1c2hTdGF0ZSIsImVycm9yIiwiRE9NRXhjZXB0aW9uIiwibmFtZSIsIm9yaWdpbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiUmVzdWx0VHlwZSIsImltbXV0YWJsZVJvdXRlS2V5cyIsIlNldCIsImlzSW5kZXhSb3V0ZSIsInJvdXRlIiwiY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyIsInJvdXRlcyIsIm1hcFJvdXRlUHJvcGVydGllcyIsInBhcmVudFBhdGgiLCJtYW5pZmVzdCIsInRyZWVQYXRoIiwiaWQiLCJqb2luIiwiY2hpbGRyZW4iLCJpbmRleFJvdXRlIiwicGF0aE9yTGF5b3V0Um91dGUiLCJtYXRjaFJvdXRlcyIsImxvY2F0aW9uQXJnIiwiYmFzZW5hbWUiLCJzdHJpcEJhc2VuYW1lIiwiYnJhbmNoZXMiLCJmbGF0dGVuUm91dGVzIiwicmFua1JvdXRlQnJhbmNoZXMiLCJtYXRjaGVzIiwiZGVjb2RlZCIsImRlY29kZVBhdGgiLCJtYXRjaFJvdXRlQnJhbmNoIiwiY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2giLCJtYXRjaCIsImxvYWRlckRhdGEiLCJwYXJhbXMiLCJkYXRhIiwiaGFuZGxlIiwicGFyZW50c01ldGEiLCJmbGF0dGVuUm91dGUiLCJyZWxhdGl2ZVBhdGgiLCJtZXRhIiwiY2FzZVNlbnNpdGl2ZSIsImNoaWxkcmVuSW5kZXgiLCJqb2luUGF0aHMiLCJyb3V0ZXNNZXRhIiwiY29uY2F0Iiwic2NvcmUiLCJjb21wdXRlU2NvcmUiLCJmb3JFYWNoIiwiX3JvdXRlJHBhdGgiLCJpbmNsdWRlcyIsImV4cGxvZGVkIiwiZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMiLCJzZWdtZW50cyIsInNwbGl0IiwiZmlyc3QiLCJyZXN0IiwiaXNPcHRpb25hbCIsImVuZHNXaXRoIiwicmVxdWlyZWQiLCJyZXN0RXhwbG9kZWQiLCJyZXN1bHQiLCJzdWJwYXRoIiwic29ydCIsImEiLCJiIiwiY29tcGFyZUluZGV4ZXMiLCJwYXJhbVJlIiwiZHluYW1pY1NlZ21lbnRWYWx1ZSIsImluZGV4Um91dGVWYWx1ZSIsImVtcHR5U2VnbWVudFZhbHVlIiwic3RhdGljU2VnbWVudFZhbHVlIiwic3BsYXRQZW5hbHR5IiwiaXNTcGxhdCIsInMiLCJpbml0aWFsU2NvcmUiLCJzb21lIiwiZmlsdGVyIiwicmVkdWNlIiwic2VnbWVudCIsInRlc3QiLCJzaWJsaW5ncyIsImV2ZXJ5IiwiYnJhbmNoIiwibWF0Y2hlZFBhcmFtcyIsIm1hdGNoZWRQYXRobmFtZSIsImVuZCIsInJlbWFpbmluZ1BhdGhuYW1lIiwibWF0Y2hQYXRoIiwicGF0aG5hbWVCYXNlIiwibm9ybWFsaXplUGF0aG5hbWUiLCJnZW5lcmF0ZVBhdGgiLCJvcmlnaW5hbFBhdGgiLCJwcmVmaXgiLCJwIiwiU3RyaW5nIiwiYXJyYXkiLCJpc0xhc3RTZWdtZW50Iiwic3RhciIsImtleU1hdGNoIiwib3B0aW9uYWwiLCJwYXJhbSIsInBhdHRlcm4iLCJtYXRjaGVyIiwiY29tcGlsZWRQYXJhbXMiLCJjb21waWxlUGF0aCIsImNhcHR1cmVHcm91cHMiLCJtZW1vIiwicGFyYW1OYW1lIiwic3BsYXRWYWx1ZSIsInJlZ2V4cFNvdXJjZSIsIl8iLCJSZWdFeHAiLCJ2IiwiZGVjb2RlVVJJQ29tcG9uZW50IiwidG9Mb3dlckNhc2UiLCJzdGFydEluZGV4IiwibmV4dENoYXIiLCJyZXNvbHZlUGF0aCIsImZyb21QYXRobmFtZSIsInRvUGF0aG5hbWUiLCJyZXNvbHZlUGF0aG5hbWUiLCJub3JtYWxpemVTZWFyY2giLCJub3JtYWxpemVIYXNoIiwicmVsYXRpdmVTZWdtZW50cyIsInBvcCIsImdldEludmFsaWRQYXRoRXJyb3IiLCJjaGFyIiwiZmllbGQiLCJkZXN0IiwiZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMiLCJnZXRSZXNvbHZlVG9NYXRjaGVzIiwidjdfcmVsYXRpdmVTcGxhdFBhdGgiLCJwYXRoTWF0Y2hlcyIsInJlc29sdmVUbyIsInRvQXJnIiwicm91dGVQYXRobmFtZXMiLCJsb2NhdGlvblBhdGhuYW1lIiwiaXNQYXRoUmVsYXRpdmUiLCJpc0VtcHR5UGF0aCIsImZyb20iLCJyb3V0ZVBhdGhuYW1lSW5kZXgiLCJ0b1NlZ21lbnRzIiwic2hpZnQiLCJoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2giLCJoYXNDdXJyZW50VHJhaWxpbmdTbGFzaCIsImdldFRvUGF0aG5hbWUiLCJwYXRocyIsImpzb24iLCJpbml0IiwicmVzcG9uc2VJbml0Iiwic3RhdHVzIiwiaGVhZGVycyIsIkhlYWRlcnMiLCJoYXMiLCJzZXQiLCJSZXNwb25zZSIsIkFib3J0ZWREZWZlcnJlZEVycm9yIiwiRGVmZXJyZWREYXRhIiwiY29uc3RydWN0b3IiLCJwZW5kaW5nS2V5c1NldCIsInN1YnNjcmliZXJzIiwiZGVmZXJyZWRLZXlzIiwiQXJyYXkiLCJpc0FycmF5IiwicmVqZWN0IiwiYWJvcnRQcm9taXNlIiwiUHJvbWlzZSIsInIiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwib25BYm9ydCIsInVubGlzdGVuQWJvcnRTaWduYWwiLCJzaWduYWwiLCJhY2MiLCJfcmVmMiIsInRyYWNrUHJvbWlzZSIsImRvbmUiLCJhZGQiLCJwcm9taXNlIiwicmFjZSIsInRoZW4iLCJvblNldHRsZSIsImNhdGNoIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJhYm9ydGVkIiwiZGVsZXRlIiwidW5kZWZpbmVkRXJyb3IiLCJlbWl0Iiwic2V0dGxlZEtleSIsInN1YnNjcmliZXIiLCJzdWJzY3JpYmUiLCJjYW5jZWwiLCJhYm9ydCIsImsiLCJyZXNvbHZlRGF0YSIsInJlc29sdmUiLCJzaXplIiwidW53cmFwcGVkRGF0YSIsIl9yZWYzIiwidW53cmFwVHJhY2tlZFByb21pc2UiLCJwZW5kaW5nS2V5cyIsImlzVHJhY2tlZFByb21pc2UiLCJfdHJhY2tlZCIsIl9lcnJvciIsIl9kYXRhIiwiZGVmZXIiLCJyZWRpcmVjdCIsInJlZGlyZWN0RG9jdW1lbnQiLCJyZXNwb25zZSIsIkVycm9yUmVzcG9uc2VJbXBsIiwic3RhdHVzVGV4dCIsImludGVybmFsIiwiaXNSb3V0ZUVycm9yUmVzcG9uc2UiLCJ2YWxpZE11dGF0aW9uTWV0aG9kc0FyciIsInZhbGlkTXV0YXRpb25NZXRob2RzIiwidmFsaWRSZXF1ZXN0TWV0aG9kc0FyciIsInZhbGlkUmVxdWVzdE1ldGhvZHMiLCJyZWRpcmVjdFN0YXR1c0NvZGVzIiwicmVkaXJlY3RQcmVzZXJ2ZU1ldGhvZFN0YXR1c0NvZGVzIiwiSURMRV9OQVZJR0FUSU9OIiwiZm9ybU1ldGhvZCIsImZvcm1BY3Rpb24iLCJmb3JtRW5jVHlwZSIsImZvcm1EYXRhIiwidGV4dCIsIklETEVfRkVUQ0hFUiIsIklETEVfQkxPQ0tFUiIsInByb2NlZWQiLCJyZXNldCIsIkFCU09MVVRFX1VSTF9SRUdFWCIsImRlZmF1bHRNYXBSb3V0ZVByb3BlcnRpZXMiLCJoYXNFcnJvckJvdW5kYXJ5IiwiQm9vbGVhbiIsIlRSQU5TSVRJT05TX1NUT1JBR0VfS0VZIiwiY3JlYXRlUm91dGVyIiwicm91dGVyV2luZG93IiwiaXNCcm93c2VyIiwiY3JlYXRlRWxlbWVudCIsImlzU2VydmVyIiwiZGV0ZWN0RXJyb3JCb3VuZGFyeSIsImRhdGFSb3V0ZXMiLCJpbkZsaWdodERhdGFSb3V0ZXMiLCJmdXR1cmUiLCJ2N19mZXRjaGVyUGVyc2lzdCIsInY3X25vcm1hbGl6ZUZvcm1NZXRob2QiLCJ2N19wYXJ0aWFsSHlkcmF0aW9uIiwidjdfcHJlcGVuZEJhc2VuYW1lIiwidW5saXN0ZW5IaXN0b3J5Iiwic2F2ZWRTY3JvbGxQb3NpdGlvbnMiLCJnZXRTY3JvbGxSZXN0b3JhdGlvbktleSIsImdldFNjcm9sbFBvc2l0aW9uIiwiaW5pdGlhbFNjcm9sbFJlc3RvcmVkIiwiaHlkcmF0aW9uRGF0YSIsImluaXRpYWxNYXRjaGVzIiwiaW5pdGlhbEVycm9ycyIsImdldEludGVybmFsUm91dGVyRXJyb3IiLCJnZXRTaG9ydENpcmN1aXRNYXRjaGVzIiwiaW5pdGlhbGl6ZWQiLCJoYXNMYXp5Um91dGVzIiwibSIsImxhenkiLCJoYXNMb2FkZXJzIiwibG9hZGVyIiwiZXJyb3JzIiwiaXNSb3V0ZUluaXRpYWxpemVkIiwiaHlkcmF0ZSIsImZpbmRJbmRleCIsInJvdXRlciIsImhpc3RvcnlBY3Rpb24iLCJuYXZpZ2F0aW9uIiwicmVzdG9yZVNjcm9sbFBvc2l0aW9uIiwicHJldmVudFNjcm9sbFJlc2V0IiwicmV2YWxpZGF0aW9uIiwiYWN0aW9uRGF0YSIsImZldGNoZXJzIiwiTWFwIiwiYmxvY2tlcnMiLCJwZW5kaW5nQWN0aW9uIiwicGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCIsInBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciIsInBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQiLCJhcHBsaWVkVmlld1RyYW5zaXRpb25zIiwicmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyIiwiaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uIiwiaXNSZXZhbGlkYXRpb25SZXF1aXJlZCIsImNhbmNlbGxlZERlZmVycmVkUm91dGVzIiwiY2FuY2VsbGVkRmV0Y2hlckxvYWRzIiwiZmV0Y2hDb250cm9sbGVycyIsImluY3JlbWVudGluZ0xvYWRJZCIsInBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkIiwiZmV0Y2hSZWxvYWRJZHMiLCJmZXRjaFJlZGlyZWN0SWRzIiwiZmV0Y2hMb2FkTWF0Y2hlcyIsImFjdGl2ZUZldGNoZXJzIiwiZGVsZXRlZEZldGNoZXJzIiwiYWN0aXZlRGVmZXJyZWRzIiwiYmxvY2tlckZ1bmN0aW9ucyIsImlnbm9yZU5leHRIaXN0b3J5VXBkYXRlIiwiaW5pdGlhbGl6ZSIsImJsb2NrZXJLZXkiLCJzaG91bGRCbG9ja05hdmlnYXRpb24iLCJjdXJyZW50TG9jYXRpb24iLCJ1cGRhdGVCbG9ja2VyIiwidXBkYXRlU3RhdGUiLCJzdGFydE5hdmlnYXRpb24iLCJyZXN0b3JlQXBwbGllZFRyYW5zaXRpb25zIiwiX3NhdmVBcHBsaWVkVHJhbnNpdGlvbnMiLCJwZXJzaXN0QXBwbGllZFRyYW5zaXRpb25zIiwiaW5pdGlhbEh5ZHJhdGlvbiIsImRpc3Bvc2UiLCJjbGVhciIsImRlbGV0ZUZldGNoZXIiLCJkZWxldGVCbG9ja2VyIiwibmV3U3RhdGUiLCJvcHRzIiwiY29tcGxldGVkRmV0Y2hlcnMiLCJkZWxldGVkRmV0Y2hlcnNLZXlzIiwiZmV0Y2hlciIsInVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uT3B0cyIsInZpZXdUcmFuc2l0aW9uT3B0cyIsInVuc3RhYmxlX2ZsdXNoU3luYyIsImZsdXNoU3luYyIsImNvbXBsZXRlTmF2aWdhdGlvbiIsIl90ZW1wIiwiX2xvY2F0aW9uJHN0YXRlIiwiX2xvY2F0aW9uJHN0YXRlMiIsImlzQWN0aW9uUmVsb2FkIiwiaXNNdXRhdGlvbk1ldGhvZCIsIl9pc1JlZGlyZWN0Iiwia2V5cyIsIm1lcmdlTG9hZGVyRGF0YSIsInByaW9yUGF0aHMiLCJ0b1BhdGhzIiwiZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbiIsIm5hdmlnYXRlIiwibm9ybWFsaXplZFBhdGgiLCJub3JtYWxpemVUbyIsImZyb21Sb3V0ZUlkIiwicmVsYXRpdmUiLCJzdWJtaXNzaW9uIiwibm9ybWFsaXplTmF2aWdhdGVPcHRpb25zIiwidXNlclJlcGxhY2UiLCJwZW5kaW5nRXJyb3IiLCJlbmFibGVWaWV3VHJhbnNpdGlvbiIsInVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uIiwicmV2YWxpZGF0ZSIsImludGVycnVwdEFjdGl2ZUxvYWRzIiwic3RhcnRVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uIiwib3ZlcnJpZGVOYXZpZ2F0aW9uIiwic2F2ZVNjcm9sbFBvc2l0aW9uIiwicm91dGVzVG9Vc2UiLCJsb2FkaW5nTmF2aWdhdGlvbiIsIm5vdEZvdW5kTWF0Y2hlcyIsImNhbmNlbEFjdGl2ZURlZmVycmVkcyIsImlzSGFzaENoYW5nZU9ubHkiLCJyZXF1ZXN0IiwiY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QiLCJwZW5kaW5nQWN0aW9uRGF0YSIsImZpbmROZWFyZXN0Qm91bmRhcnkiLCJhY3Rpb25PdXRwdXQiLCJoYW5kbGVBY3Rpb24iLCJzaG9ydENpcmN1aXRlZCIsInBlbmRpbmdBY3Rpb25FcnJvciIsImdldExvYWRpbmdOYXZpZ2F0aW9uIiwiUmVxdWVzdCIsImhhbmRsZUxvYWRlcnMiLCJmZXRjaGVyU3VibWlzc2lvbiIsImdldFN1Ym1pdHRpbmdOYXZpZ2F0aW9uIiwiYWN0aW9uTWF0Y2giLCJnZXRUYXJnZXRNYXRjaCIsInR5cGUiLCJtZXRob2QiLCJyb3V0ZUlkIiwiY2FsbExvYWRlck9yQWN0aW9uIiwiaXNSZWRpcmVjdFJlc3VsdCIsInN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uIiwiaXNFcnJvclJlc3VsdCIsImJvdW5kYXJ5TWF0Y2giLCJpc0RlZmVycmVkUmVzdWx0IiwiYWN0aXZlU3VibWlzc2lvbiIsImdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbiIsIm1hdGNoZXNUb0xvYWQiLCJyZXZhbGlkYXRpbmdGZXRjaGVycyIsImdldE1hdGNoZXNUb0xvYWQiLCJ1cGRhdGVkRmV0Y2hlcnMiLCJtYXJrRmV0Y2hSZWRpcmVjdHNEb25lIiwicmYiLCJyZXZhbGlkYXRpbmdGZXRjaGVyIiwiZ2V0TG9hZGluZ0ZldGNoZXIiLCJhYm9ydEZldGNoZXIiLCJhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMiLCJmIiwicmVzdWx0cyIsImxvYWRlclJlc3VsdHMiLCJmZXRjaGVyUmVzdWx0cyIsImNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YSIsImZpbmRSZWRpcmVjdCIsImZldGNoZXJLZXkiLCJwcm9jZXNzTG9hZGVyRGF0YSIsImRlZmVycmVkRGF0YSIsImRpZEFib3J0RmV0Y2hMb2FkcyIsImFib3J0U3RhbGVGZXRjaExvYWRzIiwic2hvdWxkVXBkYXRlRmV0Y2hlcnMiLCJmZXRjaCIsInNldEZldGNoZXJFcnJvciIsImhhbmRsZUZldGNoZXJBY3Rpb24iLCJoYW5kbGVGZXRjaGVyTG9hZGVyIiwicmVxdWVzdE1hdGNoZXMiLCJleGlzdGluZ0ZldGNoZXIiLCJ1cGRhdGVGZXRjaGVyU3RhdGUiLCJnZXRTdWJtaXR0aW5nRmV0Y2hlciIsImFib3J0Q29udHJvbGxlciIsImZldGNoUmVxdWVzdCIsIm9yaWdpbmF0aW5nTG9hZElkIiwiYWN0aW9uUmVzdWx0IiwiZ2V0RG9uZUZldGNoZXIiLCJyZXZhbGlkYXRpb25SZXF1ZXN0IiwibG9hZElkIiwibG9hZEZldGNoZXIiLCJzdGFsZUtleSIsImRvbmVGZXRjaGVyIiwicmVzb2x2ZURlZmVycmVkRGF0YSIsIl90ZW1wMiIsInJlZGlyZWN0TG9jYXRpb24iLCJpc0RvY3VtZW50UmVsb2FkIiwicmVsb2FkRG9jdW1lbnQiLCJyZWRpcmVjdEhpc3RvcnlBY3Rpb24iLCJjdXJyZW50TWF0Y2hlcyIsImZldGNoZXJzVG9Mb2FkIiwiYWxsIiwicmVzb2x2ZURlZmVycmVkUmVzdWx0cyIsImdldEZldGNoZXIiLCJkZWxldGVGZXRjaGVyQW5kVXBkYXRlU3RhdGUiLCJjb3VudCIsIm1hcmtGZXRjaGVyc0RvbmUiLCJkb25lS2V5cyIsImxhbmRlZElkIiwieWVldGVkS2V5cyIsImdldEJsb2NrZXIiLCJibG9ja2VyIiwibmV3QmxvY2tlciIsIl9yZWY0IiwiYmxvY2tlckZ1bmN0aW9uIiwicHJlZGljYXRlIiwiY2FuY2VsbGVkUm91dGVJZHMiLCJkZmQiLCJlbmFibGVTY3JvbGxSZXN0b3JhdGlvbiIsInBvc2l0aW9ucyIsImdldFBvc2l0aW9uIiwiZ2V0S2V5IiwieSIsImdldFNjcm9sbEtleSIsIl9pbnRlcm5hbFNldFJvdXRlcyIsIm5ld1JvdXRlcyIsIl9pbnRlcm5hbEZldGNoQ29udHJvbGxlcnMiLCJfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHMiLCJVTlNBRkVfREVGRVJSRURfU1lNQk9MIiwiU3ltYm9sIiwiY3JlYXRlU3RhdGljSGFuZGxlciIsInY3X3Rocm93QWJvcnRSZWFzb24iLCJxdWVyeSIsIl90ZW1wMyIsInJlcXVlc3RDb250ZXh0IiwiaXNWYWxpZE1ldGhvZCIsIm1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzIiwic3RhdHVzQ29kZSIsImxvYWRlckhlYWRlcnMiLCJhY3Rpb25IZWFkZXJzIiwicXVlcnlJbXBsIiwiaXNSZXNwb25zZSIsInF1ZXJ5Um91dGUiLCJfdGVtcDQiLCJmaW5kIiwidmFsdWVzIiwiX3Jlc3VsdCRhY3RpdmVEZWZlcnJlIiwicm91dGVNYXRjaCIsInN1Ym1pdCIsImxvYWRSb3V0ZURhdGEiLCJpc1F1ZXJ5Um91dGVSZXNwb25zZSIsImlzUmVkaXJlY3RSZXNwb25zZSIsImlzUm91dGVSZXF1ZXN0IiwiaXNTdGF0aWNSZXF1ZXN0IiwidGhyb3dTdGF0aWNIYW5kbGVyQWJvcnRlZEVycm9yIiwiTG9jYXRpb24iLCJjb250ZXh0IiwibG9hZGVyUmVxdWVzdCIsImdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5IiwicHJvY2Vzc1JvdXRlTG9hZGVyRGF0YSIsImV4ZWN1dGVkTG9hZGVycyIsImZyb21FbnRyaWVzIiwiZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvciIsIm5ld0NvbnRleHQiLCJfZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCIsInJlYXNvbiIsImlzU3VibWlzc2lvbk5hdmlnYXRpb24iLCJib2R5IiwicHJlcGVuZEJhc2VuYW1lIiwiY29udGV4dHVhbE1hdGNoZXMiLCJhY3RpdmVSb3V0ZU1hdGNoIiwiaGFzTmFrZWRJbmRleFF1ZXJ5Iiwibm9ybWFsaXplRm9ybU1ldGhvZCIsImlzRmV0Y2hlciIsImdldEludmFsaWRCb2R5RXJyb3IiLCJyYXdGb3JtTWV0aG9kIiwidG9VcHBlckNhc2UiLCJzdHJpcEhhc2hGcm9tUGF0aCIsIkZvcm1EYXRhIiwiVVJMU2VhcmNoUGFyYW1zIiwiX3JlZjUiLCJwYXJzZSIsInNlYXJjaFBhcmFtcyIsImNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zIiwiY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEiLCJhcHBlbmQiLCJib3VuZGFyeUlkIiwiYm91bmRhcnlNYXRjaGVzIiwiaXNJbml0aWFsTG9hZCIsImN1cnJlbnRVcmwiLCJuZXh0VXJsIiwibmF2aWdhdGlvbk1hdGNoZXMiLCJpc05ld0xvYWRlciIsImN1cnJlbnRSb3V0ZU1hdGNoIiwibmV4dFJvdXRlTWF0Y2giLCJzaG91bGRSZXZhbGlkYXRlTG9hZGVyIiwiY3VycmVudFBhcmFtcyIsIm5leHRQYXJhbXMiLCJkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZSIsImlzTmV3Um91dGVJbnN0YW5jZSIsImZldGNoZXJNYXRjaGVzIiwiZmV0Y2hlck1hdGNoIiwic2hvdWxkUmV2YWxpZGF0ZSIsImN1cnJlbnRMb2FkZXJEYXRhIiwiY3VycmVudE1hdGNoIiwiaXNOZXciLCJpc01pc3NpbmdEYXRhIiwiY3VycmVudFBhdGgiLCJsb2FkZXJNYXRjaCIsImFyZyIsInJvdXRlQ2hvaWNlIiwibG9hZExhenlSb3V0ZU1vZHVsZSIsImxhenlSb3V0ZSIsInJvdXRlVG9VcGRhdGUiLCJyb3V0ZVVwZGF0ZXMiLCJsYXp5Um91dGVQcm9wZXJ0eSIsInN0YXRpY1JvdXRlVmFsdWUiLCJpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQiLCJyZXN1bHRUeXBlIiwib25SZWplY3QiLCJydW5IYW5kbGVyIiwiaGFuZGxlciIsImhhbmRsZXJFcnJvciIsInByb3RvY29sIiwiaXNTYW1lQmFzZW5hbWUiLCJxdWVyeVJvdXRlUmVzcG9uc2UiLCJjb250ZW50VHlwZSIsImlzRGVmZXJyZWREYXRhIiwiX3Jlc3VsdCRpbml0IiwiX3Jlc3VsdCRpbml0MiIsImRlZmVycmVkIiwiZm91bmRFcnJvciIsIm5ld0xvYWRlckRhdGEiLCJtZXJnZWRMb2FkZXJEYXRhIiwiZWxpZ2libGVNYXRjaGVzIiwicmV2ZXJzZSIsIl90ZW1wNSIsImVycm9yTWVzc2FnZSIsIm9iaiIsInNpZ25hbHMiLCJpc1JldmFsaWRhdGluZ0xvYWRlciIsInVud3JhcCIsImdldEFsbCIsIl93aW5kb3ciLCJ0cmFuc2l0aW9ucyIsInNlc3Npb25Qb3NpdGlvbnMiLCJzZXNzaW9uU3RvcmFnZSIsImdldEl0ZW0iLCJzZXRJdGVtIiwiVU5TQUZFX0RlZmVycmVkRGF0YSIsIlVOU0FGRV9FcnJvclJlc3BvbnNlSW1wbCIsIlVOU0FGRV9jb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaCIsIlVOU0FGRV9jb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzIiwiVU5TQUZFX2dldFJlc29sdmVUb01hdGNoZXMiLCJVTlNBRkVfaW52YXJpYW50IiwiVU5TQUZFX3dhcm5pbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@remix-run/router/dist/router.js\n");

/***/ })

};
;